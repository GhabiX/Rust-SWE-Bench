{"org": "bincode-org", "repo": "bincode", "number": 434, "state": "closed", "title": "fake", "body": "fake", "base": {"label": "fake", "ref": "fake", "sha": "a2e7e0e3fc7b838dae9df3b6c358acb2725f5f52"}, "resolved_issues": [{"number": "433", "title": "fake", "body": "Figure out bincode Decode/Encode interop with serde\nCurrently bincode 2 only allows either `Decode/Encode`, or serde's traits. It would be nice to have a way to use serde types while using `Decode/Encode`\r\n\r\nSome ideas:\r\n- Add an `#[serde_interop]` attribute to `bincode_derive`\r\n- Add a `WithSerde<T>` that implements `Decode/Encode`\r\n- Disable the default impl for `Decode/Encode` and replace it with something like:\r\n  - `impl Decode for T where T: Deserialize`\r\n  - `impl Encode for T where T: Serialize`\n"}], "fix_patch": "diff --git a/derive/src/derive_enum.rs b/derive/src/derive_enum.rs\n--- a/derive/src/derive_enum.rs\n+++ b/derive/src/derive_enum.rs\n@@ -1,5 +1,5 @@\n use crate::generate::{FnSelfArg, Generator, StreamBuilder};\n-use crate::parse::{EnumVariant, Fields};\n+use crate::parse::{EnumVariant, FieldAttribute, Fields};\n use crate::prelude::*;\n use crate::Result;\n \ndiff --git a/derive/src/derive_enum.rs b/derive/src/derive_enum.rs\n--- a/derive/src/derive_enum.rs\n+++ b/derive/src/derive_enum.rs\n@@ -80,11 +80,19 @@ impl DeriveEnum {\n                             body.punct(';');\n                             // If we have any fields, encode them all one by one\n                             for field_name in variant.fields.names() {\n-                                body.push_parsed(format!(\n-                                    \"bincode::enc::Encode::encode({}, &mut encoder)?;\",\n-                                    field_name.to_string_with_prefix(TUPLE_FIELD_PREFIX),\n-                                ))\n-                                .unwrap();\n+                                if field_name.has_field_attribute(FieldAttribute::WithSerde) {\n+                                    body.push_parsed(format!(\n+                                        \"bincode::enc::Encode::encode(&bincode::serde::Compat({}), &mut encoder)?;\",\n+                                        field_name.to_string_with_prefix(TUPLE_FIELD_PREFIX),\n+                                    ))\n+                                    .unwrap();\n+                                } else {\n+                                    body.push_parsed(format!(\n+                                        \"bincode::enc::Encode::encode({}, &mut encoder)?;\",\n+                                        field_name.to_string_with_prefix(TUPLE_FIELD_PREFIX),\n+                                    ))\n+                                    .unwrap();\n+                                }\n                             }\n                         });\n                         match_body.punct(',');\ndiff --git a/derive/src/derive_enum.rs b/derive/src/derive_enum.rs\n--- a/derive/src/derive_enum.rs\n+++ b/derive/src/derive_enum.rs\n@@ -209,9 +217,15 @@ impl DeriveEnum {\n                                         variant_body.ident(field.unwrap_ident().clone());\n                                     }\n                                     variant_body.punct(':');\n-                                    variant_body\n-                                        .push_parsed(\"bincode::Decode::decode(&mut decoder)?,\")\n-                                        .unwrap();\n+                                    if field.has_field_attribute(FieldAttribute::WithSerde) {\n+                                        variant_body\n+                                            .push_parsed(\"<bincode::serde::Compat<_> as bincode::Decode>::decode(&mut decoder)?.0,\")\n+                                            .unwrap();\n+                                    } else {\n+                                        variant_body\n+                                            .push_parsed(\"bincode::Decode::decode(&mut decoder)?,\")\n+                                            .unwrap();\n+                                    }\n                                 }\n                             });\n                         });\ndiff --git a/derive/src/derive_enum.rs b/derive/src/derive_enum.rs\n--- a/derive/src/derive_enum.rs\n+++ b/derive/src/derive_enum.rs\n@@ -269,7 +283,13 @@ impl DeriveEnum {\n                                         variant_body.ident(field.unwrap_ident().clone());\n                                     }\n                                     variant_body.punct(':');\n-                                    variant_body.push_parsed(\"bincode::de::BorrowDecode::borrow_decode(&mut decoder)?,\").unwrap();\n+                                    if field.has_field_attribute(FieldAttribute::WithSerde) {\n+                                        variant_body\n+                                            .push_parsed(\"<bincode::serde::BorrowCompat<_> as bincode::BorrowDecode>::borrow_decode(&mut decoder)?.0,\")\n+                                            .unwrap();\n+                                    } else {\n+                                        variant_body.push_parsed(\"bincode::de::BorrowDecode::borrow_decode(&mut decoder)?,\").unwrap();\n+                                    }\n                                 }\n                             });\n                         });\ndiff --git a/derive/src/derive_struct.rs b/derive/src/derive_struct.rs\n--- a/derive/src/derive_struct.rs\n+++ b/derive/src/derive_struct.rs\n@@ -1,5 +1,5 @@\n use crate::generate::Generator;\n-use crate::parse::Fields;\n+use crate::parse::{FieldAttribute, Fields};\n use crate::prelude::Delimiter;\n use crate::Result;\n \ndiff --git a/derive/src/derive_struct.rs b/derive/src/derive_struct.rs\n--- a/derive/src/derive_struct.rs\n+++ b/derive/src/derive_struct.rs\n@@ -21,12 +21,21 @@ impl DeriveStruct {\n             .with_return_type(\"core::result::Result<(), bincode::error::EncodeError>\")\n             .body(|fn_body| {\n                 for field in fields.names() {\n-                    fn_body\n-                        .push_parsed(format!(\n-                            \"bincode::enc::Encode::encode(&self.{}, &mut encoder)?;\",\n-                            field.to_string()\n-                        ))\n-                        .unwrap();\n+                    if field.has_field_attribute(FieldAttribute::WithSerde) {\n+                        fn_body\n+                            .push_parsed(format!(\n+                                \"bincode::Encode::encode(&bincode::serde::Compat(&self.{}), &mut encoder)?;\",\n+                                field.to_string()\n+                            ))\n+                            .unwrap();\n+                    } else {\n+                        fn_body\n+                            .push_parsed(format!(\n+                                \"bincode::enc::Encode::encode(&self.{}, &mut encoder)?;\",\n+                                field.to_string()\n+                            ))\n+                            .unwrap();\n+                    }\n                 }\n                 fn_body.push_parsed(\"Ok(())\").unwrap();\n             })\ndiff --git a/derive/src/derive_struct.rs b/derive/src/derive_struct.rs\n--- a/derive/src/derive_struct.rs\n+++ b/derive/src/derive_struct.rs\n@@ -59,12 +68,21 @@ impl DeriveStruct {\n                         //      ...\n                         // }\n                         for field in fields.names() {\n-                            struct_body\n-                                .push_parsed(format!(\n-                                    \"{}: bincode::Decode::decode(&mut decoder)?,\",\n-                                    field.to_string()\n-                                ))\n-                                .unwrap();\n+                            if field.has_field_attribute(FieldAttribute::WithSerde) {\n+                                struct_body\n+                                    .push_parsed(format!(\n+                                        \"{}: (<bincode::serde::Compat<_> as bincode::Decode>::decode(&mut decoder)?).0,\",\n+                                        field.to_string()\n+                                    ))\n+                                    .unwrap();\n+                            } else {\n+                                struct_body\n+                                    .push_parsed(format!(\n+                                        \"{}: bincode::Decode::decode(&mut decoder)?,\",\n+                                        field.to_string()\n+                                    ))\n+                                    .unwrap();\n+                            }\n                         }\n                     });\n                 });\ndiff --git a/derive/src/derive_struct.rs b/derive/src/derive_struct.rs\n--- a/derive/src/derive_struct.rs\n+++ b/derive/src/derive_struct.rs\n@@ -92,12 +110,21 @@ impl DeriveStruct {\n                     ok_group.ident_str(\"Self\");\n                     ok_group.group(Delimiter::Brace, |struct_body| {\n                         for field in fields.names() {\n-                            struct_body\n-                                .push_parsed(format!(\n-                                    \"{}: bincode::de::BorrowDecode::borrow_decode(&mut decoder)?,\",\n-                                    field.to_string()\n-                                ))\n-                                .unwrap();\n+                            if field.has_field_attribute(FieldAttribute::WithSerde) {\n+                                struct_body\n+                                    .push_parsed(format!(\n+                                        \"{}: (<bincode::serde::BorrowCompat<_> as bincode::de::BorrowDecode>::borrow_decode(&mut decoder)?).0,\",\n+                                        field.to_string()\n+                                    ))\n+                                    .unwrap();\n+                            } else {\n+                                struct_body\n+                                    .push_parsed(format!(\n+                                        \"{}: bincode::de::BorrowDecode::borrow_decode(&mut decoder)?,\",\n+                                        field.to_string()\n+                                    ))\n+                                    .unwrap();\n+                                }\n                         }\n                     });\n                 });\ndiff --git a/derive/src/error.rs b/derive/src/error.rs\n--- a/derive/src/error.rs\n+++ b/derive/src/error.rs\n@@ -9,7 +9,7 @@ pub enum Error {\n }\n \n impl Error {\n-    pub fn wrong_token<T>(token: Option<&TokenTree>, expected: &'static str) -> Result<T, Self> {\n+    pub fn wrong_token<T>(token: Option<&TokenTree>, expected: &str) -> Result<T, Self> {\n         Err(Self::InvalidRustSyntax {\n             span: token.map(|t| t.span()).unwrap_or_else(Span::call_site),\n             expected: format!(\"{}, got {:?}\", expected, token),\ndiff --git a/derive/src/lib.rs b/derive/src/lib.rs\n--- a/derive/src/lib.rs\n+++ b/derive/src/lib.rs\n@@ -16,11 +16,12 @@ pub(crate) mod prelude {\n }\n \n use error::Error;\n+use parse::AttributeLocation;\n use prelude::TokenStream;\n \n type Result<T = ()> = std::result::Result<T, Error>;\n \n-#[proc_macro_derive(Encode)]\n+#[proc_macro_derive(Encode, attributes(bincode))]\n pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     #[allow(clippy::useless_conversion)]\n     derive_encode_inner(input.into())\ndiff --git a/derive/src/lib.rs b/derive/src/lib.rs\n--- a/derive/src/lib.rs\n+++ b/derive/src/lib.rs\n@@ -31,7 +32,7 @@ pub fn derive_encode(input: proc_macro::TokenStream) -> proc_macro::TokenStream\n fn derive_encode_inner(input: TokenStream) -> Result<TokenStream> {\n     let source = &mut input.into_iter().peekable();\n \n-    let _attributes = parse::Attribute::try_take(source)?;\n+    let _attributes = parse::Attribute::try_take(AttributeLocation::Container, source)?;\n     let _visibility = parse::Visibility::try_take(source)?;\n     let (datatype, name) = parse::DataType::take(source)?;\n     let generics = parse::Generics::try_take(source)?;\ndiff --git a/derive/src/lib.rs b/derive/src/lib.rs\n--- a/derive/src/lib.rs\n+++ b/derive/src/lib.rs\n@@ -61,7 +62,7 @@ fn derive_encode_inner(input: TokenStream) -> Result<TokenStream> {\n     Ok(stream)\n }\n \n-#[proc_macro_derive(Decode)]\n+#[proc_macro_derive(Decode, attributes(bincode))]\n pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     #[allow(clippy::useless_conversion)]\n     derive_decode_inner(input.into())\ndiff --git a/derive/src/lib.rs b/derive/src/lib.rs\n--- a/derive/src/lib.rs\n+++ b/derive/src/lib.rs\n@@ -72,7 +73,7 @@ pub fn derive_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream\n fn derive_decode_inner(input: TokenStream) -> Result<TokenStream> {\n     let source = &mut input.into_iter().peekable();\n \n-    let _attributes = parse::Attribute::try_take(source)?;\n+    let _attributes = parse::Attribute::try_take(AttributeLocation::Container, source)?;\n     let _visibility = parse::Visibility::try_take(source)?;\n     let (datatype, name) = parse::DataType::take(source)?;\n     let generics = parse::Generics::try_take(source)?;\ndiff --git a/derive/src/lib.rs b/derive/src/lib.rs\n--- a/derive/src/lib.rs\n+++ b/derive/src/lib.rs\n@@ -102,7 +103,7 @@ fn derive_decode_inner(input: TokenStream) -> Result<TokenStream> {\n     Ok(stream)\n }\n \n-#[proc_macro_derive(BorrowDecode)]\n+#[proc_macro_derive(BorrowDecode, attributes(bincode))]\n pub fn derive_brrow_decode(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     #[allow(clippy::useless_conversion)]\n     derive_borrow_decode_inner(input.into())\ndiff --git a/derive/src/lib.rs b/derive/src/lib.rs\n--- a/derive/src/lib.rs\n+++ b/derive/src/lib.rs\n@@ -113,7 +114,7 @@ pub fn derive_brrow_decode(input: proc_macro::TokenStream) -> proc_macro::TokenS\n fn derive_borrow_decode_inner(input: TokenStream) -> Result<TokenStream> {\n     let source = &mut input.into_iter().peekable();\n \n-    let _attributes = parse::Attribute::try_take(source)?;\n+    let _attributes = parse::Attribute::try_take(AttributeLocation::Container, source)?;\n     let _visibility = parse::Visibility::try_take(source)?;\n     let (datatype, name) = parse::DataType::take(source)?;\n     let generics = parse::Generics::try_take(source)?;\ndiff --git a/derive/src/parse/attributes.rs b/derive/src/parse/attributes.rs\n--- a/derive/src/parse/attributes.rs\n+++ b/derive/src/parse/attributes.rs\n@@ -1,28 +1,62 @@\n-use super::{assume_group, assume_punct};\n-use crate::parse::consume_punct_if;\n+use super::{assume_group, assume_ident, assume_punct};\n+use crate::parse::{consume_punct_if, ident_eq};\n use crate::prelude::{Delimiter, Group, Punct, TokenTree};\n use crate::{Error, Result};\n use std::iter::Peekable;\n \n #[derive(Debug)]\n-pub struct Attribute {\n-    // we don't use these fields yet\n-    #[allow(dead_code)]\n-    punct: Punct,\n-    #[allow(dead_code)]\n-    tokens: Option<Group>,\n+pub enum Attribute {\n+    Field(FieldAttribute),\n+    Unknown { punct: Punct, tokens: Option<Group> },\n+}\n+#[derive(Debug, PartialEq)]\n+pub enum FieldAttribute {\n+    /// The field is a serde type and should implement Encode/Decode through a wrapper\n+    WithSerde,\n+}\n+\n+#[derive(PartialEq, Eq, Debug, Hash, Copy, Clone)]\n+pub enum AttributeLocation {\n+    Container,\n+    Variant,\n+    Field,\n }\n \n impl Attribute {\n-    pub fn try_take(input: &mut Peekable<impl Iterator<Item = TokenTree>>) -> Result<Vec<Self>> {\n+    pub fn try_take(\n+        loc: AttributeLocation,\n+        input: &mut Peekable<impl Iterator<Item = TokenTree>>,\n+    ) -> Result<Vec<Self>> {\n         let mut result = Vec::new();\n \n         while let Some(punct) = consume_punct_if(input, '#') {\n             match input.peek() {\n                 Some(TokenTree::Group(g)) if g.delimiter() == Delimiter::Bracket => {\n-                    result.push(Attribute {\n+                    let group = assume_group(input.next());\n+                    let stream = &mut group.stream().into_iter().peekable();\n+                    if let Some(TokenTree::Ident(attribute_ident)) = stream.peek() {\n+                        if super::ident_eq(attribute_ident, \"bincode\") {\n+                            assume_ident(stream.next());\n+                            match stream.next() {\n+                                Some(TokenTree::Group(group)) => {\n+                                    result.push(Self::parse_bincode_attribute(\n+                                        loc,\n+                                        &mut group.stream().into_iter().peekable(),\n+                                    )?);\n+                                }\n+                                token => {\n+                                    return Error::wrong_token(\n+                                        token.as_ref(),\n+                                        \"Bracketed group of attributes\",\n+                                    )\n+                                }\n+                            }\n+                            continue;\n+                        }\n+                    }\n+                    result.push(Attribute::Unknown {\n                         punct,\n-                        tokens: Some(assume_group(input.next())),\n+                        tokens: Some(group),\n                     });\n                 }\n                 Some(TokenTree::Group(g)) => {\ndiff --git a/derive/src/parse/attributes.rs b/derive/src/parse/attributes.rs\n--- a/derive/src/parse/attributes.rs\n+++ b/derive/src/parse/attributes.rs\n@@ -34,7 +68,7 @@ impl Attribute {\n                 Some(TokenTree::Punct(p)) if p.as_char() == '#' => {\n                     // sometimes with empty lines of doc comments, we get two #'s in a row\n                     // add an empty attributes and continue to the next loop\n-                    result.push(Attribute {\n+                    result.push(Attribute::Unknown {\n                         punct: assume_punct(input.next(), '#'),\n                         tokens: None,\n                     })\ndiff --git a/derive/src/parse/body.rs b/derive/src/parse/body.rs\n--- a/derive/src/parse/body.rs\n+++ b/derive/src/parse/body.rs\n@@ -1,5 +1,7 @@\n+use super::attributes::AttributeLocation;\n use super::{\n-    assume_group, assume_ident, assume_punct, read_tokens_until_punct, Attribute, Visibility,\n+    assume_group, assume_ident, assume_punct, read_tokens_until_punct, Attribute, FieldAttribute,\n+    Visibility,\n };\n use crate::parse::consume_punct_if;\n use crate::prelude::{Delimiter, Ident, Literal, Span, TokenTree};\ndiff --git a/derive/src/parse/body.rs b/derive/src/parse/body.rs\n--- a/derive/src/parse/body.rs\n+++ b/derive/src/parse/body.rs\n@@ -132,7 +134,7 @@ impl EnumBody {\n         let mut variants = Vec::new();\n         let stream = &mut group.stream().into_iter().peekable();\n         while stream.peek().is_some() {\n-            let attributes = Attribute::try_take(stream)?;\n+            let attributes = Attribute::try_take(AttributeLocation::Variant, stream)?;\n             let ident = match stream.peek() {\n                 Some(TokenTree::Ident(_)) => assume_ident(stream.next()),\n                 token => return Error::wrong_token(token, \"ident\"),\ndiff --git a/derive/src/parse/body.rs b/derive/src/parse/body.rs\n--- a/derive/src/parse/body.rs\n+++ b/derive/src/parse/body.rs\n@@ -288,11 +290,18 @@ impl Fields {\n             Self::Tuple(fields) => fields\n                 .iter()\n                 .enumerate()\n-                .map(|(idx, field)| IdentOrIndex::Index(idx, field.span()))\n+                .map(|(index, field)| IdentOrIndex::Index {\n+                    index,\n+                    span: field.span(),\n+                    attributes: &field.attributes,\n+                })\n                 .collect(),\n             Self::Struct(fields) => fields\n                 .iter()\n-                .map(|(ident, _)| IdentOrIndex::Ident(ident))\n+                .map(|(ident, field)| IdentOrIndex::Ident {\n+                    ident,\n+                    attributes: &field.attributes,\n+                })\n                 .collect(),\n             Self::Unit | Self::Integer(_) => Vec::new(),\n         }\ndiff --git a/derive/src/parse/body.rs b/derive/src/parse/body.rs\n--- a/derive/src/parse/body.rs\n+++ b/derive/src/parse/body.rs\n@@ -345,7 +354,7 @@ impl UnnamedField {\n     ) -> Result<Vec<(Ident, Self)>> {\n         let mut result = Vec::new();\n         loop {\n-            let attributes = Attribute::try_take(input)?;\n+            let attributes = Attribute::try_take(AttributeLocation::Field, input)?;\n             let vis = Visibility::try_take(input)?;\n \n             let ident = match input.peek() {\ndiff --git a/derive/src/parse/body.rs b/derive/src/parse/body.rs\n--- a/derive/src/parse/body.rs\n+++ b/derive/src/parse/body.rs\n@@ -381,7 +390,7 @@ impl UnnamedField {\n     pub fn parse(input: &mut Peekable<impl Iterator<Item = TokenTree>>) -> Result<Vec<Self>> {\n         let mut result = Vec::new();\n         while input.peek().is_some() {\n-            let attributes = Attribute::try_take(input)?;\n+            let attributes = Attribute::try_take(AttributeLocation::Field, input)?;\n             let vis = Visibility::try_take(input)?;\n \n             let r#type = read_tokens_until_punct(input, &[','])?;\ndiff --git a/derive/src/parse/body.rs b/derive/src/parse/body.rs\n--- a/derive/src/parse/body.rs\n+++ b/derive/src/parse/body.rs\n@@ -422,42 +431,63 @@ impl UnnamedField {\n \n #[derive(Debug)]\n pub enum IdentOrIndex<'a> {\n-    Ident(&'a Ident),\n-    Index(usize, Span),\n+    Ident {\n+        ident: &'a Ident,\n+        attributes: &'a Vec<Attribute>,\n+    },\n+    Index {\n+        index: usize,\n+        span: Span,\n+        attributes: &'a Vec<Attribute>,\n+    },\n }\n \n impl<'a> IdentOrIndex<'a> {\n     pub fn unwrap_ident(&self) -> &'a Ident {\n         match self {\n-            Self::Ident(i) => i,\n+            Self::Ident { ident, .. } => ident,\n             x => panic!(\"Expected ident, found {:?}\", x),\n         }\n     }\n \n     pub fn to_token_tree_with_prefix(&self, prefix: &str) -> TokenTree {\n         TokenTree::Ident(match self {\n-            IdentOrIndex::Ident(i) => (*i).clone(),\n-            IdentOrIndex::Index(idx, span) => {\n-                let name = format!(\"{}{}\", prefix, idx);\n+            IdentOrIndex::Ident { ident, .. } => (*ident).clone(),\n+            IdentOrIndex::Index { index, span, .. } => {\n+                let name = format!(\"{}{}\", prefix, index);\n                 Ident::new(&name, *span)\n             }\n         })\n     }\n     pub fn to_string_with_prefix(&self, prefix: &str) -> String {\n         match self {\n-            IdentOrIndex::Ident(i) => i.to_string(),\n-            IdentOrIndex::Index(idx, _) => {\n-                format!(\"{}{}\", prefix, idx)\n+            IdentOrIndex::Ident { ident, .. } => ident.to_string(),\n+            IdentOrIndex::Index { index, .. } => {\n+                format!(\"{}{}\", prefix, index)\n             }\n         }\n     }\n+\n+    pub fn has_field_attribute(&self, attribute: FieldAttribute) -> bool {\n+        let attributes = match self {\n+            IdentOrIndex::Ident { attributes, .. } => attributes,\n+            IdentOrIndex::Index { attributes, .. } => attributes,\n+        };\n+        attributes.iter().any(|a| {\n+            if let Attribute::Field(field_attribute) = a {\n+                field_attribute == &attribute\n+            } else {\n+                false\n+            }\n+        })\n+    }\n }\n \n impl std::fmt::Display for IdentOrIndex<'_> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {\n         match self {\n-            IdentOrIndex::Ident(i) => write!(fmt, \"{}\", i),\n-            IdentOrIndex::Index(idx, _) => write!(fmt, \"{}\", idx),\n+            IdentOrIndex::Ident { ident, .. } => write!(fmt, \"{}\", ident),\n+            IdentOrIndex::Index { index, .. } => write!(fmt, \"{}\", index),\n         }\n     }\n }\ndiff --git a/derive/src/parse/mod.rs b/derive/src/parse/mod.rs\n--- a/derive/src/parse/mod.rs\n+++ b/derive/src/parse/mod.rs\n@@ -8,7 +8,7 @@ mod data_type;\n mod generics;\n mod visibility;\n \n-pub use self::attributes::Attribute;\n+pub use self::attributes::{Attribute, AttributeLocation, FieldAttribute};\n pub use self::body::{EnumBody, EnumVariant, Fields, StructBody, UnnamedField};\n pub use self::data_type::DataType;\n pub use self::generics::{GenericConstraints, Generics, Lifetime, SimpleGeneric};\ndiff --git a/docs/spec.md b/docs/spec.md\n--- a/docs/spec.md\n+++ b/docs/spec.md\n@@ -12,7 +12,7 @@ By default `bincode` will serialize values in little endian encoding. This can b\n \r\n Boolean types are encoded with 1 byte for each boolean type, with `0` being `false`, `1` being true. Whilst deserializing every other value will throw an error.\r\n \r\n-All basic numeric types will be encoded based on the configured [IntEncoding](#IntEncoding).\r\n+All basic numeric types will be encoded based on the configured [IntEncoding](#intencoding).\r\n \r\n All floating point types will take up exactly 4 (for `f32`) or 8 (for `f64`) bytes.\r\n \r\ndiff --git a/src/features/mod.rs b/src/features/mod.rs\n--- a/src/features/mod.rs\n+++ b/src/features/mod.rs\n@@ -19,6 +19,5 @@ mod derive;\n pub use self::derive::*;\n \n #[cfg(feature = \"serde\")]\n-mod serde;\n-#[cfg(feature = \"serde\")]\n-pub use self::serde::*;\n+#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n+pub mod serde;\ndiff --git a/src/features/serde/de_borrowed.rs b/src/features/serde/de_borrowed.rs\n--- a/src/features/serde/de_borrowed.rs\n+++ b/src/features/serde/de_borrowed.rs\n@@ -7,10 +7,7 @@ use core::marker::PhantomData;\n use serde_incl::de::*;\n \n /// Decode a borrowed type from the given slice. Some parts of the decoded type are expected to be referring to the given slice\n-pub fn serde_decode_borrowed_from_slice<'de, T, C>(\n-    slice: &'de [u8],\n-    config: C,\n-) -> Result<T, DecodeError>\n+pub fn decode_borrowed_from_slice<'de, T, C>(slice: &'de [u8], config: C) -> Result<T, DecodeError>\n where\n     T: Deserialize<'de>,\n     C: Config,\ndiff --git a/src/features/serde/de_borrowed.rs b/src/features/serde/de_borrowed.rs\n--- a/src/features/serde/de_borrowed.rs\n+++ b/src/features/serde/de_borrowed.rs\n@@ -24,9 +21,9 @@ where\n     T::deserialize(serde_decoder)\n }\n \n-struct SerdeDecoder<'a, 'de, DE: BorrowDecoder<'de>> {\n-    de: &'a mut DE,\n-    pd: PhantomData<&'de ()>,\n+pub(super) struct SerdeDecoder<'a, 'de, DE: BorrowDecoder<'de>> {\n+    pub(super) de: &'a mut DE,\n+    pub(super) pd: PhantomData<&'de ()>,\n }\n \n impl<'a, 'de, DE: BorrowDecoder<'de>> Deserializer<'de> for SerdeDecoder<'a, 'de, DE> {\ndiff --git a/src/features/serde/de_owned.rs b/src/features/serde/de_owned.rs\n--- a/src/features/serde/de_owned.rs\n+++ b/src/features/serde/de_owned.rs\n@@ -7,8 +7,10 @@ use serde_incl::de::*;\n \n /// Decode an owned type from the given slice.\n ///\n-/// Note that this does not work with borrowed types like `&str` or `&[u8]`. For that use [serde_decode_borrowed_from_slice].\n-pub fn serde_decode_from_slice<T, C>(slice: &[u8], config: C) -> Result<T, DecodeError>\n+/// Note that this does not work with borrowed types like `&str` or `&[u8]`. For that use [decode_borrowed_from_slice].\n+///\n+/// [decode_borrowed_from_slice]: fn.decode_borrowed_from_slice.html\n+pub fn decode_from_slice<T, C>(slice: &[u8], config: C) -> Result<T, DecodeError>\n where\n     T: DeserializeOwned,\n     C: Config,\ndiff --git a/src/features/serde/de_owned.rs b/src/features/serde/de_owned.rs\n--- a/src/features/serde/de_owned.rs\n+++ b/src/features/serde/de_owned.rs\n@@ -19,8 +21,8 @@ where\n     T::deserialize(serde_decoder)\n }\n \n-struct SerdeDecoder<'a, DE: Decoder> {\n-    de: &'a mut DE,\n+pub(crate) struct SerdeDecoder<'a, DE: Decoder> {\n+    pub(crate) de: &'a mut DE,\n }\n \n impl<'a, 'de, DE: Decoder> Deserializer<'de> for SerdeDecoder<'a, DE> {\ndiff --git a/src/features/serde/mod.rs b/src/features/serde/mod.rs\n--- a/src/features/serde/mod.rs\n+++ b/src/features/serde/mod.rs\n@@ -1,3 +1,63 @@\n+//! Support for serde integration. Enable this with the `serde` feature.\n+//!\n+//! To encode/decode type that implement serde's trait, you can use:\n+//! - [decode_borrowed_from_slice]\n+//! - [decode_from_slice]\n+//! - [encode_to_slice]\n+//! - [encode_to_vec]\n+//!\n+//! For interop with bincode's [Decode]/[Encode], you can use:\n+//! - [Compat]\n+//! - [BorrowCompat]\n+//!\n+//! For interop with bincode's `derive` feature, you can use the `#[bincode(with_serde)]` attribute on each field that implements serde's traits.\n+//!\n+//! ```\n+//! # #[cfg(feature = \"derive\")]\n+//! # mod foo {\n+//! # use bincode::{Decode, Encode};\n+//! # use serde_derive::{Deserialize, Serialize};\n+//! #[derive(Serialize, Deserialize)]\n+//! # #[serde(crate = \"serde_incl\")]\n+//! pub struct SerdeType {\n+//!     // ...\n+//! }\n+//!\n+//! #[derive(Decode, Encode)]\n+//! pub struct StructWithSerde {\n+//!     #[bincode(with_serde)]\n+//!     pub serde: SerdeType,\n+//! }\n+//!\n+//! #[derive(Decode, Encode)]\n+//! pub enum EnumWithSerde {\n+//!     Unit(#[bincode(with_serde)] SerdeType),\n+//!     Struct {\n+//!         #[bincode(with_serde)]\n+//!         serde: SerdeType,\n+//!     },\n+//! }\n+//! # }\n+//! ```\n+//!\n+//! # Known issues\n+//!\n+//! Currently the `serde` feature will automatically enable the `alloc` and `std` feature. If you're running in a `#[no_std]` environment consider using bincode's own derive macros.\n+//!\n+//! Because bincode is a format without meta data, there are several known issues with serde's `skip` attributes. Please do not use `skip` attributes if you plan on using bincode, or use bincode's own `derive` macros.\n+//!\n+//! This includes:\n+//! - `#[serde(skip)]`\n+//! - `#[serde(skip_serializing)]`\n+//! - `#[serde(skip_deserializing)]`\n+//! - `#[serde(skip_serializing_if = \"path\")]`\n+//! - `#[serde(flatten)]`\n+//!\n+//! **Using any of the above attributes can and will cause issues with bincode and will result in lost data**. Consider using bincode's own derive macro instead.\n+//!\n+//! [Decode]: ../de/trait.Decode.html\n+//! [Encode]: ../enc/trait.Encode.html\n+\n mod de_borrowed;\n mod de_owned;\n mod ser;\ndiff --git a/src/features/serde/mod.rs b/src/features/serde/mod.rs\n--- a/src/features/serde/mod.rs\n+++ b/src/features/serde/mod.rs\n@@ -26,3 +86,74 @@ impl serde_incl::ser::Error for crate::error::EncodeError {\n         Self::OtherString(msg.to_string())\n     }\n }\n+\n+/// Wrapper struct that implements [Decode] and [Encode] on any type that implements serde's [DeserializeOwned] and [Serialize] respectively.\n+///\n+/// This works for most types, but if you're dealing with borrowed data consider using [BorrowCompat] instead.\n+///\n+/// [Decode]: ../de/trait.Decode.html\n+/// [Encode]: ../enc/trait.Encode.html\n+/// [DeserializeOwned]: https://docs.rs/serde/1/serde/de/trait.DeserializeOwned.html\n+/// [Serialize]: https://docs.rs/serde/1/serde/trait.Serialize.html\n+pub struct Compat<T>(pub T);\n+\n+impl<T> crate::Decode for Compat<T>\n+where\n+    T: serde_incl::de::DeserializeOwned,\n+{\n+    fn decode<D: crate::de::Decoder>(mut decoder: D) -> Result<Self, crate::error::DecodeError> {\n+        let serde_decoder = de_owned::SerdeDecoder { de: &mut decoder };\n+        T::deserialize(serde_decoder).map(Compat)\n+    }\n+}\n+\n+impl<T> crate::Encode for Compat<T>\n+where\n+    T: serde_incl::Serialize,\n+{\n+    fn encode<E: crate::enc::Encoder>(\n+        &self,\n+        mut encoder: E,\n+    ) -> Result<(), crate::error::EncodeError> {\n+        let serializer = ser::SerdeEncoder { enc: &mut encoder };\n+        self.0.serialize(serializer)?;\n+        Ok(())\n+    }\n+}\n+\n+/// Wrapper struct that implements [BorrowDecode] and [Encode] on any type that implements serde's [Deserialize] and [Serialize] respectively. This is mostly used on `&[u8]` and `&str`, for other types consider using [Compat] instead.\n+///\n+/// [BorrowDecode]: ../de/trait.BorrowDecode.html\n+/// [Encode]: ../enc/trait.Encode.html\n+/// [Deserialize]: https://docs.rs/serde/1/serde/de/trait.Deserialize.html\n+/// [Serialize]: https://docs.rs/serde/1/serde/trait.Serialize.html\n+pub struct BorrowCompat<T>(pub T);\n+\n+impl<'de, T> crate::de::BorrowDecode<'de> for BorrowCompat<T>\n+where\n+    T: serde_incl::de::Deserialize<'de>,\n+{\n+    fn borrow_decode<D: crate::de::BorrowDecoder<'de>>(\n+        mut decoder: D,\n+    ) -> Result<Self, crate::error::DecodeError> {\n+        let serde_decoder = de_borrowed::SerdeDecoder {\n+            de: &mut decoder,\n+            pd: core::marker::PhantomData,\n+        };\n+        T::deserialize(serde_decoder).map(BorrowCompat)\n+    }\n+}\n+\n+impl<T> crate::Encode for BorrowCompat<T>\n+where\n+    T: serde_incl::Serialize,\n+{\n+    fn encode<E: crate::enc::Encoder>(\n+        &self,\n+        mut encoder: E,\n+    ) -> Result<(), crate::error::EncodeError> {\n+        let serializer = ser::SerdeEncoder { enc: &mut encoder };\n+        self.0.serialize(serializer)?;\n+        Ok(())\n+    }\n+}\ndiff --git a/src/features/serde/ser.rs b/src/features/serde/ser.rs\n--- a/src/features/serde/ser.rs\n+++ b/src/features/serde/ser.rs\n@@ -9,7 +9,8 @@ use serde_incl::ser::*;\n \n #[cfg(feature = \"alloc\")]\n /// Encode a `serde` `Serialize` type into a `Vec<u8>` with the bincode algorithm\n-pub fn serde_encode_to_vec<T, C>(t: T, config: C) -> Result<Vec<u8>, EncodeError>\n+#[cfg_attr(docsrs, doc(cfg(feature = \"alloc\")))]\n+pub fn encode_to_vec<T, C>(t: T, config: C) -> Result<Vec<u8>, EncodeError>\n where\n     T: Serialize,\n     C: Config,\ndiff --git a/src/features/serde/ser.rs b/src/features/serde/ser.rs\n--- a/src/features/serde/ser.rs\n+++ b/src/features/serde/ser.rs\n@@ -21,7 +22,7 @@ where\n }\n \n /// Encode a `serde` `Serialize` type into a given byte slice with the bincode algorithm\n-pub fn serde_encode_to_slice<T, C>(t: T, slice: &mut [u8], config: C) -> Result<usize, EncodeError>\n+pub fn encode_to_slice<T, C>(t: T, slice: &mut [u8], config: C) -> Result<usize, EncodeError>\n where\n     T: Serialize,\n     C: Config,\ndiff --git a/src/features/serde/ser.rs b/src/features/serde/ser.rs\n--- a/src/features/serde/ser.rs\n+++ b/src/features/serde/ser.rs\n@@ -33,8 +34,8 @@ where\n     Ok(encoder.into_writer().bytes_written())\n }\n \n-struct SerdeEncoder<'a, ENC: Encoder> {\n-    enc: &'a mut ENC,\n+pub(super) struct SerdeEncoder<'a, ENC: Encoder> {\n+    pub(super) enc: &'a mut ENC,\n }\n \n impl<'a, ENC> Serializer for SerdeEncoder<'a, ENC>\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -19,7 +19,7 @@\n //! |alloc | Yes    |All common containers in alloc, like `Vec`, `String`, `Box`|`encode_to_vec`|\n //! |atomic| Yes    |All `Atomic*` integer types, e.g. `AtomicUsize`, and `AtomicBool`||\n //! |derive| Yes    |||Enables the `BorrowDecode`, `Decode` and `Encode` derive macros|\n-//! |serde | No     |TODO|TODO|TODO|\n+//! |serde | No     |`Compat` and `BorrowCompat`, which will work for all types that implement serde's traits|serde-specific encode/decode functions in the [serde] module|Note: There are several [known issues](serde/index.html#known-issues) when using serde and bincode|\n //!\n //! # Example\n //!\n", "test_patch": "diff --git a/derive/src/parse/attributes.rs b/derive/src/parse/attributes.rs\n--- a/derive/src/parse/attributes.rs\n+++ b/derive/src/parse/attributes.rs\n@@ -44,6 +78,27 @@ impl Attribute {\n         }\n         Ok(result)\n     }\n+\n+    fn parse_bincode_attribute(\n+        loc: AttributeLocation,\n+        stream: &mut Peekable<impl Iterator<Item = TokenTree>>,\n+    ) -> Result<Self> {\n+        match (stream.next(), loc) {\n+            (Some(TokenTree::Ident(ident)), AttributeLocation::Field)\n+                if ident_eq(&ident, \"with_serde\") =>\n+            {\n+                Ok(Self::Field(FieldAttribute::WithSerde))\n+            }\n+            (token @ Some(TokenTree::Ident(_)), AttributeLocation::Field) => {\n+                Error::wrong_token(token.as_ref(), \"one of: `with_serde`\")\n+            }\n+            (token @ Some(TokenTree::Ident(_)), loc) => Error::wrong_token(\n+                token.as_ref(),\n+                &format!(\"{:?} attributes not supported\", loc),\n+            ),\n+            (token, _) => Error::wrong_token(token.as_ref(), \"ident\"),\n+        }\n+    }\n }\n \n #[test]\ndiff --git a/derive/src/parse/attributes.rs b/derive/src/parse/attributes.rs\n--- a/derive/src/parse/attributes.rs\n+++ b/derive/src/parse/attributes.rs\n@@ -51,14 +106,18 @@ fn test_attributes_try_take() {\n     use crate::token_stream;\n \n     let stream = &mut token_stream(\"struct Foo;\");\n-    assert!(Attribute::try_take(stream).unwrap().is_empty());\n+    assert!(Attribute::try_take(AttributeLocation::Container, stream)\n+        .unwrap()\n+        .is_empty());\n     match stream.next().unwrap() {\n         TokenTree::Ident(i) => assert_eq!(i, \"struct\"),\n         x => panic!(\"Expected ident, found {:?}\", x),\n     }\n \n     let stream = &mut token_stream(\"#[cfg(test)] struct Foo;\");\n-    assert!(!Attribute::try_take(stream).unwrap().is_empty());\n+    assert!(!Attribute::try_take(AttributeLocation::Container, stream)\n+        .unwrap()\n+        .is_empty());\n     match stream.next().unwrap() {\n         TokenTree::Ident(i) => assert_eq!(i, \"struct\"),\n         x => panic!(\"Expected ident, found {:?}\", x),\ndiff --git a/tests/serde.rs b/tests/serde.rs\n--- a/tests/serde.rs\n+++ b/tests/serde.rs\n@@ -61,16 +61,16 @@ fn test_serialize_deserialize_borrowed_data() {\n \n     let mut result = [0u8; 20];\n     let len =\n-        bincode::serde_encode_to_slice(&input, &mut result, Configuration::standard()).unwrap();\n+        bincode::serde::encode_to_slice(&input, &mut result, Configuration::standard()).unwrap();\n     let result = &result[..len];\n     assert_eq!(result, expected);\n \n-    let result = bincode::serde_encode_to_vec(&input, Configuration::standard()).unwrap();\n+    let result = bincode::serde::encode_to_vec(&input, Configuration::standard()).unwrap();\n \n     assert_eq!(result, expected);\n \n     let output: SerdeWithBorrowedData =\n-        bincode::serde_decode_borrowed_from_slice(&result, Configuration::standard()).unwrap();\n+        bincode::serde::decode_borrowed_from_slice(&result, Configuration::standard()).unwrap();\n     assert_eq!(\n         SerdeWithBorrowedData {\n             b: 0, // remember: b is skipped\ndiff --git a/tests/serde.rs b/tests/serde.rs\n--- a/tests/serde.rs\n+++ b/tests/serde.rs\n@@ -107,16 +107,16 @@ fn test_serialize_deserialize_owned_data() {\n \n     let mut result = [0u8; 20];\n     let len =\n-        bincode::serde_encode_to_slice(&input, &mut result, Configuration::standard()).unwrap();\n+        bincode::serde::encode_to_slice(&input, &mut result, Configuration::standard()).unwrap();\n     let result = &result[..len];\n     assert_eq!(result, expected);\n \n-    let result = bincode::serde_encode_to_vec(&input, Configuration::standard()).unwrap();\n+    let result = bincode::serde::encode_to_vec(&input, Configuration::standard()).unwrap();\n \n     assert_eq!(result, expected);\n \n     let output: SerdeWithOwnedData =\n-        bincode::serde_decode_from_slice(&result, Configuration::standard()).unwrap();\n+        bincode::serde::decode_from_slice(&result, Configuration::standard()).unwrap();\n     assert_eq!(\n         SerdeWithOwnedData {\n             b: 0, // remember: b is skipped\ndiff --git a/tests/serde.rs b/tests/serde.rs\n--- a/tests/serde.rs\n+++ b/tests/serde.rs\n@@ -125,3 +125,53 @@ fn test_serialize_deserialize_owned_data() {\n         output\n     );\n }\n+\n+#[cfg(feature = \"derive\")]\n+mod derive {\n+    use bincode::{config::Configuration, Decode, Encode};\n+    use serde_derive::{Deserialize, Serialize};\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(crate = \"serde_incl\")]\n+    pub struct SerdeType {\n+        pub a: u32,\n+    }\n+\n+    #[derive(Decode, Encode, PartialEq, Debug)]\n+    pub struct StructWithSerde {\n+        #[bincode(with_serde)]\n+        pub serde: SerdeType,\n+    }\n+\n+    #[derive(Decode, Encode, PartialEq, Debug)]\n+    pub enum EnumWithSerde {\n+        Unit(#[bincode(with_serde)] SerdeType),\n+        Struct {\n+            #[bincode(with_serde)]\n+            serde: SerdeType,\n+        },\n+    }\n+\n+    #[test]\n+    fn test_serde_derive() {\n+        fn test_encode_decode<T>(start: T)\n+        where\n+            T: bincode::Encode + bincode::Decode + PartialEq + core::fmt::Debug,\n+        {\n+            let mut slice = [0u8; 100];\n+            let len =\n+                bincode::encode_into_slice(&start, &mut slice, Configuration::standard()).unwrap();\n+            let slice = &slice[..len];\n+            let result: T = bincode::decode_from_slice(&slice, Configuration::standard()).unwrap();\n+\n+            assert_eq!(start, result);\n+        }\n+        test_encode_decode(StructWithSerde {\n+            serde: SerdeType { a: 5 },\n+        });\n+        test_encode_decode(EnumWithSerde::Unit(SerdeType { a: 5 }));\n+        test_encode_decode(EnumWithSerde::Struct {\n+            serde: SerdeType { a: 5 },\n+        });\n+    }\n+}\n", "instance_id": "bincode-org__bincode-434"}