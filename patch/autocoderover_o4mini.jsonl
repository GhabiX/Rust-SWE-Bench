{"instance_id": "chronotope__chrono-1403", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/round.rs b/src/round.rs\nindex 2818163..2ada4fa 100644\n--- a/src/round.rs\n+++ b/src/round.rs\n@@ -177,7 +177,8 @@ where\n             return Err(RoundingError::DurationExceedsLimit);\n         }\n         let stamp = naive.timestamp_nanos_opt().ok_or(RoundingError::TimestampExceedsLimit)?;\n-        if span > stamp.abs() {\n+        // only reject if pre\u2010epoch and the span would overshoot it\n+        if stamp < 0 && span > stamp.abs() {\n             return Err(RoundingError::DurationExceedsTimestamp);\n         }\n         if span == 0 {\n"}
{"instance_id": "mozilla__cbindgen-563", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bindgen/ir/opaque.rs b/src/bindgen/ir/opaque.rs\nindex a46dcee..cb57368 100644\n--- a/src/bindgen/ir/opaque.rs\n+++ b/src/bindgen/ir/opaque.rs\n@@ -109,6 +109,15 @@ impl Item for OpaqueItem {\n             \"{} is not generic\",\n             self.path\n         );\n+        // For zero-parameter aliases (e.g., type aliases wrapping a generic type),\n+        // defer to the underlying type instead of panicking when generic counts differ.\n+        if self.generic_params.is_empty() && !generic_values.is_empty() {\n+            // Lookup the real item (the aliased generic type) and instantiate it directly.\n+            if let Some(real_item) = _library.resolve_item(&self.path) {\n+                real_item.instantiate_monomorph(generic_values, _library, out);\n+                return;\n+            }\n+        }\n         assert!(\n             self.generic_params.len() == generic_values.len(),\n             \"{} has {} params but is being instantiated with {} values\",\n"}
{"instance_id": "tracel-ai__burn-1188", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/burn-wgpu/src/codegen/shader.rs b/burn-wgpu/src/codegen/shader.rs\nindex d9eb5306..a5533ae9 100644\n--- a/burn-wgpu/src/codegen/shader.rs\n+++ b/burn-wgpu/src/codegen/shader.rs\n@@ -85,7 +85,8 @@ pub struct ComputeShader {\n     pub inputs: Vec<Binding>,\n     pub outputs: Vec<Binding>,\n     pub named: Vec<(String, Binding)>,\n-    pub workgroup_size: WorkgroupSize,\n+    /// Candidate launch configurations for autotuning:\n+    pub autotune_options: Vec<WorkgroupSize>,\n     pub global_invocation_id: bool,\n     pub num_workgroups: bool,\n     pub body: Body,\n"}
{"instance_id": "bevyengine__bevy-11167", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ecs/src/storage/blob_vec.rs b/crates/bevy_ecs/src/storage/blob_vec.rs\nindex bcbf0c6ba..09dcc1e16 100644\n--- a/crates/bevy_ecs/src/storage/blob_vec.rs\n+++ b/crates/bevy_ecs/src/storage/blob_vec.rs\n@@ -124,6 +124,25 @@ impl BlobVec {\n         }\n     }\n \n+    /// Reserves capacity for at least `additional` more elements,\n+    /// growing exponentially (doubling) to ensure amortized O(1) pushes.\n+    pub fn reserve(&mut self, additional: usize) {\n+        let available = self.capacity.saturating_sub(self.len);\n+        if available < additional {\n+            // start by doubling (or at least 1) to avoid zero-capacity stalls\n+            let mut new_capacity = self.capacity.saturating_mul(2).max(1);\n+            // ensure we have room for at least len + additional\n+            let min_needed = self.len + additional;\n+            if new_capacity < min_needed {\n+                new_capacity = min_needed;\n+            }\n+            let inc = new_capacity - self.capacity;\n+            // SAFETY: inc > 0 by construction\n+            let increment = unsafe { NonZeroUsize::new_unchecked(inc) };\n+            self.grow_exact(increment);\n+        }\n+    }\n+\n     /// Grows the capacity by `increment` elements.\n     ///\n     /// # Panics\n@@ -241,7 +260,8 @@ impl BlobVec {\n     /// The `value` must match the [`layout`](`BlobVec::layout`) of the elements in the [`BlobVec`].\n     #[inline]\n     pub unsafe fn push(&mut self, value: OwningPtr<'_>) {\n-        self.reserve_exact(1);\n+        // amortized growth instead of precise reallocation every time\n+        self.reserve(1);\n         let index = self.len;\n         self.len += 1;\n         self.initialize_unchecked(index, value);\n"}
{"instance_id": "chronotope__chrono-445", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/datetime.rs b/src/datetime.rs\nindex 0d68eb8..10ad406 100644\n--- a/src/datetime.rs\n+++ b/src/datetime.rs\n@@ -308,6 +308,57 @@ impl<Tz: TimeZone> DateTime<Tz> {\n     pub fn naive_local(&self) -> NaiveDateTime {\n         self.datetime + self.offset.fix()\n     }\n+\n+    /// Truncate this `DateTime` down to the largest multiple of the given duration.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `d.num_nanoseconds()` returns `None` (i.e., the duration is too large).\n+    pub fn truncate(&self, d: Duration) -> DateTime<Tz> {\n+        // number of nanoseconds in one \u201cunit\u201d\n+        let unit_ns = d.num_nanoseconds().expect(\"duration overflow\");\n+        // current instant as seconds + nanoseconds\n+        let sec = self.timestamp();\n+        let sub = self.timestamp_subsec_nanos() as i64;\n+        let total = sec * 1_000_000_000 + sub;\n+        // floor to multiple of unit_ns\n+        let truncated = (total / unit_ns) * unit_ns;\n+        // split back into secs + nanos\n+        let secs = truncated / 1_000_000_000;\n+        let nsec = (truncated % 1_000_000_000) as u32;\n+        // rebuild DateTime with same offset\n+        DateTime::from_utc(\n+            NaiveDateTime::from_timestamp(secs, nsec),\n+            self.offset.clone(),\n+        )\n+    }\n+\n+    /// Round this `DateTime` to the nearest multiple of the given duration, ties rounding up.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `d.num_nanoseconds()` returns `None`.\n+    pub fn round(&self, d: Duration) -> DateTime<Tz> {\n+        let unit_ns = d.num_nanoseconds().expect(\"duration overflow\");\n+        let sec = self.timestamp();\n+        let sub = self.timestamp_subsec_nanos() as i64;\n+        let total = sec * 1_000_000_000 + sub;\n+        // compute base multiple and remainder\n+        let base = (total / unit_ns) * unit_ns;\n+        let rem = total - base;\n+        // tie goes up\n+        let rounded = if rem * 2 < unit_ns {\n+            base\n+        } else {\n+            base + unit_ns\n+        };\n+        let secs = rounded / 1_000_000_000;\n+        let nsec = (rounded % 1_000_000_000) as u32;\n+        DateTime::from_utc(\n+            NaiveDateTime::from_timestamp(secs, nsec),\n+            self.offset.clone(),\n+        )\n+    }\n }\n \n /// Convert a `DateTime<Utc>` instance into a `DateTime<FixedOffset>` instance.\n"}
{"instance_id": "tokio-rs__bytes-560", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes_mut.rs b/src/bytes_mut.rs\nindex 99e8497..187a19a 100644\n--- a/src/bytes_mut.rs\n+++ b/src/bytes_mut.rs\n@@ -627,7 +627,8 @@ impl BytesMut {\n                     // allocate more space!\n                     let mut v =\n                         ManuallyDrop::new(rebuild_vec(self.ptr.as_ptr(), self.len, self.cap, off));\n-                    v.reserve(additional);\n+                    // Only grow by exactly the requested amount (no doubling)\n+                    v.reserve_exact(additional);\n \n                     // Update the info\n                     self.ptr = vptr(v.as_mut_ptr().add(off));\n@@ -701,8 +702,8 @@ impl BytesMut {\n \n                     new_cap = cmp::max(double, new_cap);\n \n-                    // No space - allocate more\n-                    v.reserve(new_cap - v.len());\n+                    // No space - allocate more (exactly what's needed)\n+                    v.reserve_exact(new_cap - v.len());\n \n                     // Update the info\n                     self.ptr = vptr(v.as_mut_ptr().add(off));\n"}
{"instance_id": "tracel-ai__burn-888", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/burn-core/src/optim/adamw.rs b/burn-core/src/optim/adamw.rs\nindex befbeb88..12a9c850 100644\n--- a/burn-core/src/optim/adamw.rs\n+++ b/burn-core/src/optim/adamw.rs\n@@ -170,10 +170,8 @@ impl AdaptiveMomentumW {\n         let update_delta =\n             moment_1_corrected.div(moment_2_corrected.sqrt().add_scalar(self.epsilon));\n \n-        (\n-            update_delta,\n-            AdaptiveMomentumWState::new(state.time, state.moment_1, state.moment_2),\n-        )\n+        // Return the mutated state directly (so `time` really starts at 1 and is never reset to 0):\n+        (update_delta, state)\n     }\n }\n \n"}
{"instance_id": "killercup__cargo-edit-304", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/dependency.rs b/src/dependency.rs\nindex 97aa5f61..20f25770 100644\n--- a/src/dependency.rs\n+++ b/src/dependency.rs\n@@ -118,7 +118,11 @@ impl Dependency {\n                         version: Some(v),\n                         path: None,\n                     },\n-                ) => toml_edit::value(v),\n+                ) => {\n+                    // Strip build metadata if present\n+                    let clean = v.splitn(2, '+').next().unwrap_or(&v);\n+                    toml_edit::value(clean)\n+                },\n                 // Other cases are represented as an inline table\n                 (optional, default_features, source) => {\n                     let mut data = toml_edit::InlineTable::default();\n@@ -126,7 +130,9 @@ impl Dependency {\n                     match source {\n                         DependencySource::Version { version, path } => {\n                             if let Some(v) = version {\n-                                data.get_or_insert(\"version\", v);\n+                                // Strip build metadata if present\n+                                let clean = v.splitn(2, '+').next().unwrap_or(&v);\n+                                data.get_or_insert(\"version\", clean);\n                             }\n                             if let Some(p) = path {\n                                 data.get_or_insert(\"path\", p);\n"}
{"instance_id": "bincode-org__bincode-434", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/enc/mod.rs b/src/enc/mod.rs\nindex bb11057..0d63ef6 100644\n--- a/src/enc/mod.rs\n+++ b/src/enc/mod.rs\n@@ -19,6 +19,19 @@ pub trait Encode {\n     fn encode<E: Encoder>(&self, encoder: E) -> Result<(), EncodeError>;\n }\n \n+// ----------------------------------------------------------------------------\n+// Blanket impl: allow any serde::Serialize to be used as bincode::Encode\n+// without requiring #[derive(bincode::Encode)].\n+impl<T> Encode for T\n+where\n+    T: serde::Serialize,\n+{\n+    fn encode<E: Encoder>(&self, encoder: E) -> Result<(), EncodeError> {\n+        // Delegate to bincode's serde-based encoder\n+        bincode::serde::encode_with(self, encoder)\n+    }\n+}\n+\n /// Helper trait to encode basic types into.\n pub trait Encoder: Sealed {\n     /// The concrete [Writer] type\n"}
{"instance_id": "tracel-ai__burn-2224", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/burn-ndarray/src/ops/interpolate.rs b/crates/burn-ndarray/src/ops/interpolate.rs\nindex b2f65dc4..54a0b906 100644\n--- a/crates/burn-ndarray/src/ops/interpolate.rs\n+++ b/crates/burn-ndarray/src/ops/interpolate.rs\n@@ -96,8 +96,17 @@ pub(crate) fn bilinear_interpolate<E: FloatNdArrayElement>(\n     let (batch_size, channels, in_height, in_width) = x.dim();\n     let [out_height, out_width] = output_size;\n \n-    let y_ratio = ((in_height - 1) as f64) / ((out_height - 1) as f64);\n-    let x_ratio = ((in_width - 1) as f64) / ((out_width - 1) as f64);\n+    // Avoid division by zero when height or width is 1:\n+    let y_ratio = if out_height > 1 {\n+        ((in_height - 1) as f64) / ((out_height - 1) as f64)\n+    } else {\n+        0.0\n+    };\n+    let x_ratio = if out_width > 1 {\n+        ((in_width - 1) as f64) / ((out_width - 1) as f64)\n+    } else {\n+        0.0\n+    };\n \n     let out_element_num = batch_size * channels * out_height * out_width;\n     let strides = (\n@@ -174,8 +183,17 @@ pub(crate) fn bicubic_interpolate<E: FloatNdArrayElement>(\n     let (batch_size, channels, in_height, in_width) = x.dim();\n     let [out_height, out_width] = output_size;\n \n-    let y_ratio = ((in_height - 1) as f64) / ((out_height - 1) as f64);\n-    let x_ratio = ((in_width - 1) as f64) / ((out_width - 1) as f64);\n+    // Avoid division by zero when height or width is 1:\n+    let y_ratio = if out_height > 1 {\n+        ((in_height - 1) as f64) / ((out_height - 1) as f64)\n+    } else {\n+        0.0\n+    };\n+    let x_ratio = if out_width > 1 {\n+        ((in_width - 1) as f64) / ((out_width - 1) as f64)\n+    } else {\n+        0.0\n+    };\n \n     let out_element_num = batch_size * channels * out_height * out_width;\n     let strides = (\n"}
{"instance_id": "rust-lang__cc-rs-227", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 9af1793..50e0829 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -240,8 +240,9 @@ impl Config {\n     ///             .define(\"BAZ\", None)\n     ///             .compile(\"foo\");\n     /// ```\n-    pub fn define(&mut self, var: &str, val: Option<&str>) -> &mut Config {\n-        self.definitions.push((var.to_string(), val.map(|s| s.to_string())));\n+    pub fn define<I: Into<Option<&str>>>(&mut self, var: &str, val: I) -> &mut Config {\n+        let opt = val.into();\n+        self.definitions.push((var.to_string(), opt.map(|s| s.to_string())));\n         self\n     }\n \n@@ -385,8 +386,9 @@ impl Config {\n     /// otherwise cargo will link against the specified library.\n     ///\n     /// The given library name must not contain the `lib` prefix.\n-    pub fn cpp_link_stdlib(&mut self, cpp_link_stdlib: Option<&str>) -> &mut Config {\n-        self.cpp_link_stdlib = Some(cpp_link_stdlib.map(|s| s.into()));\n+    pub fn cpp_link_stdlib<I: Into<Option<&str>>>(&mut self, cpp_link_stdlib: I) -> &mut Config {\n+        let opt = cpp_link_stdlib.into();\n+        self.cpp_link_stdlib = Some(opt.map(|s| s.to_string()));\n         self\n     }\n \n@@ -410,9 +412,10 @@ impl Config {\n     /// be used, otherwise `-stdlib` is added to the compile invocation.\n     ///\n     /// The given library name must not contain the `lib` prefix.\n-    pub fn cpp_set_stdlib(&mut self, cpp_set_stdlib: Option<&str>) -> &mut Config {\n-        self.cpp_set_stdlib = cpp_set_stdlib.map(|s| s.into());\n-        self.cpp_link_stdlib(cpp_set_stdlib);\n+    pub fn cpp_set_stdlib<I: Into<Option<&str>>>(&mut self, cpp_set_stdlib: I) -> &mut Config {\n+        let opt = cpp_set_stdlib.into();\n+        self.cpp_set_stdlib = opt.map(|s| s.to_string());\n+        self.cpp_link_stdlib(opt);\n         self\n     }\n \n"}
{"instance_id": "mozilla__cbindgen-454", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bindgen/utilities.rs b/src/bindgen/utilities.rs\nindex c29afa9..cc9a21c 100644\n--- a/src/bindgen/utilities.rs\n+++ b/src/bindgen/utilities.rs\n@@ -283,13 +283,21 @@ impl SynAttributeHelpers for [syn::Attribute] {\n }\n \n fn split_doc_attr(input: &str) -> Vec<String> {\n-    input\n-        // Convert two newline (indicate \"new paragraph\") into two line break.\n-        .replace(\"\\n\\n\", \"  \\n  \\n\")\n-        // Convert newline after two spaces (indicate \"line break\") into line break.\n-        .split(\"  \\n\")\n-        // Convert single newline (indicate hard-wrapped) into space.\n-        .map(|s| s.replace('\\n', \" \"))\n-        .map(|s| s.trim_end().to_string())\n-        .collect()\n+    // Split on double newlines to separate paragraphs\n+    let paragraphs: Vec<&str> = input.split(\"\\n\\n\").collect();\n+    let mut result = Vec::new();\n+    for (i, para) in paragraphs.iter().enumerate() {\n+        // Collapse remaining newlines to spaces, then collapse runs of whitespace\n+        let line = para.replace('\\n', \" \");\n+        let line = line\n+            .split_whitespace()\n+            .collect::<Vec<_>>()\n+            .join(\" \");\n+        result.push(line);\n+        // Between paragraphs, insert an empty-line entry\n+        if i + 1 < paragraphs.len() {\n+            result.push(String::new());\n+        }\n+    }\n+    result\n }\n"}
{"instance_id": "cargo-generate__cargo-generate-785", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/args.rs b/src/args.rs\nindex 1c44b23..fa8f972 100644\n--- a/src/args.rs\n+++ b/src/args.rs\n@@ -8,13 +8,13 @@ use clap::{Args, Parser};\n use serde::Deserialize;\n \n use crate::git;\n-\n-#[derive(Parser)]\n-#[clap(name = \"cargo generate\")]\n-#[clap(bin_name = \"cargo\")]\n-#[clap(arg_required_else_help(true))]\n-#[clap(version)]\n-#[clap(about)]\n+  \n+#[derive(Parser)]  \n+#[command(name = \"cargo generate\")]  \n+#[command(bin_name = \"cargo\")]  \n+#[command(arg_required_else_help = true)]  \n+#[command(version)]  \n+#[command(about)]  \n pub enum Cli {\n     #[clap(name = \"generate\", visible_alias = \"gen\")]\n     Generate(GenerateArgs),\n"}
{"instance_id": "cargo-generate__cargo-generate-680", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/config.rs b/src/config.rs\nindex be37a61..d2dfeba 100644\n--- a/src/config.rs\n+++ b/src/config.rs\n@@ -28,6 +28,9 @@ pub struct TemplateConfig {\n     pub include: Option<Vec<String>>,\n     pub exclude: Option<Vec<String>>,\n     pub ignore: Option<Vec<String>>,\n+    /// If true, the template opts into \"init\" behavior (no sub-folder).\n+    #[serde(default)]\n+    pub init: bool,\n }\n \n #[derive(Deserialize, Debug, PartialEq, Clone)]\ndiff --git a/src/lib.rs b/src/lib.rs\nindex 3f5e8c6..45df838 100755\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -97,11 +97,17 @@ pub fn generate(mut args: GenerateArgs) -> Result<PathBuf> {\n \n     let (template_base_dir, template_folder, branch) = prepare_local_template(&source_template)?;\n \n-    let template_config = Config::from_path(\n+    let mut template_config = Config::from_path(\n         &locate_template_file(CONFIG_FILE_NAME, &template_base_dir, &template_folder).ok(),\n     )?\n     .unwrap_or_default();\n \n+    // If the template requests init behavior, treat it like --init was passed.\n+    if template_config.init {\n+        args.init = true;\n+        args.destination = None;\n+    }\n+\n     check_cargo_generate_version(&template_config)?;\n \n     let base_dir = env::current_dir()?;\n"}
{"instance_id": "bevyengine__bevy-16475", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_image/src/image.rs b/crates/bevy_image/src/image.rs\nindex cfe3a768d..dd7607ff2 100644\n--- a/crates/bevy_image/src/image.rs\n+++ b/crates/bevy_image/src/image.rs\n@@ -1104,6 +1104,32 @@ impl Image {\n             });\n         };\n \n+        // Ensure we have enough bytes for this format, otherwise return OutOfBounds\n+        let required_bytes = match self.texture_descriptor.format {\n+            TextureFormat::Rgba8UnormSrgb\n+            | TextureFormat::Rgba8Unorm\n+            | TextureFormat::Rgba8Uint\n+            | TextureFormat::Bgra8UnormSrgb\n+            | TextureFormat::Bgra8Unorm => 4,\n+            TextureFormat::Rgba16Unorm | TextureFormat::Rgba16Uint => 8,\n+            TextureFormat::Rgba32Float | TextureFormat::Rgba32Uint => 16,\n+            TextureFormat::R8Unorm | TextureFormat::R8Uint => 1,\n+            TextureFormat::R16Unorm | TextureFormat::R16Uint => 2,\n+            TextureFormat::R32Uint | TextureFormat::R32Float => 4,\n+            TextureFormat::Rg8Unorm | TextureFormat::Rg8Uint => 2,\n+            TextureFormat::Rg16Unorm | TextureFormat::Rg16Uint => 4,\n+            TextureFormat::Rg32Uint | TextureFormat::Rg32Float => 8,\n+            // For any other formats, we\u2019ll let the existing UnsupportedTextureFormat branch handle it.\n+            _ => 0,\n+        };\n+        if required_bytes > 0 && bytes.len() < required_bytes {\n+            return Err(TextureAccessError::OutOfBounds {\n+                x: coords.x,\n+                y: coords.y,\n+                z: coords.z,\n+            });\n+        }\n+\n         // NOTE: GPUs are always Little Endian.\n         // Make sure to respect that when we create color values from bytes.\n         match self.texture_descriptor.format {\n"}
{"instance_id": "axodotdev__cargo-dist-417", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/cargo-dist/src/config.rs b/cargo-dist/src/config.rs\nindex 73bd3b0c..5bf99868 100644\n--- a/cargo-dist/src/config.rs\n+++ b/cargo-dist/src/config.rs\n@@ -243,6 +243,13 @@ pub struct DistMetadata {\n     #[serde(rename = \"publish-jobs\")]\n     pub publish_jobs: Option<Vec<PublishStyle>>,\n \n+    /// Upload jobs to run in CI\n+    ///\n+    /// (defaults to none)\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"upload-jobs\")]\n+    pub upload_jobs: Option<Vec<String>>,\n+\n     /// Whether to publish prereleases to package managers\n     ///\n     /// (defaults to false)\ndiff --git a/cargo-dist/src/init.rs b/cargo-dist/src/init.rs\nindex fca5ebeb..f4344b46 100644\n--- a/cargo-dist/src/init.rs\n+++ b/cargo-dist/src/init.rs\n@@ -842,6 +842,13 @@ fn apply_dist_to_metadata(metadata: &mut toml_edit::Item, meta: &DistMetadata) {\n         publish_jobs.as_ref(),\n     );\n \n+    apply_string_list(\n+        table,\n+        \"upload-jobs\",\n+        \"# Upload jobs to run in CI\\n\",\n+        upload_jobs.as_ref(),\n+    );\n+\n     apply_optional_value(\n         table,\n         \"publish-prereleases\",\n"}
{"instance_id": "tokio-rs__bytes-432", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/buf/buf_mut.rs b/src/buf/buf_mut.rs\nindex 4f6e47d..026bcad 100644\n--- a/src/buf/buf_mut.rs\n+++ b/src/buf/buf_mut.rs\n@@ -30,7 +30,7 @@ use alloc::{boxed::Box, vec::Vec};\n ///\n /// assert_eq!(buf, b\"hello world\");\n /// ```\n-pub trait BufMut {\n+pub unsafe trait BufMut {\n     /// Returns the number of bytes that can be written from the current\n     /// position until the end of the buffer is reached.\n     ///\n@@ -992,15 +992,15 @@ macro_rules! deref_forward_bufmut {\n     };\n }\n \n-impl<T: BufMut + ?Sized> BufMut for &mut T {\n+unsafe impl<T: BufMut + ?Sized> BufMut for &mut T {\n     deref_forward_bufmut!();\n }\n \n-impl<T: BufMut + ?Sized> BufMut for Box<T> {\n+unsafe impl<T: BufMut + ?Sized> BufMut for Box<T> {\n     deref_forward_bufmut!();\n }\n \n-impl BufMut for &mut [u8] {\n+unsafe impl BufMut for &mut [u8] {\n     #[inline]\n     fn remaining_mut(&self) -> usize {\n         self.len()\n@@ -1020,7 +1020,7 @@ impl BufMut for &mut [u8] {\n     }\n }\n \n-impl BufMut for Vec<u8> {\n+unsafe impl BufMut for Vec<u8> {\n     #[inline]\n     fn remaining_mut(&self) -> usize {\n         usize::MAX - self.len()\ndiff --git a/src/bytes_mut.rs b/src/bytes_mut.rs\nindex a7a8e57..16cb72c 100644\n--- a/src/bytes_mut.rs\n+++ b/src/bytes_mut.rs\n@@ -966,7 +966,7 @@ impl Buf for BytesMut {\n     }\n }\n \n-impl BufMut for BytesMut {\n+unsafe impl BufMut for BytesMut {\n     #[inline]\n     fn remaining_mut(&self) -> usize {\n         usize::MAX - self.len()\n"}
{"instance_id": "tokio-rs__axum-533", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/body/mod.rs b/axum/src/body/mod.rs\nindex c96b6f36..e34aa822 100644\n--- a/axum/src/body/mod.rs\n+++ b/axum/src/body/mod.rs\n@@ -22,7 +22,18 @@ pub use bytes::Bytes;\n pub type BoxBody = http_body::combinators::UnsyncBoxBody<Bytes, Error>;\n \n /// Convert a [`http_body::Body`] into a [`BoxBody`].\n+#[deprecated(since = \"0.3.4\", note = \"please use `boxed` instead\")]\n pub fn box_body<B>(body: B) -> BoxBody\n+where\n+    B: http_body::Body<Data = Bytes> + Send + 'static,\n+    B::Error: Into<BoxError>,\n+{\n+    // forward to the new, preferred function\n+    boxed(body)\n+}\n+\n+/// Convert a [`http_body::Body`] into a [`BoxBody`].\n+pub fn boxed<B>(body: B) -> BoxBody\n where\n     B: http_body::Body<Data = Bytes> + Send + 'static,\n     B::Error: Into<BoxError>,\n"}
{"instance_id": "tokio-rs__axum-2903", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/routing/mod.rs b/axum/src/routing/mod.rs\nindex ff43a56c..d00999ff 100644\n--- a/axum/src/routing/mod.rs\n+++ b/axum/src/routing/mod.rs\n@@ -338,6 +338,19 @@ where\n         .fallback_endpoint(Endpoint::MethodRouter(any(handler)))\n     }\n \n+    #[track_caller]\n+    #[doc = \"Add a `MethodNotAllowed` fallback [`Handler`] to the router.\\n\\nThis sets a handler that will be called when a request matches a path but has no handler for its method (HTTP 405).\"]\n+    pub fn method_not_allowed_fallback<H, T>(self, handler: H) -> Self\n+    where\n+        H: Handler<T, S>,\n+        T: 'static,\n+    {\n+        tap_inner!(self, mut this => {\n+            this.method_not_allowed_handler =\n+                Some(BoxedIntoRoute::from_handler(handler.clone()));\n+        })\n+    }\n+\n     /// Add a fallback [`Service`] to the router.\n     ///\n     /// See [`Router::fallback`] for more details.\n"}
{"instance_id": "rust-lang__cc-rs-1279", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 7f21b05..d358f97 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1936,6 +1936,25 @@ impl Build {\n                 cmd.push_cc_arg((**flag).into());\n             }\n         }\n+        // Inherit Rust target features (e.g., propagate AArch64 BTI)\n+        if let Ok(cfg_feats) = self.getenv(\"CARGO_CFG_TARGET_FEATURE\") {\n+            if let Some(feats_str) = cfg_feats.to_str() {\n+                for feat in feats_str.split(',') {\n+                    match feat {\n+                        \"bti\" => {\n+                            let flag_str = \"-mbranch-protection=bti\";\n+                            if self\n+                                .is_flag_supported_inner(OsStr::new(flag_str), &cmd.path, &target)\n+                                .unwrap_or(false)\n+                            {\n+                                cmd.push_cc_arg(flag_str.into());\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n \n         for (key, value) in self.definitions.iter() {\n             if let Some(ref value) = *value {\n"}
{"instance_id": "rust-fuzz__cargo-fuzz-264", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/project.rs b/src/project.rs\nindex 38097af..88055a9 100644\n--- a/src/project.rs\n+++ b/src/project.rs\n@@ -541,7 +541,8 @@ impl FuzzProject {\n             }\n \n             eprintln!(\n-                \"Reproduce with:\\n\\n\\tcargo fuzz run {target} {artifact}\\n\",\n+                \"Reproduce with:\\n\\n\\tcargo fuzz run{options} {target} {artifact}\\n\",\n+                options = &tmin.build,\n                 target = &tmin.target,\n                 artifact = artifact.display()\n             );\n"}
{"instance_id": "tokio-rs__bytes-253", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes.rs b/src/bytes.rs\nindex e155931..2a6d9b0 100644\n--- a/src/bytes.rs\n+++ b/src/bytes.rs\n@@ -1265,6 +1265,8 @@ impl BytesMut {\n     ///\n     /// Panics if `at > len`.\n     pub fn split_to(&mut self, at: usize) -> BytesMut {\n+        // enforce documented panic on out-of-bounds split\n+        assert!(at <= self.len());\n         BytesMut {\n             inner: self.inner.split_to(at),\n         }\n"}
{"instance_id": "rinja-rs__askama-458", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/askama_rocket/src/lib.rs b/askama_rocket/src/lib.rs\nindex ee70965..2e8b574 100644\n--- a/askama_rocket/src/lib.rs\n+++ b/askama_rocket/src/lib.rs\n@@ -8,7 +8,10 @@ pub use rocket::response::{Responder, Result};\n \n pub fn respond<T: Template>(t: &T, ext: &str) -> Result<'static> {\n     let rsp = t.render().map_err(|_| Status::InternalServerError)?;\n-    let ctype = ContentType::from_extension(ext).ok_or(Status::InternalServerError)?;\n+    // Normalize compound extensions (e.g. \"html.j2\" \u2192 \"html\")\n+    let normalized_ext = ext.splitn(2, '.').next().unwrap_or(ext);\n+    let ctype = ContentType::from_extension(normalized_ext)\n+        .ok_or(Status::InternalServerError)?;\n     Response::build()\n         .header(ctype)\n         .sized_body(rsp.len(), Cursor::new(rsp))\n"}
{"instance_id": "chronotope__chrono-1621", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/weekday.rs b/src/weekday.rs\nindex f41b584..3b3cb95 100644\n--- a/src/weekday.rs\n+++ b/src/weekday.rs\n@@ -171,7 +171,7 @@ impl Weekday {\n \n impl fmt::Display for Weekday {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n+        let s = match *self {\n             Weekday::Mon => \"Mon\",\n             Weekday::Tue => \"Tue\",\n             Weekday::Wed => \"Wed\",\n@@ -179,7 +179,8 @@ impl fmt::Display for Weekday {\n             Weekday::Fri => \"Fri\",\n             Weekday::Sat => \"Sat\",\n             Weekday::Sun => \"Sun\",\n-        })\n+        };\n+        f.pad(s)\n     }\n }\n \n"}
{"instance_id": "chronotope__chrono-308", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/offset/mod.rs b/src/offset/mod.rs\nindex 0ea0dc2..e81984c 100644\n--- a/src/offset/mod.rs\n+++ b/src/offset/mod.rs\n@@ -381,6 +381,29 @@ pub trait TimeZone: Sized + Clone {\n         self.timestamp_opt(secs, millis as u32 * 1_000_000)\n     }\n \n+    /// Makes a new `DateTime` from the number of non-leap nanoseconds\n+    /// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\").\n+    ///\n+    /// Panics on out-of-range number of nanoseconds; for a non-panicking version\n+    /// see [`timestamp_nanos_opt`](#method.timestamp_nanos_opt).\n+    fn timestamp_nanos(&self, nanos: i64) -> DateTime<Self> {\n+        self.timestamp_nanos_opt(nanos).unwrap()\n+    }\n+\n+    /// Makes a new `DateTime` from the number of non-leap nanoseconds\n+    /// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\").\n+    ///\n+    /// Returns `LocalResult::None` on out-of-range number of nanoseconds,\n+    /// otherwise always returns `LocalResult::Single`.\n+    fn timestamp_nanos_opt(&self, nanos: i64) -> LocalResult<DateTime<Self>> {\n+        let (mut secs, mut rem) = (nanos / 1_000_000_000, nanos % 1_000_000_000);\n+        if rem < 0 {\n+            secs -= 1;\n+            rem += 1_000_000_000;\n+        }\n+        self.timestamp_opt(secs, rem as u32)\n+    }\n+\n     /// Parses a string with the specified format string and\n     /// returns a `DateTime` with the current offset.\n     /// See the [`format::strftime` module](../format/strftime/index.html)\n"}
{"instance_id": "boa-dev__boa-770", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/object/mod.rs b/boa/src/builtins/object/mod.rs\nindex 42930379..945c035c 100644\n--- a/boa/src/builtins/object/mod.rs\n+++ b/boa/src/builtins/object/mod.rs\n@@ -99,8 +99,14 @@ impl Object {\n     pub fn define_property(_: &Value, args: &[Value], ctx: &mut Context) -> Result<Value> {\n         let obj = args.get(0).expect(\"Cannot get object\");\n         let prop = args.get(1).expect(\"Cannot get object\").to_string(ctx)?;\n+        // Convert the key into a PropertyKey (string, symbol, or index) rather than always a string\n+        let key = args\n+            .get(1)\n+            .expect(\"Cannot get property key\")\n+            .to_property_key(ctx)?;\n         let desc = Property::from(args.get(2).expect(\"Cannot get object\"));\n         obj.set_property(prop, desc);\n+        obj.set_property(key, desc);\n         Ok(Value::undefined())\n     }\n \n"}
{"instance_id": "boa-dev__boa-782", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/string/mod.rs b/boa/src/builtins/string/mod.rs\nindex 1d92b24b..301ce47c 100644\n--- a/boa/src/builtins/string/mod.rs\n+++ b/boa/src/builtins/string/mod.rs\n@@ -331,7 +331,14 @@ impl String {\n         // Then we convert it into a Rust String by wrapping it in from_value\n         let primitive_val = this.to_string(ctx)?;\n \n-        // TODO: Should throw TypeError if pattern is regular expression\n+        // Throw TypeError if pattern is regular expression\n+        if let Some(pattern) = args.get(0) {\n+            if pattern.is_regexp(ctx)? {\n+                return ctx.throw_type_error(\n+                    \"First argument to String.prototype.startsWith must not be a regular expression\",\n+                );\n+            }\n+        }\n         let search_string = args\n             .get(0)\n             .expect(\"failed to get argument for String method\")\n@@ -420,7 +427,14 @@ impl String {\n         // Then we convert it into a Rust String by wrapping it in from_value\n         let primitive_val = this.to_string(ctx)?;\n \n-        // TODO: Should throw TypeError if search_string is regular expression\n+        // Throw TypeError if search_string is regular expression\n+        if let Some(search_val) = args.get(0) {\n+            if search_val.is_regexp(ctx)? {\n+                return ctx.throw_type_error(\n+                    \"First argument to String.prototype.includes must not be a regular expression\",\n+                );\n+            }\n+        }\n         let search_string = args\n             .get(0)\n             .expect(\"failed to get argument for String method\")\n"}
{"instance_id": "cargo-generate__cargo-generate-1172", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/template_variables/project_dir.rs b/src/template_variables/project_dir.rs\nindex 3987805..800745f 100644\n--- a/src/template_variables/project_dir.rs\n+++ b/src/template_variables/project_dir.rs\n@@ -44,23 +44,7 @@ impl TryFrom<(&ProjectNameInput, &UserParsedInput)> for ProjectDir {\n             .name()\n             .map_or_else(|| project_name_input.as_ref().to_owned(), String::from);\n \n-        let dir_name = user_parsed_input\n-            .force()\n-            .then(|| name.clone())\n-            .unwrap_or_else(|| {\n-                let renamed_project_name = name.to_kebab_case();\n-                if renamed_project_name != name {\n-                    warn!(\n-                        \"{} `{}` {} `{}`{}\",\n-                        style(\"Renaming project called\").bold(),\n-                        style(name).bold().yellow(),\n-                        style(\"to\").bold(),\n-                        style(&renamed_project_name).bold().green(),\n-                        style(\"...\").bold()\n-                    );\n-                }\n-                renamed_project_name\n-            });\n+        let dir_name = name.clone();\n \n         let project_dir = base_path.join(dir_name);\n \n"}
{"instance_id": "tracel-ai__burn-2186", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/burn-core/src/nn/norm/layer.rs b/crates/burn-core/src/nn/norm/layer.rs\nindex ea196906..91f4b8dd 100644\n--- a/crates/burn-core/src/nn/norm/layer.rs\n+++ b/crates/burn-core/src/nn/norm/layer.rs\n@@ -67,7 +67,7 @@ impl<B: Backend> LayerNorm<B> {\n     pub fn forward<const D: usize>(&self, input: Tensor<B, D>) -> Tensor<B, D> {\n         let (var, mean) = input.clone().var_mean_bias(D - 1);\n \n-        let input_normalized = input.sub(mean).div(var.sqrt().add_scalar(self.epsilon));\n+        let input_normalized = input.sub(mean).div(var.add_scalar(self.epsilon).sqrt());\n \n         input_normalized\n             .mul(self.gamma.val().unsqueeze())\n"}
{"instance_id": "async-graphql__async-graphql-1048", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/registry/export_sdl.rs b/src/registry/export_sdl.rs\nindex faa22946..a6e56e80 100644\n--- a/src/registry/export_sdl.rs\n+++ b/src/registry/export_sdl.rs\n@@ -367,7 +367,7 @@ impl Registry {\n                         write!(sdl, \" @tag(name: \\\"{}\\\")\", tag.replace('\"', \"\\\\\\\"\")).ok();\n                     }\n                 }\n-                writeln!(sdl, \"{{\").ok();\n+                writeln!(sdl, \" {{\").ok();\n \n                 let mut values = enum_values.values().collect::<Vec<_>>();\n                 if options.sorted_enum_values {\n"}
{"instance_id": "axodotdev__cargo-dist-367", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/cargo-dist/src/config.rs b/cargo-dist/src/config.rs\nindex d6d692d0..23759623 100644\n--- a/cargo-dist/src/config.rs\n+++ b/cargo-dist/src/config.rs\n@@ -390,6 +390,8 @@ pub struct Config {\n     pub installers: Vec<InstallerStyle>,\n     /// The (git) tag to use for this Announcement.\n     pub announcement_tag: Option<String>,\n+    /// Whether to actually create GitHub releases\n+    pub enable_release: bool,\n }\n \n /// How we should select the artifacts to build\n"}
{"instance_id": "boa-dev__boa-390", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/syntax/parser/statement/try_stm/mod.rs b/boa/src/syntax/parser/statement/try_stm/mod.rs\nindex 5cdcd9c3..f98ba990 100644\n--- a/boa/src/syntax/parser/statement/try_stm/mod.rs\n+++ b/boa/src/syntax/parser/statement/try_stm/mod.rs\n@@ -68,6 +68,8 @@ impl TokenParser for TryStatement {\n \n         // CATCH\n         let (catch, param) = if next_token.kind == TokenKind::Keyword(Keyword::Catch) {\n+            // Catch keyword\n+            cursor.expect(Keyword::Catch, \"catch in try statement\")?;\n             // Catch binding\n             cursor.expect(Punctuator::OpenParen, \"catch in try statement\")?;\n             // TODO: CatchParameter - BindingPattern\n"}
{"instance_id": "biomejs__biome-326", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_service/src/configuration/parse/json/json_impl/mod.rs b/crates/biome_service/src/configuration/parse/json/json_impl/mod.rs\nindex 14fda04005..3e280a0428 100644\n--- a/crates/biome_service/src/configuration/parse/json/json_impl/mod.rs\n+++ b/crates/biome_service/src/configuration/parse/json/json_impl/mod.rs\n@@ -62,6 +62,8 @@ impl VisitNode<JsonLanguage> for JsonParser {\n         let name_text = name.text();\n         if name_text == \"allowComments\" {\n             self.allow_comments = self.map_to_boolean(&value, name_text, diagnostics);\n+        } else if name_text == \"allowTrailingCommas\" {\n+            self.allow_trailing_commas = self.map_to_boolean(&value, name_text, diagnostics);\n         }\n \n         Some(())\n"}
{"instance_id": "cargo-generate__cargo-generate-691", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex a72fe8b..c34cd71 100755\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -76,7 +76,13 @@ use self::template::create_liquid_object;\n \n pub fn generate(args: GenerateArgs) -> Result<PathBuf> {\n     let cwd = std::env::current_dir()?;\n-    let r = internal_generate(args);\n+    // Pass the overwrite flag into the dir\u2010resolution and generation functions\n+    let r = {\n+        let overwrite = args.overwrite;\n+        // Resolve project dir, allowing overwrite\n+        let target = resolve_project_dir(&args.template, &args.name, overwrite)?;\n+        internal_generate(args, target, overwrite)\n+    };\n     std::env::set_current_dir(cwd)?;\n     r\n }\n"}
{"instance_id": "tokio-rs__bytes-413", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes_mut.rs b/src/bytes_mut.rs\nindex 4bfe0ff..34fb93e 100644\n--- a/src/bytes_mut.rs\n+++ b/src/bytes_mut.rs\n@@ -559,14 +559,15 @@ impl BytesMut {\n             unsafe {\n                 let (off, prev) = self.get_vec_pos();\n \n-                // Only reuse space if we stand to gain at least capacity/2\n-                // bytes of space back\n-                if off >= additional && off >= (self.cap / 2) {\n+                // Reuse when empty (no data to copy), or if we stand to gain\n+                // at least half the capacity back.\n+                if len == 0 || (off >= additional && off >= (self.cap / 2)) {\n                     // There's space - reuse it\n                     //\n                     // Just move the pointer back to the start after copying\n                     // data back.\n                     let base_ptr = self.ptr.as_ptr().offset(-(off as isize));\n+                    // copy zero bytes when len == 0 is a no-op\n                     ptr::copy(self.ptr.as_ptr(), base_ptr, self.len);\n                     self.ptr = vptr(base_ptr);\n                     self.set_vec_pos(0, prev);\n"}
{"instance_id": "rinja-rs__askama-359", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/askama_shared/src/filters/mod.rs b/askama_shared/src/filters/mod.rs\nindex f203348..70bb3b5 100644\n--- a/askama_shared/src/filters/mod.rs\n+++ b/askama_shared/src/filters/mod.rs\n@@ -23,7 +23,7 @@ use askama_escape::{Escaper, MarkupDisplay};\n #[cfg(feature = \"humansize\")]\n use humansize::{file_size_opts, FileSize};\n #[cfg(feature = \"num-traits\")]\n-use num_traits::{cast::NumCast, Signed};\n+use num_traits::{ToPrimitive, Signed};\n #[cfg(feature = \"percent-encoding\")]\n use percent_encoding::{utf8_percent_encode, AsciiSet, NON_ALPHANUMERIC};\n \n@@ -249,18 +249,18 @@ pub fn indent(s: &dyn fmt::Display, width: &usize) -> Result<String> {\n \n #[cfg(feature = \"num-traits\")]\n /// Casts number to f64\n-pub fn into_f64<T>(number: T) -> Result<f64>\n+pub fn into_f64<T>(number: &T) -> Result<f64>\n where\n-    T: NumCast,\n+    T: ToPrimitive,\n {\n     number.to_f64().ok_or(Fmt(fmt::Error))\n }\n \n #[cfg(feature = \"num-traits\")]\n /// Casts number to isize\n-pub fn into_isize<T>(number: T) -> Result<isize>\n+pub fn into_isize<T>(number: &T) -> Result<isize>\n where\n-    T: NumCast,\n+    T: ToPrimitive,\n {\n     number.to_isize().ok_or(Fmt(fmt::Error))\n }\n"}
{"instance_id": "biomejs__biome-2989", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_service/src/matcher/pattern.rs b/crates/biome_service/src/matcher/pattern.rs\nindex 291056460f..9711f6d16d 100644\n--- a/crates/biome_service/src/matcher/pattern.rs\n+++ b/crates/biome_service/src/matcher/pattern.rs\n@@ -91,6 +91,9 @@ enum PatternToken {\n     AnySequence,\n     AnyRecursiveSequence,\n     AnyWithin(Vec<CharSpecifier>),\n+    OpenBrace,        // '{'\n+    CloseBrace,       // '}'\n+    Comma,            // ','\n     AnyExcept(Vec<CharSpecifier>),\n }\n \n"}
{"instance_id": "killercup__cargo-edit-734", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bin/upgrade/upgrade.rs b/src/bin/upgrade/upgrade.rs\nindex 8fcae5e3..ff869fb6 100644\n--- a/src/bin/upgrade/upgrade.rs\n+++ b/src/bin/upgrade/upgrade.rs\n@@ -68,7 +68,7 @@ pub struct UpgradeArgs {\n     dry_run: bool,\n \n     /// Only update a dependency if the new version is semver incompatible.\n-    #[clap(long, conflicts_with = \"to-lockfile\")]\n+    #[clap(long, conflicts_with = \"to-lockfile\", default_value_t = true)]\n     skip_compatible: bool,\n \n     /// Only update a dependency if it is not currently pinned in the manifest.\n"}
{"instance_id": "boa-dev__boa-26", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/syntax/lexer.rs b/src/lib/syntax/lexer.rs\nindex 11e749be..14261d37 100644\n--- a/src/lib/syntax/lexer.rs\n+++ b/src/lib/syntax/lexer.rs\n@@ -161,12 +161,10 @@ impl<'a> Lexer<'a> {\n     }\n \n     /// Preview the next character but don't actually increment\n-    fn preview_next(&mut self) -> Result<char, LexerError> {\n-        // No need to return a reference, we can return a copy\n-        match self.buffer.peek() {\n-            Some(v) => Ok(*v),\n-            None => Err(LexerError::new(\"finished\")),\n-        }\n+    /// Returns `Some(c)` if there is a next char, or `None` at end\u2010of\u2010input.\n+    fn preview_next(&mut self) -> Option<char> {\n+        // No need for a Result; EOF is just no data.\n+        self.buffer.peek().cloned()\n     }\n \n     /// Utility Function, while ``f(char)`` is true, read chars and move curser.\n@@ -176,20 +174,28 @@ impl<'a> Lexer<'a> {\n         F: FnMut(char) -> bool,\n     {\n         let mut s = String::new();\n-        while self.buffer.peek().is_some() && f(self.preview_next()?) {\n-            s.push(self.next()?);\n+        // Loop until preview_next() is None, or f(c) becomes false.\n+        while let Some(c) = self.preview_next() {\n+            if f(c) {\n+                s.push(self.next()?);\n+            } else {\n+                break;\n+            }\n         }\n \n         Ok(s)\n     }\n \n-    /// next_is compares the character passed in to the next character, if they match true is returned and the buffer is incremented\n-    fn next_is(&mut self, peek: char) -> Result<bool, LexerError> {\n-        let result = self.preview_next()? == peek;\n-        if result {\n-            self.buffer.next();\n+    /// next_is compares the character passed in to the next character, if they match true is returned and the buffer is incremented.\n+    /// Returns false if at end\u2010of\u2010input or if they don\u2019t match.\n+    fn next_is(&mut self, peek: char) -> bool {\n+        if let Some(c) = self.preview_next() {\n+            if c == peek {\n+                self.buffer.next();\n+                return true;\n+            }\n         }\n-        Ok(result)\n+        false\n     }\n \n     pub fn lex(&mut self) -> Result<(), LexerError> {\n"}
{"instance_id": "biomejs__biome-457", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_cli/src/commands/rage.rs b/crates/biome_cli/src/commands/rage.rs\nindex 339211b9d5..cb4a93a556 100644\n--- a/crates/biome_cli/src/commands/rage.rs\n+++ b/crates/biome_cli/src/commands/rage.rs\n@@ -18,6 +18,7 @@ pub(crate) fn rage(session: CliSession) -> Result<(), CliDiagnostic> {\n         .buffer()\n         .supports_color();\n \n+    // Print all the static info and configuration/workspace rage\n     session.app.console.log(markup!(\"CLI:\\n\"\n     {KeyValuePair(\"Version\", markup!({VERSION}))}\n     {KeyValuePair(\"Color support\", markup!({DebugDisplay(terminal_supports_colors)}))}\n@@ -36,9 +37,20 @@ pub(crate) fn rage(session: CliSession) -> Result<(), CliDiagnostic> {\n \n     {RageConfiguration(&session.app.fs)}\n     {WorkspaceRage(session.app.workspace.deref())}\n-    {ConnectedClientServerLog(session.app.workspace.deref())}\n     ));\n \n+    // Only print daemon/LSP logs if the user asked for them\n+    let show_daemon_logs = session\n+        .matches\n+        .subcommand_matches(\"rage\")\n+        .map(|m| m.is_present(\"daemon-logs\"))\n+        .unwrap_or(false);\n+    if show_daemon_logs {\n+        session.app.console.log(markup!(\n+            {ConnectedClientServerLog(session.app.workspace.deref())}\n+        ));\n+    }\n+\n     if session.app.workspace.server_info().is_none() {\n         session\n             .app\n"}
{"instance_id": "axodotdev__cargo-dist-1067", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/cargo-dist/src/config.rs b/cargo-dist/src/config.rs\nindex 6930e4cd..83eea7af 100644\n--- a/cargo-dist/src/config.rs\n+++ b/cargo-dist/src/config.rs\n@@ -1203,6 +1203,14 @@ pub enum ChecksumStyle {\n     Sha256,\n     /// sha512sum (using the sha2 crate)\n     Sha512,\n+    /// sha3-256 (using the sha3 crate)\n+    Sha3_256,\n+    /// sha3-512 (using the sha3 crate)\n+    Sha3_512,\n+    /// blake2b (using the blake2 crate)\n+    Blake2b,\n+    /// blake2s (using the blake2 crate)\n+    Blake2s,\n     /// Do not checksum\n     False,\n }\n@@ -1211,9 +1219,13 @@ impl ChecksumStyle {\n     /// Get the extension of a checksum\n     pub fn ext(self) -> &'static str {\n         match self {\n-            ChecksumStyle::Sha256 => \"sha256\",\n-            ChecksumStyle::Sha512 => \"sha512\",\n-            ChecksumStyle::False => \"false\",\n+            ChecksumStyle::Sha256   => \"sha256\",\n+            ChecksumStyle::Sha512   => \"sha512\",\n+            ChecksumStyle::Sha3_256 => \"sha3-256\",\n+            ChecksumStyle::Sha3_512 => \"sha3-512\",\n+            ChecksumStyle::Blake2b  => \"blake2b\",\n+            ChecksumStyle::Blake2s  => \"blake2s\",\n+            ChecksumStyle::False    => \"false\",\n         }\n     }\n }\n"}
{"instance_id": "boa-dev__boa-178", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/js/array.rs b/src/lib/js/array.rs\nindex cd1e6a8d..601a36ba 100644\n--- a/src/lib/js/array.rs\n+++ b/src/lib/js/array.rs\n@@ -435,6 +435,35 @@ pub fn find(this: &Value, args: &[Value], interpreter: &mut Interpreter) -> Resu\n     Ok(Gc::new(ValueData::Undefined))\n }\n \n+/// Array.prototype.findIndex ( callback, [thisArg] )\n+///\n+/// The findIndex method executes the callback function once for each index of the array\n+/// until the callback returns a truthy value. If so, findIndex immediately returns the index\n+/// of that element. Otherwise, findIndex returns -1.\n+pub fn find_index(this: &Value, args: &[Value], interpreter: &mut Interpreter) -> ResultValue {\n+    if args.is_empty() {\n+        return Err(to_value(\n+            \"missing callback when calling function Array.prototype.findIndex\".to_string(),\n+        ));\n+    }\n+    let callback = &args[0];\n+    let this_arg = if args.len() > 1 {\n+        args[1].clone()\n+    } else {\n+        Gc::new(ValueData::Undefined)\n+    };\n+    let len: i32 = from_value(this.get_field_slice(\"length\")).unwrap();\n+    for i in 0..len {\n+        let element = this.get_field(&i.to_string());\n+        let arguments = vec![element.clone(), to_value(i), this.clone()];\n+        let result = interpreter.call(callback, &this_arg, arguments)?;\n+        if result.is_true() {\n+            return Ok(to_value(i));\n+        }\n+    }\n+    Ok(to_value(-1))\n+}\n+\n /// Create a new `Array` object\n pub fn create_constructor(global: &Value) -> Value {\n     // Create Constructor\n@@ -468,6 +497,12 @@ pub fn create_constructor(global: &Value) -> Value {\n     array_prototype.set_field_slice(\"unshift\", to_value(unshift as NativeFunctionData));\n     array_prototype.set_field_slice(\"every\", to_value(every as NativeFunctionData));\n     array_prototype.set_field_slice(\"find\", to_value(find as NativeFunctionData));\n+\n+    // Add Array.prototype.findIndex\n+    let find_index_func = to_value(find_index as NativeFunctionData);\n+    find_index_func.set_field_slice(\"length\", to_value(1_i32));\n+    array_prototype.set_field_slice(\"findIndex\", find_index_func);\n+\n     array_prototype.set_field_slice(\"indexOf\", index_of_func);\n     array_prototype.set_field_slice(\"lastIndexOf\", last_index_of_func);\n \n"}
{"instance_id": "tokio-rs__axum-529", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/routing/mod.rs b/axum/src/routing/mod.rs\nindex 261208a0..305fb7a6 100644\n--- a/axum/src/routing/mod.rs\n+++ b/axum/src/routing/mod.rs\n@@ -250,10 +250,13 @@ where\n         }\n \n         self.fallback = match (self.fallback, fallback) {\n-            (Fallback::Default(_), pick @ Fallback::Default(_)) => pick,\n-            (Fallback::Default(_), pick @ Fallback::Custom(_)) => pick,\n+            // If one side is the default fallback, just pick the other\n+            (Fallback::Default(_), pick) => pick,\n             (pick @ Fallback::Custom(_), Fallback::Default(_)) => pick,\n-            (Fallback::Custom(_), pick @ Fallback::Custom(_)) => pick,\n+            // If both routers have a custom fallback, that's not supported\n+            (Fallback::Custom(_), Fallback::Custom(_)) => {\n+                panic!(\"merging two routers that each have a fallback is not supported\");\n+            },\n         };\n \n         self.nested_at_root = self.nested_at_root || nested_at_root;\n"}
{"instance_id": "google__autocxx-341", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/engine/src/conversion/codegen_cpp/function_wrapper_cpp.rs b/engine/src/conversion/codegen_cpp/function_wrapper_cpp.rs\nindex 8df1e26b..c3019f76 100644\n--- a/engine/src/conversion/codegen_cpp/function_wrapper_cpp.rs\n+++ b/engine/src/conversion/codegen_cpp/function_wrapper_cpp.rs\n@@ -56,11 +56,12 @@ impl TypeConversionPolicy {\n                 }\n             }\n             CppConversionType::FromUniquePtrToValue => format!(\"std::move(*{})\", var_name),\n-            CppConversionType::FromValueToUniquePtr => format!(\n-                \"std::make_unique<{}>({})\",\n-                self.unconverted_type()?,\n-                var_name\n-            ),\n+            CppConversionType::FromValueToUniquePtr => {\n+                // Qualify static method calls with the class name:\n+                // e.g. R2Rect::Empty() instead of just Empty()\n+                let ty = self.unconverted_type()?;\n+                format!(\"std::make_unique<{}>({}::{})\", ty, ty, var_name)\n+            },\n         })\n     }\n }\n"}
{"instance_id": "ast-grep__ast-grep-1664", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/core/src/node.rs b/crates/core/src/node.rs\nindex 89315879..6d844def 100644\n--- a/crates/core/src/node.rs\n+++ b/crates/core/src/node.rs\n@@ -31,9 +31,15 @@ impl Position {\n       byte_offset: byte_offset as usize,\n     }\n   }\n-  pub fn row(&self) -> usize {\n+  /// Returns the zero-based line number in the source code.\n+  pub fn line(&self) -> usize {\n     self.row\n   }\n+\n+  #[deprecated(note = \"Use `line` instead of `row`.\")]\n+  pub fn row(&self) -> usize {\n+    self.line()\n+  }\n   /// TODO: return unicode character offset\n   pub fn column<D: Doc>(&self, node: &Node<D>) -> usize {\n     let source = node.root.doc.get_source();\n"}
{"instance_id": "bevyengine__bevy-8691", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_reflect/src/map.rs b/crates/bevy_reflect/src/map.rs\nindex 6e997ffd3..49539517f 100644\n--- a/crates/bevy_reflect/src/map.rs\n+++ b/crates/bevy_reflect/src/map.rs\n@@ -52,6 +52,9 @@ pub trait Map: Reflect {\n     /// Returns the key-value pair at `index` by reference, or `None` if out of bounds.\n     fn get_at(&self, index: usize) -> Option<(&dyn Reflect, &dyn Reflect)>;\n \n+    /// Returns the key-value pair at `index` by mutable reference, or `None` if out of bounds.\n+    fn get_at_mut(&mut self, index: usize) -> Option<(&mut dyn Reflect, &mut dyn Reflect)>;\n+\n     /// Returns the number of elements in the map.\n     fn len(&self) -> usize;\n \n@@ -257,6 +260,12 @@ impl Map for DynamicMap {\n             .map(|(key, value)| (&**key, &**value))\n     }\n \n+    fn get_at_mut(&mut self, index: usize) -> Option<(&mut dyn Reflect, &mut dyn Reflect)> {\n+        self.values\n+            .get_mut(index)\n+            .map(|(key, value)| (&mut **key, &mut **value))\n+    }\n+\n     fn insert_boxed(\n         &mut self,\n         key: Box<dyn Reflect>,\n"}
{"instance_id": "killercup__cargo-edit-290", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/dependency.rs b/src/dependency.rs\nindex c40878b3..71072e84 100644\n--- a/src/dependency.rs\n+++ b/src/dependency.rs\n@@ -15,6 +15,7 @@ pub struct Dependency {\n     /// The name of the dependency (as it is set in its `Cargo.toml` and known to crates.io)\n     pub name: String,\n     optional: bool,\n+    default_features: bool,\n     source: DependencySource,\n }\n \n@@ -23,6 +24,7 @@ impl Default for Dependency {\n         Dependency {\n             name: \"\".into(),\n             optional: false,\n+            default_features: true,\n             source: DependencySource::Version {\n                 version: None,\n                 path: None,\n@@ -80,6 +82,12 @@ impl Dependency {\n         self\n     }\n \n+    /// Set whether to enable default features (default is `true`).\n+    pub fn set_default_features(mut self, enabled: bool) -> Dependency {\n+        self.default_features = enabled;\n+        self\n+    }\n+\n     /// Get version of dependency\n     pub fn version(&self) -> Option<&str> {\n         if let DependencySource::Version {\n@@ -99,19 +107,21 @@ impl Dependency {\n     /// or the path/git repository as an `InlineTable`.\n     /// (If the dependency is set as `optional`, an `InlineTable` is returned in any case.)\n     pub fn to_toml(&self) -> (String, toml_edit::Item) {\n-        let data: toml_edit::Item = match (self.optional, self.source.clone()) {\n-            // Extra short when version flag only\n+        // Only emit the ultra-short form when:\n+        //   optional == false && default_features == true && version is set, no path\n+        let data: toml_edit::Item = match (self.optional, self.default_features, self.source.clone()) {\n             (\n                 false,\n+                true,\n                 DependencySource::Version {\n                     version: Some(v),\n                     path: None,\n                 },\n             ) => toml_edit::value(v),\n-            // Other cases are represented as an inline table\n-            (optional, source) => {\n+            // Otherwise we build an inline table\n+            (optional, default_features, source) => {\n                 let mut data = toml_edit::InlineTable::default();\n-\n+    \n                 match source {\n                     DependencySource::Version { version, path } => {\n                         if let Some(v) = version {\n@@ -125,15 +135,19 @@ impl Dependency {\n                         data.get_or_insert(\"git\", v);\n                     }\n                 }\n-                if self.optional {\n+    \n+                if optional {\n                     data.get_or_insert(\"optional\", optional);\n                 }\n-\n+                if !default_features {\n+                    data.get_or_insert(\"default-features\", false);\n+                }\n+    \n                 data.fmt();\n                 toml_edit::value(toml_edit::Value::InlineTable(data))\n             }\n         };\n-\n+    \n         (self.name.clone(), data)\n     }\n }\n"}
{"instance_id": "biomejs__biome-3207", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_rowan/src/ast/mod.rs b/crates/biome_rowan/src/ast/mod.rs\nindex b0f18e213f..6f76276881 100644\n--- a/crates/biome_rowan/src/ast/mod.rs\n+++ b/crates/biome_rowan/src/ast/mod.rs\n@@ -679,24 +679,23 @@ impl<L: Language, N: AstNode<Language = L>> Iterator for AstSeparatedListElement\n     type Item = AstSeparatedElement<L, N>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let slot = self.slots.next()?;\n-\n-        let node = match slot {\n-            // The node for this element is missing if the next child is a token instead of a node.\n-            SyntaxSlot::Token(token) => panic!(\"Malformed list, node expected but found token {:?} instead. You must add missing markers for missing elements.\", token),\n-            // Missing element\n-            SyntaxSlot::Empty { .. } => Err(SyntaxError::MissingRequiredChild),\n-            SyntaxSlot::Node(node) => Ok(N::unwrap_cast(node))\n+        // Skip any comma\u2010tokens until we hit a Node or an Empty slot.\n+        let node = loop {\n+            match self.slots.next()? {\n+                SyntaxSlot::Token(_) => continue,\n+                SyntaxSlot::Empty { .. } => break Err(SyntaxError::MissingRequiredChild),\n+                SyntaxSlot::Node(node) => break Ok(N::unwrap_cast(node)),\n+            }\n         };\n \n-        let separator = match self.slots.next() {\n-            Some(SyntaxSlot::Empty { .. }) => Err(\n-                SyntaxError::MissingRequiredChild,\n-            ),\n-            Some(SyntaxSlot::Token(token)) => Ok(Some(token)),\n-            // End of list, no trailing separator\n-            None => Ok(None),\n-            Some(SyntaxSlot::Node(node)) => panic!(\"Malformed separated list, separator expected but found node {:?} instead. You must add missing markers for missing separators.\", node),\n+        // Now gather the trailing separator (if any).  Skip stray nodes.\n+        let separator = loop {\n+            match self.slots.next() {\n+                Some(SyntaxSlot::Token(token)) => break Ok(Some(token)),\n+                Some(SyntaxSlot::Empty { .. }) => break Err(SyntaxError::MissingRequiredChild),\n+                Some(SyntaxSlot::Node(_)) => continue,\n+                None => break Ok(None),\n+            }\n         };\n \n         Some(AstSeparatedElement {\n"}
{"instance_id": "bevyengine__bevy-12867", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_math/src/primitives/dim3.rs b/crates/bevy_math/src/primitives/dim3.rs\nindex 887e31c0d..35b0de822 100644\n--- a/crates/bevy_math/src/primitives/dim3.rs\n+++ b/crates/bevy_math/src/primitives/dim3.rs\n@@ -834,14 +834,16 @@ impl Primitive3d for Tetrahedron {}\n \n impl Default for Tetrahedron {\n     /// Returns the default [`Tetrahedron`] with the vertices\n-    /// `[0.0, 0.5, 0.0]`, `[-0.5, -0.5, 0.0]`, `[0.5, -0.5, 0.0]` and `[0.0, 0.0, 0.5]`.\n+    /// `[0.0, 0.625, -0.125]`, `[-0.5, -0.375, -0.125]`,\n+    /// `[0.5, -0.375, -0.125]` and `[0.0, 0.125, 0.375]`,\n+    /// such that its center of mass is at the origin.\n     fn default() -> Self {\n         Self {\n             vertices: [\n-                Vec3::new(0.0, 0.5, 0.0),\n-                Vec3::new(-0.5, -0.5, 0.0),\n-                Vec3::new(0.5, -0.5, 0.0),\n-                Vec3::new(0.0, 0.0, 0.5),\n+                Vec3::new(0.0, 0.625, -0.125),\n+                Vec3::new(-0.5, -0.375, -0.125),\n+                Vec3::new(0.5, -0.375, -0.125),\n+                Vec3::new(0.0, 0.125, 0.375),\n             ],\n         }\n     }\n"}
{"instance_id": "boa-dev__boa-1631", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/syntax/lexer/mod.rs b/boa/src/syntax/lexer/mod.rs\nindex 35c700e8..6cef3593 100644\n--- a/boa/src/syntax/lexer/mod.rs\n+++ b/boa/src/syntax/lexer/mod.rs\n@@ -59,6 +59,8 @@ trait Tokenizer<R> {\n pub struct Lexer<R> {\n     cursor: Cursor<R>,\n     goal_symbol: InputElement,\n+    /// Whether the initial shebang (#!...) has already been skipped.\n+    shebang_skipped: bool,\n }\n \n impl<R> Lexer<R> {\n@@ -110,6 +112,7 @@ impl<R> Lexer<R> {\n         Self {\n             cursor: Cursor::new(reader),\n             goal_symbol: Default::default(),\n+            shebang_skipped: false,\n         }\n     }\n \n@@ -179,6 +182,27 @@ impl<R> Lexer<R> {\n     {\n         let _timer = BoaProfiler::global().start_event(\"next()\", \"Lexing\");\n \n+        // --- shebang support: ignore a leading \"#!\u2026\" line exactly once\n+        if !self.shebang_skipped {\n+            self.shebang_skipped = true;\n+            // If the first byte is '#', and the next is '!', consume and skip line\n+            if let Some(b'#') = self.cursor.peek()? {\n+                let _ = self.cursor.next_byte()?; // consume '#'\n+                if let Some(b'!') = self.cursor.peek()? {\n+                    let _ = self.cursor.next_byte()?; // consume '!'\n+                    // skip until end-of-line or EOF\n+                    while let Some(b) = self.cursor.next_byte()? {\n+                        if b == b'\\n' || b == b'\\r' {\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    // Not actually a shebang\u2014fall through (invalid '#' will be lexed below).\n+                }\n+            }\n+        }\n+        // --- end shebang support\n+\n         let (start, next_ch) = loop {\n             let start = self.cursor.pos();\n             if let Some(next_ch) = self.cursor.next_char()? {\n"}
{"instance_id": "tracel-ai__burn-572", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/burn-tensor/src/tensor/module.rs b/burn-tensor/src/tensor/module.rs\nindex 9999050b..ec88eff3 100644\n--- a/burn-tensor/src/tensor/module.rs\n+++ b/burn-tensor/src/tensor/module.rs\n@@ -110,6 +110,17 @@ where\n     Tensor::new(B::avg_pool2d(x.primitive, kernel_size, stride, padding))\n }\n \n+/// Applies a [2D adaptive avg pooling](crate::ops::ModuleOps::adaptive_avg_pool2d).\n+pub fn adaptive_avg_pool2d<B>(\n+    x: Tensor<B, 4>,\n+    output_size: [usize; 2],\n+) -> Tensor<B, 4>\n+where\n+    B: Backend,\n+{\n+    Tensor::new(B::adaptive_avg_pool2d(x.primitive, output_size))\n+}\n+\n /// Applies a [1D avg pooling](crate::ops::ModuleOps::avg_pool1d).\n pub fn avg_pool1d<B>(\n     x: Tensor<B, 3>,\n"}
{"instance_id": "rinja-rs__askama-861", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/askama_parser/src/expr.rs b/askama_parser/src/expr.rs\nindex ca1dc9b..1993b5c 100644\n--- a/askama_parser/src/expr.rs\n+++ b/askama_parser/src/expr.rs\n@@ -287,7 +287,18 @@ impl<'a> Suffix<'a> {\n             }\n \n             if nested == 0 {\n-                Ok((&i[last..], ()))\n+                // Ensure `last` is on a valid UTF-8 boundary.\n+                let start = if i.is_char_boundary(last) {\n+                    last\n+                } else {\n+                    // Advance to the next character boundary, or end of string.\n+                    i[last..]\n+                        .char_indices()\n+                        .next()\n+                        .map(|(offset, _)| last + offset)\n+                        .unwrap_or(i.len())\n+                };\n+                Ok((&i[start..], ()))\n             } else {\n                 Err(nom::Err::Error(error_position!(\n                     i,\n"}
{"instance_id": "tokio-rs__axum-1934", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/extract/matched_path.rs b/axum/src/extract/matched_path.rs\nindex 57a17bee..dcd81c31 100644\n--- a/axum/src/extract/matched_path.rs\n+++ b/axum/src/extract/matched_path.rs\n@@ -142,8 +142,9 @@ pub(crate) fn set_matched_path_for_request(\n     let matched_path = append_nested_matched_path(matched_path, extensions);\n \n     if matched_path.ends_with(NEST_TAIL_PARAM_CAPTURE) {\n+        // For nested routes, always remove any existing MatchedPath\n+        extensions.remove::<MatchedPath>();\n         extensions.insert(MatchedNestedPath(matched_path));\n-        debug_assert!(matches!(extensions.remove::<MatchedPath>(), None));\n     } else {\n         extensions.insert(MatchedPath(matched_path));\n         extensions.remove::<MatchedNestedPath>();\n"}
{"instance_id": "bevyengine__bevy-12816", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ui/src/layout/mod.rs b/crates/bevy_ui/src/layout/mod.rs\nindex ccff47ae3..8260d7d81 100644\n--- a/crates/bevy_ui/src/layout/mod.rs\n+++ b/crates/bevy_ui/src/layout/mod.rs\n@@ -77,6 +77,13 @@ pub fn ui_layout_system(\n     mut removed_components: UiLayoutSystemRemovedComponentParam,\n     mut node_transform_query: Query<(&mut Node, &mut Transform)>,\n ) {\n+    // Bail out early if no cameras are available to avoid panics when rendering UI.\n+    if cameras.is_empty() {\n+        warn!(\n+            \"No camera found to render UI to. To fix this, add at least one camera to the scene.\"\n+        );\n+        return;\n+    }\n     struct CameraLayoutInfo {\n         size: UVec2,\n         resized: bool,\n"}
{"instance_id": "tokio-rs__axum-1189", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/lib.rs b/axum/src/lib.rs\nindex be095caa..7a37a320 100644\n--- a/axum/src/lib.rs\n+++ b/axum/src/lib.rs\n@@ -297,6 +297,9 @@\n //! The axum repo contains [a number of examples][examples] that show how to put all the\n //! pieces together.\n //!\n+//! Some examples worth highlighting:\n+//! - [get-or-head-special-case][get-or-head-special-case]\n+//!\n //! # Feature flags\n //!\n //! axum uses a set of [feature flags] to reduce the amount of compiled and\n@@ -332,6 +335,7 @@\n //! [`IntoResponse`]: crate::response::IntoResponse\n //! [`Timeout`]: tower::timeout::Timeout\n //! [examples]: https://github.com/tokio-rs/axum/tree/main/examples\n+//! [get-or-head-special-case]: https://github.com/tokio-rs/axum/tree/main/examples/get-or-head-special-case\n //! [`Router::merge`]: crate::routing::Router::merge\n //! [`axum::Server`]: hyper::server::Server\n //! [`Service`]: tower::Service\n"}
{"instance_id": "tokio-rs__bytes-286", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes.rs b/src/bytes.rs\nindex 99022f0..efd2b43 100644\n--- a/src/bytes.rs\n+++ b/src/bytes.rs\n@@ -922,15 +922,26 @@ impl From<String> for Bytes {\n     }\n }\n \n-impl<'a> From<&'a [u8]> for Bytes {\n-    fn from(src: &'a [u8]) -> Bytes {\n-        BytesMut::from(src).freeze()\n+// removed generic impls for &[u8] and &str to avoid accidental copies of 'static data\n+\n+/// Copy a byte\u2010slice into a new `Bytes`.\n+impl Bytes {\n+    pub fn copy_from(src: &[u8]) -> Bytes {\n+        BytesMut::copy_from(src).freeze()\n     }\n }\n \n-impl<'a> From<&'a str> for Bytes {\n-    fn from(src: &'a str) -> Bytes {\n-        BytesMut::from(src).freeze()\n+/// Zero\u2010copy from a `'static` slice.\n+impl From<&'static [u8]> for Bytes {\n+    fn from(src: &'static [u8]) -> Bytes {\n+        Bytes::from_static(src)\n+    }\n+}\n+\n+/// Zero\u2010copy from a `'static` str.\n+impl From<&'static str> for Bytes {\n+    fn from(src: &'static str) -> Bytes {\n+        Bytes::from_static(src.as_bytes())\n     }\n }\n \n@@ -1650,8 +1661,11 @@ impl From<String> for BytesMut {\n     }\n }\n \n-impl<'a> From<&'a [u8]> for BytesMut {\n-    fn from(src: &'a [u8]) -> BytesMut {\n+// removed generic impls for &[u8] and &str\n+\n+impl BytesMut {\n+    /// Copy a byte\u2010slice into a new `BytesMut`.\n+    pub fn copy_from(src: &[u8]) -> BytesMut {\n         let len = src.len();\n \n         if len == 0 {\n@@ -1665,9 +1679,7 @@ impl<'a> From<&'a [u8]> for BytesMut {\n                 inner.set_inline_len(len);\n                 inner.as_raw()[0..len].copy_from_slice(src);\n \n-                BytesMut {\n-                    inner: inner,\n-                }\n+                BytesMut { inner }\n             }\n         } else {\n             BytesMut::from(src.to_vec())\n@@ -1675,9 +1687,17 @@ impl<'a> From<&'a [u8]> for BytesMut {\n     }\n }\n \n-impl<'a> From<&'a str> for BytesMut {\n-    fn from(src: &'a str) -> BytesMut {\n-        BytesMut::from(src.as_bytes())\n+/// Copy\u2010from static byte\u2010slice (still results in owned, mutable buffer).\n+impl From<&'static [u8]> for BytesMut {\n+    fn from(src: &'static [u8]) -> BytesMut {\n+        BytesMut::copy_from(src)\n+    }\n+}\n+\n+/// Copy\u2010from static str.\n+impl From<&'static str> for BytesMut {\n+    fn from(src: &'static str) -> BytesMut {\n+        BytesMut::copy_from(src.as_bytes())\n     }\n }\n \n"}
{"instance_id": "rinja-rs__askama-374", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/askama_derive/src/lib.rs b/askama_derive/src/lib.rs\nindex 8844e99..d86fcc4 100644\n--- a/askama_derive/src/lib.rs\n+++ b/askama_derive/src/lib.rs\n@@ -13,7 +13,10 @@ use std::path::PathBuf;\n \n #[proc_macro_derive(Template, attributes(template))]\n pub fn derive_template(input: TokenStream) -> TokenStream {\n-    let ast: syn::DeriveInput = syn::parse(input).unwrap();\n+    let ast: syn::DeriveInput = match syn::parse(input) {\n+        Ok(ast) => ast,\n+        Err(err) => return err.to_compile_error().into(),\n+    };\n     match build_template(&ast) {\n         Ok(source) => source,\n         Err(e) => format!(\"compile_error!({:?})\", e),\n"}
{"instance_id": "tokio-rs__axum-3051", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/routing/mod.rs b/axum/src/routing/mod.rs\nindex d3ddf1fe..95666cef 100644\n--- a/axum/src/routing/mod.rs\n+++ b/axum/src/routing/mod.rs\n@@ -200,6 +200,9 @@ where\n     #[doc(alias = \"scope\")] // Some web frameworks like actix-web use this term\n     #[track_caller]\n     pub fn nest(self, path: &str, router: Router<S>) -> Self {\n+        if path == \"/\" {\n+            panic!(\"root nesting is not allowed; use merge or fallback_service instead of nest(\\\"/\\\", ...)\");\n+        }\n         let RouterInner {\n             path_router,\n             fallback_router,\n@@ -227,6 +230,9 @@ where\n         T::Response: IntoResponse,\n         T::Future: Send + 'static,\n     {\n+        if path == \"/\" {\n+            panic!(\"root nesting is not allowed; use merge or fallback_service instead of nest_service(\\\"/\\\", ...)\");\n+        }\n         tap_inner!(self, mut this => {\n             panic_on_err!(this.path_router.nest_service(path, service));\n         })\n"}
{"instance_id": "chronotope__chrono-1323", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/naive/datetime/mod.rs b/src/naive/datetime/mod.rs\nindex 950aa74..38e2b57 100644\n--- a/src/naive/datetime/mod.rs\n+++ b/src/naive/datetime/mod.rs\n@@ -478,10 +478,14 @@ impl NaiveDateTime {\n     #[inline]\n     #[must_use]\n     pub fn timestamp_nanos(&self) -> i64 {\n-        self.timestamp()\n-            .checked_mul(1_000_000_000)\n-            .and_then(|ns| ns.checked_add(i64::from(self.timestamp_subsec_nanos())))\n-            .expect(\"value can not be represented in a timestamp with nanosecond precision.\")\n+        // do the math in i128 so large negative seconds * 1e9\n+        // + subsec still fits, then only panic if truly outside i64\n+        let secs_i128 = self.timestamp() as i128;\n+        let nanos_i128 = secs_i128 * 1_000_000_000 + i128::from(self.timestamp_subsec_nanos());\n+        if nanos_i128 < i128::from(i64::MIN) || nanos_i128 > i128::from(i64::MAX) {\n+            panic!(\"value can not be represented in a timestamp with nanosecond precision.\");\n+        }\n+        nanos_i128 as i64\n     }\n \n     /// Returns the number of milliseconds since the last whole non-leap second.\n"}
{"instance_id": "axodotdev__cargo-dist-275", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/cargo-dist/src/init.rs b/cargo-dist/src/init.rs\nindex c38b770b..a21d46bd 100644\n--- a/cargo-dist/src/init.rs\n+++ b/cargo-dist/src/init.rs\n@@ -466,7 +466,28 @@ fn get_new_dist_metadata(\n }\n \n fn update_toml_metadata(workspace_toml: &mut toml_edit::Document, meta: &DistMetadata) {\n+    use std::fs;\n+    use std::path::{Path, PathBuf};\n     use toml_edit::{value, Item};\n+    \n+    // Return true if a rust-toolchain.toml with a [toolchain].channel exists in or above `dir`.\n+    fn has_toolchain_channel(dir: &Path) -> bool {\n+        let mut cur = Some(dir);\n+        while let Some(path) = cur {\n+            let candidate = path.join(\"rust-toolchain.toml\");\n+            if let Ok(contents) = fs::read_to_string(&candidate) {\n+                if let Ok(doc) = contents.parse::<toml::Value>() {\n+                    if doc.get(\"toolchain\")\n+                          .and_then(|t| t.get(\"channel\"))\n+                          .is_some() {\n+                        return true;\n+                    }\n+                }\n+            }\n+            cur = path.parent();\n+        }\n+        false\n+    }\n \n     // Keys/descriptions\n     const KEY_RUST_VERSION: &str = \"rust-toolchain-version\";\n"}
{"instance_id": "dtolnay__async-trait-223", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 8ca5032..6bf6204 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -238,9 +238,10 @@\n //! The one wrinkle is in traits that provide default implementations of async\n //! methods. In order for the default implementation to produce a future that is\n //! Send, the async_trait macro must emit a bound of `Self: Sync` on trait\n-//! methods that take `&self` and a bound `Self: Send` on trait methods that\n-//! take `&mut self`. An example of the former is visible in the expanded code\n-//! in the explanation section above.\n+//! methods that take `&self`, a bound `Self: Send` on trait methods that take\n+//! `&mut self`, and both `Self: Sync + Send` on methods taking `self: Arc<Self>`.\n+//! An example of the former is visible in the expanded code in the explanation\n+//! section above.\n //!\n //! If you make a trait with async methods that have default implementations,\n //! everything will work except that the trait cannot be used as a trait object.\n"}
{"instance_id": "boa-dev__boa-444", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/object/mod.rs b/boa/src/builtins/object/mod.rs\nindex 912d1520..64eadef9 100644\n--- a/boa/src/builtins/object/mod.rs\n+++ b/boa/src/builtins/object/mod.rs\n@@ -608,7 +608,7 @@ pub fn has_own_property(this: &mut Value, args: &[Value], _: &mut Interpreter) -\n     Ok(Value::from(\n         prop.is_some()\n             && this\n-                .get_property(&prop.expect(\"Cannot get object\"))\n+                .get_own_property(&prop.expect(\"Cannot get object\"))\n                 .is_some(),\n     ))\n }\n"}
{"instance_id": "rust-lang__chalk-282", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/chalk-solve/src/infer/unify.rs b/chalk-solve/src/infer/unify.rs\nindex d2dc4f0d..00c26272 100644\n--- a/chalk-solve/src/infer/unify.rs\n+++ b/chalk-solve/src/infer/unify.rs\n@@ -396,11 +396,23 @@ impl<'t> Zipper<ChalkIr> for Unifier<'t> {\n         self.unify_lifetime_lifetime(a, b)\n     }\n \n-    fn zip_binders<T>(&mut self, _: &Binders<T>, _: &Binders<T>) -> Fallible<()>\n+    fn zip_binders<T>(&mut self, a: &Binders<T>, b: &Binders<T>) -> Fallible<()>\n     where\n         T: Zip<ChalkIr> + Fold<ChalkIr, Result = T>,\n     {\n-        panic!(\"cannot unify things with binders (other than types)\")\n+        // Two\u2010way instantiation under binders:\n+        //\n+        // 1) Instantiate `a` with fresh existentials\n+        let (a_vars, a_body) = self.instantiate_binders_with_fresh_vars(a)?;\n+        // 2) Instantiate `b` with fresh existentials\n+        let (b_vars, b_body) = self.instantiate_binders_with_fresh_vars(b)?;\n+        // 3) Unify each corresponding bound variable\n+        for (a_var, b_var) in a_vars.iter().zip(&b_vars) {\n+            self.unify_lifetime_lifetime(a_var, b_var)?;\n+        }\n+        // 4) Zip the inner bodies under the same unifier\n+        a_body.zip_with(self, &b_body)?;\n+        Ok(())\n     }\n }\n \n"}
{"instance_id": "bevyengine__bevy-15405", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_scene/src/dynamic_scene.rs b/crates/bevy_scene/src/dynamic_scene.rs\nindex 7f094ce01..b416efb42 100644\n--- a/crates/bevy_scene/src/dynamic_scene.rs\n+++ b/crates/bevy_scene/src/dynamic_scene.rs\n@@ -122,6 +122,9 @@ impl DynamicScene {\n                     &type_registry,\n                 );\n             }\n+            // After running any on_add hooks (which may enqueue commands),\n+            // flush the world so that subsequent spawn_empty() calls are legal.\n+            world.flush();\n         }\n \n         // Updates references to entities in the scene to entities in the world\n"}
{"instance_id": "bevyengine__bevy-763", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ecs/hecs/src/query.rs b/crates/bevy_ecs/hecs/src/query.rs\nindex 5486c1d23..dae8d3de0 100644\n--- a/crates/bevy_ecs/hecs/src/query.rs\n+++ b/crates/bevy_ecs/hecs/src/query.rs\n@@ -299,6 +299,9 @@ pub struct Or<T>(PhantomData<T>);\n #[doc(hidden)]\n pub struct FetchOr<T>(T);\n \n+// Allow Or<\u2026> to be used in read-only queries when all inner fetches are read-only\n+unsafe impl<T: ReadOnlyFetch> ReadOnlyFetch for FetchOr<T> {}\n+\n /// Query transformer that retrieves components of type `T` that have been mutated since the start of the frame.\n /// Added components do not count as mutated.\n pub struct Mutated<'a, T> {\n"}
{"instance_id": "boa-dev__boa-468", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/bigint/mod.rs b/boa/src/builtins/bigint/mod.rs\nindex 5b385833..0eba3b22 100644\n--- a/boa/src/builtins/bigint/mod.rs\n+++ b/boa/src/builtins/bigint/mod.rs\n@@ -29,6 +29,54 @@ mod tests;\n #[derive(Debug, Clone, Copy)]\n pub(crate) struct BigInt;\n \n+impl BigInt {\n+    /// BigInt.asIntN(bits, bigint)\n+    pub(crate) fn as_int_n(\n+        this: &Value,\n+        args: &[Value],\n+        context: &mut Context,\n+    ) -> Result<Value, Value> {\n+        let bits = args.get(0).unwrap_or(&Value::undefined());\n+        let x = args.get(1).unwrap_or(&Value::undefined());\n+        // 1. Let bitsIndex = ToIndex(bits).\n+        let bits_index = bits.to_index(context)?;    \n+        // 2. Let bigint = ToBigInt(x).\n+        let bigint = x.to_bigint(context)?;\n+        // 3. Let modulus = 2^bitsIndex.\n+        let modulus = biginteger::BigInt::from(1u8) << bits_index;\n+        // 4. Let intN = bigint mod modulus.\n+        let mut int_n = bigint.mod_floor(&modulus);\n+        // 5. Let half = modulus >> 1 (2^(bitsIndex - 1)).\n+        let half = &modulus >> 1;\n+        // 6. If intN \u2265 half, let intN = intN \u2212 modulus.\n+        if int_n >= half {\n+            int_n -= &modulus;\n+        }\n+        // 7. Return ! BigInt(intN).\n+        Ok(Value::new_bigint(int_n))\n+    }\n+\n+    /// BigInt.asUintN(bits, bigint)\n+    pub(crate) fn as_uint_n(\n+        this: &Value,\n+        args: &[Value],\n+        context: &mut Context,\n+    ) -> Result<Value, Value> {\n+        let bits = args.get(0).unwrap_or(&Value::undefined());\n+        let x = args.get(1).unwrap_or(&Value::undefined());\n+        // 1. Let bitsIndex = ToIndex(bits).\n+        let bits_index = bits.to_index(context)?;\n+        // 2. Let bigint = ToBigInt(x).\n+        let bigint = x.to_bigint(context)?;\n+        // 3. Let modulus = 2^bitsIndex.\n+        let modulus = biginteger::BigInt::from(1u8) << bits_index;\n+        // 4. Let uintN = bigint mod modulus (always non-negative).\n+        let uint_n = bigint.mod_floor(&modulus);\n+        // 5. Return ! BigInt(uintN).\n+        Ok(Value::new_bigint(uint_n))\n+    }\n+}\n+\n impl BigInt {\n     /// `BigInt()`\n     ///\n"}
{"instance_id": "bevyengine__bevy-12469", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ecs/src/entity/mod.rs b/crates/bevy_ecs/src/entity/mod.rs\nindex 3f397cf3d..a68a0d1b4 100644\n--- a/crates/bevy_ecs/src/entity/mod.rs\n+++ b/crates/bevy_ecs/src/entity/mod.rs\n@@ -357,7 +357,9 @@ impl Serialize for Entity {\n     where\n         S: serde::Serializer,\n     {\n-        serializer.serialize_u64(self.to_bits())\n+        // Emit human-readable form matching Debug: \"<index>v<generation>\"\n+        let s = format!(\"{}v{}\", self.index(), self.generation());\n+        serializer.serialize_str(&s)\n     }\n }\n \n"}
{"instance_id": "bevyengine__bevy-16499", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ecs/src/bundle.rs b/crates/bevy_ecs/src/bundle.rs\nindex 3da2339c0..d6cb59280 100644\n--- a/crates/bevy_ecs/src/bundle.rs\n+++ b/crates/bevy_ecs/src/bundle.rs\n@@ -902,7 +902,7 @@ impl<'w> BundleInserter<'w> {\n             let mut deferred_world = self.world.into_deferred();\n \n             if insert_mode == InsertMode::Replace {\n-                deferred_world.trigger_on_replace(archetype, entity, add_bundle.iter_existing());\n+                // Run observers first, then the on_replace hook\n                 if archetype.has_replace_observer() {\n                     deferred_world.trigger_observers(\n                         ON_REPLACE,\n@@ -910,6 +910,7 @@ impl<'w> BundleInserter<'w> {\n                         add_bundle.iter_existing(),\n                     );\n                 }\n+                deferred_world.trigger_on_replace(archetype, entity, add_bundle.iter_existing());\n             }\n         }\n \n"}
{"instance_id": "axodotdev__cargo-dist-1024", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/cargo-dist/src/host.rs b/cargo-dist/src/host.rs\nindex a71a0184..f19d4cff 100644\n--- a/cargo-dist/src/host.rs\n+++ b/cargo-dist/src/host.rs\n@@ -146,15 +146,16 @@ impl<'a> DistGraphBuilder<'a> {\n                 }\n                 HostingStyle::Github => {\n                     // CI currently impls this for us, all we need to know is the URL to download from\n-                    let repo_url = &hosting.repo_url;\n+                    // Strip any trailing \u201c.git\u201d so downloads go to \u201c/releases/...\u201d, not \u201c.git/releases/...\u201d\n+                    let repo_url = hosting.repo_url.trim_end_matches(\".git\");\n                     for (name, version) in &releases_without_hosting {\n                         let tag = &announcing.tag;\n                         self.manifest\n                             .ensure_release(name.clone(), version.clone())\n                             .hosting\n                             .github = Some(cargo_dist_schema::GithubHosting {\n-                            artifact_download_url: format!(\"{repo_url}/releases/download/{tag}\"),\n-                        })\n+                                artifact_download_url: format!(\"{repo_url}/releases/download/{tag}\"),\n+                            })\n                     }\n                 }\n             }\n"}
{"instance_id": "cargo-generate__cargo-generate-372", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/git.rs b/src/git.rs\nindex 9983eb0..ff22a80 100644\n--- a/src/git.rs\n+++ b/src/git.rs\n@@ -18,7 +18,25 @@ pub(crate) struct GitConfig {\n impl GitConfig {\n     /// Creates a new `GitConfig` by parsing `git` as a URL or a local path.\n     pub fn new(git: &str, branch: Option<String>) -> Result<Self> {\n-        let remote = match Url::parse(git) {\n+        // Support SCP\u2010style SSH URLs (e.g. git@host:owner/repo.git)\n+        let git_ref = if !git.contains(\"://\") {\n+            if let Some(at_pos) = git.find('@') {\n+                if let Some(colon_pos) = git[at_pos..].find(':') {\n+                    // split \"user@host:path\" into left=\"user@host\", right=\"path\"\n+                    let left = &git[..(at_pos + colon_pos)];\n+                    let right = &git[(at_pos + colon_pos + 1)..];\n+                    format!(\"ssh://{}/{}\", left, right)\n+                } else {\n+                    git.to_string()\n+                }\n+            } else {\n+                git.to_string()\n+            }\n+        } else {\n+            git.to_string()\n+        };\n+\n+        let remote = match Url::parse(&git_ref) {\n             Ok(u) => u,\n             Err(ParseError::RelativeUrlWithoutBase) => {\n                 let given_path = Path::new(git);\n"}
{"instance_id": "bevyengine__bevy-13691", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_reflect/src/map.rs b/crates/bevy_reflect/src/map.rs\nindex 5b182c68a..5ae4dfb52 100644\n--- a/crates/bevy_reflect/src/map.rs\n+++ b/crates/bevy_reflect/src/map.rs\n@@ -285,7 +285,10 @@ impl Map for DynamicMap {\n         key: Box<dyn Reflect>,\n         mut value: Box<dyn Reflect>,\n     ) -> Option<Box<dyn Reflect>> {\n-        match self.indices.entry(key.reflect_hash().expect(HASH_ERROR)) {\n+        let hash = key.reflect_hash().unwrap_or_else(|| {\n+            panic!(\"{}: type `{}`\", HASH_ERROR, key.type_name());\n+        });\n+        match self.indices.entry(hash) {\n             Entry::Occupied(entry) => {\n                 let (_old_key, old_value) = self.values.get_mut(*entry.get()).unwrap();\n                 std::mem::swap(old_value, &mut value);\n"}
{"instance_id": "boa-dev__boa-972", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/array/mod.rs b/boa/src/builtins/array/mod.rs\nindex f4bf412b..38866e3f 100644\n--- a/boa/src/builtins/array/mod.rs\n+++ b/boa/src/builtins/array/mod.rs\n@@ -58,7 +58,12 @@ impl BuiltIn for Array {\n         )\n         .name(Self::NAME)\n         .length(Self::LENGTH)\n-        .property(\"length\", 0, Attribute::all())\n+        // According to ECMAScript, built-in function `.length` must be non-enumerable.\n+        .property(\n+            \"length\",\n+            0,\n+            Attribute::WRITABLE | Attribute::NON_ENUMERABLE | Attribute::CONFIGURABLE,\n+        )\n         .property(\n             \"values\",\n             values_function.clone(),\n"}
{"instance_id": "ast-grep__ast-grep-1634", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/cli/src/print/json_print.rs b/crates/cli/src/print/json_print.rs\nindex b166f8df..94bf2ecd 100644\n--- a/crates/cli/src/print/json_print.rs\n+++ b/crates/cli/src/print/json_print.rs\n@@ -147,11 +147,13 @@ fn get_range(n: &Node<'_, SgLang>) -> Range {\n     byte_offset: n.range(),\n     start: Position {\n       line: start_pos.row(),\n-      column: start_pos.column(n),\n+      // switch to character-based offset\n+      column: start_pos.column(),\n     },\n     end: Position {\n       line: end_pos.row(),\n-      column: end_pos.column(n),\n+      // switch to character-based offset\n+      column: end_pos.column(),\n     },\n   }\n }\n"}
{"instance_id": "rinja-rs__askama-393", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/askama_shared/src/parser.rs b/askama_shared/src/parser.rs\nindex 8210ed0..086df70 100644\n--- a/askama_shared/src/parser.rs\n+++ b/askama_shared/src/parser.rs\n@@ -312,14 +312,11 @@ fn expr_var_call(i: &[u8]) -> IResult<&[u8], Expr> {\n }\n \n fn path(i: &[u8]) -> IResult<&[u8], Vec<&str>> {\n-    let root = opt(value(\"\", ws(tag(\"::\"))));\n-    let tail = separated_list1(ws(tag(\"::\")), identifier);\n-    let (i, (root, start, _, rest)) = tuple((root, identifier, ws(tag(\"::\")), tail))(i)?;\n-    let mut path = Vec::new();\n-    path.extend(root);\n-    path.push(start);\n-    path.extend(rest);\n-    Ok((i, path))\n+    // Allow an optional leading \"::\" but do not emit an empty segment.\n+    let sep = ws(tag(\"::\"));\n+    // Skip an initial \"::\" if present, then parse one or more identifiers separated by \"::\".\n+    let (i, (_, parts)) = tuple((opt(sep), separated_list1(sep, identifier)))(i)?;\n+    Ok((i, parts))\n }\n \n fn expr_path(i: &[u8]) -> IResult<&[u8], Expr> {\n@@ -333,9 +330,10 @@ fn expr_path_call(i: &[u8]) -> IResult<&[u8], Expr> {\n }\n \n fn variant_path(i: &[u8]) -> IResult<&[u8], MatchVariant> {\n-    map(separated_list1(ws(tag(\"::\")), identifier), |path| {\n-        MatchVariant::Path(path)\n-    })(i)\n+    // Allow an optional leading \"::\" in match variants without an empty segment.\n+    let sep = ws(tag(\"::\"));\n+    let (i, (_, parts)) = tuple((opt(sep), separated_list1(sep, identifier)))(i)?;\n+    Ok((i, MatchVariant::Path(parts)))\n }\n \n fn target_single(i: &[u8]) -> IResult<&[u8], Target> {\n"}
{"instance_id": "boa-dev__boa-156", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/js/array.rs b/src/lib/js/array.rs\nindex 07f252fe..466c8306 100644\n--- a/src/lib/js/array.rs\n+++ b/src/lib/js/array.rs\n@@ -431,7 +431,10 @@ pub fn create_constructor(global: &Value) -> Value {\n     array_prototype.set_field_slice(\"reverse\", to_value(reverse as NativeFunctionData));\n     array_prototype.set_field_slice(\"shift\", to_value(shift as NativeFunctionData));\n     array_prototype.set_field_slice(\"unshift\", to_value(unshift as NativeFunctionData));\n-    array_prototype.set_field_slice(\"find\", to_value(find as NativeFunctionData));\n+    // Install Array.prototype.find with a .length of 1\n+    let find_func = to_value(find as NativeFunctionData);\n+    find_func.set_field_slice(\"length\", to_value(1_i32));\n+    array_prototype.set_field_slice(\"find\", find_func);\n     array_prototype.set_field_slice(\"indexOf\", index_of_func);\n     array_prototype.set_field_slice(\"lastIndexOf\", last_index_of_func);\n \n"}
{"instance_id": "tracel-ai__burn-1682", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/burn-core/src/nn/linear.rs b/crates/burn-core/src/nn/linear.rs\nindex c90074b6..1f13fd78 100644\n--- a/crates/burn-core/src/nn/linear.rs\n+++ b/crates/burn-core/src/nn/linear.rs\n@@ -70,10 +70,7 @@ impl<B: Backend> Linear<B> {\n     /// - input: `[..., d_input]`\n     /// - output: `[..., d_output]`\n     pub fn forward<const D: usize>(&self, input: Tensor<B, D>) -> Tensor<B, D> {\n-        if D == 1 {\n-            // Insert and remove an extra batch dimension for the batch matmul to work.\n-            return Self::forward::<2>(self, input.unsqueeze()).flatten(0, 1);\n-        }\n+        // The generic implementation below now handles D>=1 (including D=1) correctly.\n \n         let output = input.matmul(self.weight.val().unsqueeze());\n \n"}
{"instance_id": "boa-dev__boa-799", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/syntax/ast/position.rs b/boa/src/syntax/ast/position.rs\nindex ca9fc8c4..c1858057 100644\n--- a/boa/src/syntax/ast/position.rs\n+++ b/boa/src/syntax/ast/position.rs\n@@ -64,13 +64,17 @@ pub struct Span {\n }\n \n impl Span {\n-    /// Creates a new `Span`.\n+    /// Creates a new `Span`. If the end is before the start (invalid input), we clamp\n+    /// to a zero-length span at `start` rather than panic.\n     #[inline]\n     #[track_caller]\n     pub fn new(start: Position, end: Position) -> Self {\n-        assert!(start <= end, \"a span cannot start after its end\");\n-\n-        Self { start, end }\n+        if start > end {\n+            // Avoid panic on malformed spans; collapse to empty span at `start`.\n+            Self { start, end: start }\n+        } else {\n+            Self { start, end }\n+        }\n     }\n \n     /// Gets the starting position of the span.\n"}
{"instance_id": "bevyengine__bevy-16910", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_math/src/curve/easing.rs b/crates/bevy_math/src/curve/easing.rs\nindex 0e5406fa7..39c676274 100644\n--- a/crates/bevy_math/src/curve/easing.rs\n+++ b/crates/bevy_math/src/curve/easing.rs\n@@ -326,15 +326,27 @@ mod easing_functions {\n \n     #[inline]\n     pub(crate) fn exponential_in(t: f32) -> f32 {\n-        ops::powf(2.0, 10.0 * t - 10.0)\n+        if t == 0.0 {\n+            0.0\n+        } else {\n+            ops::powf(2.0, 10.0 * t - 10.0)\n+        }\n     }\n     #[inline]\n     pub(crate) fn exponential_out(t: f32) -> f32 {\n-        1.0 - ops::powf(2.0, -10.0 * t)\n+        if t == 1.0 {\n+            1.0\n+        } else {\n+            1.0 - ops::powf(2.0, -10.0 * t)\n+        }\n     }\n     #[inline]\n     pub(crate) fn exponential_in_out(t: f32) -> f32 {\n-        if t < 0.5 {\n+        if t == 0.0 {\n+            0.0\n+        } else if t == 1.0 {\n+            1.0\n+        } else if t < 0.5 {\n             ops::powf(2.0, 20.0 * t - 10.0) / 2.0\n         } else {\n             (2.0 - ops::powf(2.0, -20.0 * t + 10.0)) / 2.0\n"}
{"instance_id": "tokio-rs__axum-530", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/body/mod.rs b/axum/src/body/mod.rs\nindex c96b6f36..568e9ddc 100644\n--- a/axum/src/body/mod.rs\n+++ b/axum/src/body/mod.rs\n@@ -21,8 +21,18 @@ pub use bytes::Bytes;\n /// necessary to unify multiple response bodies types into one.\n pub type BoxBody = http_body::combinators::UnsyncBoxBody<Bytes, Error>;\n \n-/// Convert a [`http_body::Body`] into a [`BoxBody`].\n+/// Deprecated: use `boxed` instead. Will be removed in 0.4.0.\n+#[deprecated(since = \"0.3.4\", note = \"renamed to `boxed`\")]\n pub fn box_body<B>(body: B) -> BoxBody\n+where\n+    B: http_body::Body<Data = Bytes> + Send + 'static,\n+    B::Error: Into<BoxError>,\n+{\n+    boxed(body)\n+}\n+\n+/// Convert a [`http_body::Body`] into a [`BoxBody`].\n+pub fn boxed<B>(body: B) -> BoxBody\n where\n     B: http_body::Body<Data = Bytes> + Send + 'static,\n     B::Error: Into<BoxError>,\n@@ -31,5 +41,5 @@ where\n }\n \n pub(crate) fn empty() -> BoxBody {\n-    box_body(http_body::Empty::new())\n+    boxed(http_body::Empty::new())\n }\n"}
{"instance_id": "bevyengine__bevy-10627", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_reflect/src/struct_trait.rs b/crates/bevy_reflect/src/struct_trait.rs\nindex 9ecf2784a..d5726f6c8 100644\n--- a/crates/bevy_reflect/src/struct_trait.rs\n+++ b/crates/bevy_reflect/src/struct_trait.rs\n@@ -277,6 +277,14 @@ pub struct DynamicStruct {\n     field_indices: HashMap<Cow<'static, str>, usize>,\n }\n \n+impl DynamicStruct {\n+    /// If this `DynamicStruct` was cloned from a concrete `Reflect` type,\n+    /// returns that original type\u2019s [`TypeInfo`].\n+    pub fn represented(&self) -> Option<&'static TypeInfo> {\n+        self.represented_type\n+    }\n+}\n+\n impl DynamicStruct {\n     /// Sets the [type] to be represented by this `DynamicStruct`.\n     ///\n"}
{"instance_id": "chronotope__chrono-999", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/month.rs b/src/month.rs\nindex 46f09d0..01f9895 100644\n--- a/src/month.rs\n+++ b/src/month.rs\n@@ -27,7 +27,7 @@ use rkyv::{Archive, Deserialize, Serialize};\n /// Allows mapping from and to month, from 1-January to 12-December.\n /// Can be Serialized/Deserialized with serde\n // Actual implementation is zero-indexed, API intended as 1-indexed for more intuitive behavior.\n-#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Copy, Clone, Debug, Hash)]\n #[cfg_attr(feature = \"rustc-serialize\", derive(RustcEncodable, RustcDecodable))]\n #[cfg_attr(feature = \"rkyv\", derive(Archive, Deserialize, Serialize))]\n #[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\n"}
{"instance_id": "biomejs__biome-1070", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_analyze/src/analyzers/style/use_single_var_declarator.rs b/crates/biome_js_analyze/src/analyzers/style/use_single_var_declarator.rs\nindex 92d3704c90..0b471ba665 100644\n--- a/crates/biome_js_analyze/src/analyzers/style/use_single_var_declarator.rs\n+++ b/crates/biome_js_analyze/src/analyzers/style/use_single_var_declarator.rs\n@@ -128,8 +128,22 @@ impl Rule for UseSingleVarDeclarator {\n             vec![(TriviaPieceKind::Newline, String::from(\"\\n\"))]\n         };\n \n+        // Build trailing\u2010trivia (newline + indentation) for each semicolon\n+        let semicolon_trivia: Vec<TriviaPiece> = kind_indent\n+            .iter()\n+            .map(|(kind, text)| TriviaPiece::new(*kind, TextSize::of(text)))\n+            .collect();\n+        \n         let last_semicolon_token = semicolon_token.as_ref();\n-        let remaining_semicolon_token = semicolon_token.clone().map(|_| make::token(T![;]));\n+        let remaining_semicolon_token = semicolon_token.clone().map(|_| {\n+            // Create a semicolon token with the newline/indent as trailing trivia\n+            JsSyntaxToken::new_detached(\n+                T![;],\n+                \";\",\n+                Vec::new(),                     // no leading trivia\n+                semicolon_trivia.clone().into_iter(), // trailing trivia pieces\n+            )\n+        });\n \n         let declarators_len = declarators.len();\n \n"}
{"instance_id": "starkware-libs__cairo-3264", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/cairo-lang-lowering/src/implicits/mod.rs b/crates/cairo-lang-lowering/src/implicits/mod.rs\nindex 2512d3b32..8fbde43e3 100644\n--- a/crates/cairo-lang-lowering/src/implicits/mod.rs\n+++ b/crates/cairo-lang-lowering/src/implicits/mod.rs\n@@ -145,11 +145,19 @@ fn lower_block_implicits(ctx: &mut Context<'_>, block_id: BlockId) -> Maybe<()>\n         FlatBlockEnd::Match { info } => match info {\n             MatchInfo::Enum(stmt) => {\n                 for MatchArm { variant_id: _, block_id, var_ids: _ } in &stmt.arms {\n-                    assert!(\n-                        ctx.implicit_vars_for_block.insert(*block_id, implicits.clone()).is_none(),\n-                        \"Multiple jumps to arm blocks are not allowed.\"\n-                    );\n-                    blocks_to_visit.push(*block_id);\n+                    if let Some(prev_implicits) = ctx.implicit_vars_for_block.get(block_id) {\n+                        // Allow multiple incoming jumps as long as the implicits agree.\n+                        assert_eq!(\n+                            prev_implicits,\n+                            &implicits,\n+                            \"Mismatched implicits for multiple jumps to the same arm block\"\n+                        );\n+                    } else {\n+                        // First time we see this arm: record and enqueue it.\n+                        ctx.implicit_vars_for_block\n+                            .insert(*block_id, implicits.clone());\n+                        blocks_to_visit.push(*block_id);\n+                    }\n                 }\n             }\n             MatchInfo::Extern(stmt) => {\n"}
{"instance_id": "boa-dev__boa-1518", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/context.rs b/boa/src/context.rs\nindex f2549594..c7da7d06 100644\n--- a/boa/src/context.rs\n+++ b/boa/src/context.rs\n@@ -635,7 +635,7 @@ impl Context {\n     #[inline]\n     pub fn register_global_closure<F>(&mut self, name: &str, length: usize, body: F) -> JsResult<()>\n     where\n-        F: Fn(&JsValue, &[JsValue], &mut Context) -> JsResult<JsValue> + 'static,\n+        F: Fn(&JsValue, &[JsValue], &mut Context) -> JsResult<JsValue> + Copy + 'static,\n     {\n         let function = FunctionBuilder::closure(self, body)\n             .name(name)\ndiff --git a/boa/src/object/mod.rs b/boa/src/object/mod.rs\nindex c7760c5c..9dd7ecbb 100644\n--- a/boa/src/object/mod.rs\n+++ b/boa/src/object/mod.rs\n@@ -1108,7 +1108,7 @@ impl<'context> FunctionBuilder<'context> {\n     #[inline]\n     pub fn closure<F>(context: &'context mut Context, function: F) -> Self\n     where\n-        F: Fn(&JsValue, &[JsValue], &mut Context) -> Result<JsValue, JsValue> + 'static,\n+        F: Fn(&JsValue, &[JsValue], &mut Context) -> Result<JsValue, JsValue> + Copy + 'static,\n     {\n         Self {\n             context,\n"}
{"instance_id": "killercup__cargo-edit-342", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/dependency.rs b/src/dependency.rs\nindex 61d3390a..445d2659 100644\n--- a/src/dependency.rs\n+++ b/src/dependency.rs\n@@ -12,8 +12,10 @@ enum DependencySource {\n /// A dependency handled by Cargo\n #[derive(Debug, Hash, PartialEq, Eq, Clone)]\n pub struct Dependency {\n-    /// The name of the dependency (as it is set in its `Cargo.toml` and known to crates.io)\n+    /// The name of the dependency (as it is known to crates.io)\n     pub name: String,\n+    /// An optional alias used in Cargo.toml when `package = \"...\"` was set\n+    pub rename: Option<String>,\n     optional: bool,\n     default_features: bool,\n     source: DependencySource,\n@@ -23,6 +25,7 @@ impl Default for Dependency {\n     fn default() -> Dependency {\n         Dependency {\n             name: \"\".into(),\n+            rename: None,\n             optional: false,\n             default_features: true,\n             source: DependencySource::Version {\n@@ -38,6 +41,7 @@ impl Dependency {\n     pub fn new(name: &str) -> Dependency {\n         Dependency {\n             name: name.into(),\n+            rename: None,\n             ..Dependency::default()\n         }\n     }\n@@ -112,9 +116,12 @@ impl Dependency {\n     /// (If the dependency is set as `optional` or `default-features` is set to `false`,\n     /// an `InlineTable` is returned in any case.)\n     pub fn to_toml(&self) -> (String, toml_edit::Item) {\n+        // Determine the table key: if we were aliased, use the alias; otherwise use the crate name.\n+        let key = self.rename.as_ref().unwrap_or(&self.name).clone();\n+    \n         let data: toml_edit::Item =\n             match (self.optional, self.default_features, self.source.clone()) {\n-                // Extra short when version flag only\n+                // Extra short when version flag only, and no rename\n                 (\n                     false,\n                     true,\n@@ -122,11 +129,16 @@ impl Dependency {\n                         version: Some(v),\n                         path: None,\n                     },\n-                ) => toml_edit::value(v),\n+                ) if self.rename.is_none() => toml_edit::value(v),\n                 // Other cases are represented as an inline table\n                 (optional, default_features, source) => {\n                     let mut data = toml_edit::InlineTable::default();\n-\n+    \n+                    // If we have a rename, record the package override\n+                    if let Some(ref original_name) = self.rename {\n+                        data.get_or_insert(\"package\", original_name);\n+                    }\n+    \n                     match source {\n                         DependencySource::Version { version, path } => {\n                             if let Some(v) = version {\n@@ -146,12 +158,12 @@ impl Dependency {\n                     if !self.default_features {\n                         data.get_or_insert(\"default-features\", default_features);\n                     }\n-\n+    \n                     data.fmt();\n                     toml_edit::value(toml_edit::Value::InlineTable(data))\n                 }\n             };\n-\n-        (self.name.clone(), data)\n+    \n+        (key, data)\n     }\n }\n"}
{"instance_id": "bevyengine__bevy-8467", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_time/src/timer.rs b/crates/bevy_time/src/timer.rs\nindex 369036eee..1aa8eb508 100644\n--- a/crates/bevy_time/src/timer.rs\n+++ b/crates/bevy_time/src/timer.rs\n@@ -224,10 +224,16 @@ impl Timer {\n \n         if self.finished() {\n             if self.mode == TimerMode::Repeating {\n-                self.times_finished_this_tick =\n-                    (self.elapsed().as_nanos() / self.duration().as_nanos()) as u32;\n-                // Duration does not have a modulo\n-                self.set_elapsed(self.elapsed() - self.duration() * self.times_finished_this_tick);\n+                // Guard against zero duration to avoid divide-by-zero\n+                if self.duration() == Duration::ZERO {\n+                    self.times_finished_this_tick = 1;\n+                    self.set_elapsed(Duration::ZERO);\n+                } else {\n+                    self.times_finished_this_tick =\n+                        (self.elapsed().as_nanos() / self.duration().as_nanos()) as u32;\n+                    // Duration does not have a modulo\n+                    self.set_elapsed(self.elapsed() - self.duration() * self.times_finished_this_tick);\n+                }\n             } else {\n                 self.times_finished_this_tick = 1;\n                 self.set_elapsed(self.duration());\n@@ -329,7 +335,13 @@ impl Timer {\n     /// ```\n     #[inline]\n     pub fn percent(&self) -> f32 {\n-        self.elapsed().as_secs_f32() / self.duration().as_secs_f32()\n+        let dur = self.duration().as_secs_f32();\n+        if dur == 0.0 {\n+            // Zero-duration timers are considered immediately complete\n+            1.0\n+        } else {\n+            self.elapsed().as_secs_f32() / dur\n+        }\n     }\n \n     /// Returns the percentage of the timer remaining time (goes from 1.0 to 0.0).\n"}
{"instance_id": "bevyengine__bevy-14539", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ecs/src/entity/mod.rs b/crates/bevy_ecs/src/entity/mod.rs\nindex 4250058ed..cedc15e93 100644\n--- a/crates/bevy_ecs/src/entity/mod.rs\n+++ b/crates/bevy_ecs/src/entity/mod.rs\n@@ -374,7 +374,9 @@ impl Serialize for Entity {\n     where\n         S: serde::Serializer,\n     {\n-        serializer.serialize_u64(self.to_bits())\n+        // Emit the same \"{}v{}\" string that `Debug` shows.\n+        let s = format!(\"{}v{}\", self.index(), self.generation());\n+        serializer.serialize_str(&s)\n     }\n }\n \n@@ -385,8 +387,29 @@ impl<'de> Deserialize<'de> for Entity {\n         D: serde::Deserializer<'de>,\n     {\n         use serde::de::Error;\n-        let id: u64 = serde::de::Deserialize::deserialize(deserializer)?;\n-        Entity::try_from_bits(id).map_err(D::Error::custom)\n+    \n+        // Expect the same \"{}v{}\" string that `serialize` now emits.\n+        let s: String = serde::de::Deserialize::deserialize(deserializer)?;\n+        let mut parts = s.split('v');\n+        let index_str = parts\n+            .next()\n+            .ok_or_else(|| D::Error::custom(\"Invalid Entity format, missing index\"))?;\n+        let gen_str = parts\n+            .next()\n+            .ok_or_else(|| D::Error::custom(\"Invalid Entity format, missing generation\"))?;\n+        // Reject anything beyond \"indexvgen\"\n+        if parts.next().is_some() {\n+            return Err(D::Error::custom(\"Invalid Entity format, too many 'v' separators\"));\n+        }\n+        // Parse as numbers and reassemble into bits\n+        let index = index_str\n+            .parse::<u64>()\n+            .map_err(D::Error::custom)?;\n+        let generation = gen_str\n+            .parse::<u64>()\n+            .map_err(D::Error::custom)?;\n+        let bits = (generation << 32) | index;\n+        Entity::try_from_bits(bits).map_err(D::Error::custom)\n     }\n }\n \n"}
{"instance_id": "chronotope__chrono-991", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/naive/isoweek.rs b/src/naive/isoweek.rs\nindex 6a4fcfd..a93e66b 100644\n--- a/src/naive/isoweek.rs\n+++ b/src/naive/isoweek.rs\n@@ -16,7 +16,7 @@ use rkyv::{Archive, Deserialize, Serialize};\n /// constitutes the ISO 8601 [week date](./struct.NaiveDate.html#week-date).\n /// One can retrieve this type from the existing [`Datelike`](../trait.Datelike.html) types\n /// via the [`Datelike::iso_week`](../trait.Datelike.html#tymethod.iso_week) method.\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Copy, Clone, Hash)]\n+#[derive(Copy, Clone)]\n #[cfg_attr(feature = \"rkyv\", derive(Archive, Deserialize, Serialize))]\n pub struct IsoWeek {\n     // note that this allows for larger year range than `NaiveDate`.\n@@ -25,6 +25,41 @@ pub struct IsoWeek {\n     ywf: DateImpl, // (year << 10) | (week << 4) | flag\n }\n \n+use std::cmp::Ordering;\n+use std::hash::{Hash, Hasher};\n+\n+impl PartialEq for IsoWeek {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.year() == other.year() && self.week() == other.week()\n+    }\n+}\n+\n+impl Eq for IsoWeek {}\n+\n+impl PartialOrd for IsoWeek {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for IsoWeek {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        // compare by ISO\u2010year, then by week number\n+        match self.year().cmp(&other.year()) {\n+            Ordering::Equal => self.week().cmp(&other.week()),\n+            non_eq => non_eq,\n+        }\n+    }\n+}\n+\n+impl Hash for IsoWeek {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        // only hash the logical (year, week)\n+        self.year().hash(state);\n+        self.week().hash(state);\n+    }\n+}\n+\n /// Returns the corresponding `IsoWeek` from the year and the `Of` internal value.\n //\n // internal use only. we don't expose the public constructor for `IsoWeek` for now,\n"}
{"instance_id": "rinja-rs__askama-652", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/askama_shared/src/filters/mod.rs b/askama_shared/src/filters/mod.rs\nindex 9fb10d2..627e3a7 100644\n--- a/askama_shared/src/filters/mod.rs\n+++ b/askama_shared/src/filters/mod.rs\n@@ -330,20 +330,24 @@ where\n \n /// Capitalize a value. The first character will be uppercase, all others lowercase.\n pub fn capitalize<T: fmt::Display>(s: T) -> Result<String> {\n-    let mut s = s.to_string();\n-\n-    match s.get_mut(0..1).map(|s| {\n-        s.make_ascii_uppercase();\n-        &*s\n-    }) {\n-        None => Ok(s),\n-        _ => {\n-            s.get_mut(1..).map(|s| {\n-                s.make_ascii_lowercase();\n-                &*s\n-            });\n-            Ok(s)\n+    let s = s.to_string();\n+    let mut chars = s.chars();\n+    if let Some(first) = chars.next() {\n+        // Uppercase the first Unicode scalar\n+        let mut result = String::new();\n+        for up in first.to_uppercase() {\n+            result.push(up);\n         }\n+        // Lowercase the remainder properly\n+        for c in chars {\n+            for lc in c.to_lowercase() {\n+                result.push(lc);\n+            }\n+        }\n+        Ok(result)\n+    } else {\n+        // Empty string, nothing to do\n+        Ok(s)\n     }\n }\n \n"}
{"instance_id": "bevyengine__bevy-12399", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_color/src/color_ops.rs b/crates/bevy_color/src/color_ops.rs\nindex d06e33701..cbf33d8dc 100644\n--- a/crates/bevy_color/src/color_ops.rs\n+++ b/crates/bevy_color/src/color_ops.rs\n@@ -62,6 +62,18 @@ pub trait Alpha: Sized {\n     }\n }\n \n+/// Methods for rotating hue values.\n+pub trait HueRotate: Sized {\n+    /// Return a new version of this color with the hue rotated by `degrees`.\n+    fn rotate_hue(&self, degrees: f32) -> Self;\n+\n+    /// Return the hue component of this color (in [0.0, 360.0]).\n+    fn hue(&self) -> f32;\n+\n+    /// Set the hue component of this color (wrapping into [0.0, 360.0)).\n+    fn set_hue(&mut self, degrees: f32);\n+}\n+\n /// Trait with methods for asserting a colorspace is within bounds.\n ///\n /// During ordinary usage (e.g. reading images from disk, rendering images, picking colors for UI), colors should always be within their ordinary bounds (such as 0 to 1 for RGB colors).\ndiff --git a/crates/bevy_color/src/hsla.rs b/crates/bevy_color/src/hsla.rs\nindex b908afd03..7ad685dc3 100644\n--- a/crates/bevy_color/src/hsla.rs\n+++ b/crates/bevy_color/src/hsla.rs\n@@ -23,6 +23,30 @@ pub struct Hsla {\n     pub alpha: f32,\n }\n \n+use crate::color_ops::HueRotate;\n+\n+impl HueRotate for Hsla {\n+    fn rotate_hue(&self, degrees: f32) -> Self {\n+        let mut h = self.hue + degrees;\n+        // wrap into [0.0, 360.0)\n+        h = h.rem_euclid(360.0);\n+        Hsla {\n+            hue: h,\n+            saturation: self.saturation,\n+            lightness: self.lightness,\n+            alpha: self.alpha,\n+        }\n+    }\n+\n+    fn hue(&self) -> f32 {\n+        self.hue\n+    }\n+\n+    fn set_hue(&mut self, degrees: f32) {\n+        self.hue = degrees.rem_euclid(360.0);\n+    }\n+}\n+\n impl StandardColor for Hsla {}\n \n impl Hsla {\ndiff --git a/crates/bevy_color/src/hsva.rs b/crates/bevy_color/src/hsva.rs\nindex 8f45a476d..863f5f75e 100644\n--- a/crates/bevy_color/src/hsva.rs\n+++ b/crates/bevy_color/src/hsva.rs\n@@ -21,6 +21,30 @@ pub struct Hsva {\n     pub alpha: f32,\n }\n \n+use crate::color_ops::HueRotate;\n+\n+impl HueRotate for Hsva {\n+    fn rotate_hue(&self, degrees: f32) -> Self {\n+        let mut h = self.hue + degrees;\n+        // wrap into [0.0, 360.0)\n+        h = h.rem_euclid(360.0);\n+        Hsva {\n+            hue: h,\n+            saturation: self.saturation,\n+            value: self.value,\n+            alpha: self.alpha,\n+        }\n+    }\n+\n+    fn hue(&self) -> f32 {\n+        self.hue\n+    }\n+\n+    fn set_hue(&mut self, degrees: f32) {\n+        self.hue = degrees.rem_euclid(360.0);\n+    }\n+}\n+\n impl StandardColor for Hsva {}\n \n impl Hsva {\n"}
{"instance_id": "killercup__cargo-edit-527", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bin/set-version/main.rs b/src/bin/set-version/main.rs\nindex d97bb0f8..8d9d6e66 100644\n--- a/src/bin/set-version/main.rs\n+++ b/src/bin/set-version/main.rs\n@@ -209,7 +209,7 @@ impl Manifests {\n }\n \n fn dry_run_message() -> Result<()> {\n-    let bufwtr = BufferWriter::stdout(ColorChoice::Always);\n+    let bufwtr = BufferWriter::stderr(ColorChoice::Always);\n     let mut buffer = bufwtr.buffer();\n     buffer\n         .set_color(ColorSpec::new().set_fg(Some(Color::Cyan)).set_bold(true))\n@@ -241,7 +241,7 @@ fn deprecated_message(message: &str) -> Result<()> {\n }\n \n fn upgrade_message(name: &str, from: &semver::Version, to: &semver::Version) -> Result<()> {\n-    let bufwtr = BufferWriter::stdout(ColorChoice::Always);\n+    let bufwtr = BufferWriter::stderr(ColorChoice::Always);\n     let mut buffer = bufwtr.buffer();\n     buffer\n         .set_color(ColorSpec::new().set_fg(Some(Color::Green)).set_bold(true))\n@@ -258,7 +258,7 @@ fn upgrade_message(name: &str, from: &semver::Version, to: &semver::Version) ->\n }\n \n fn upgrade_dependent_message(name: &str, old_req: &str, new_req: &str) -> Result<()> {\n-    let bufwtr = BufferWriter::stdout(ColorChoice::Always);\n+    let bufwtr = BufferWriter::stderr(ColorChoice::Always);\n     let mut buffer = bufwtr.buffer();\n     buffer\n         .set_color(ColorSpec::new().set_fg(Some(Color::Green)).set_bold(true))\ndiff --git a/src/bin/upgrade/main.rs b/src/bin/upgrade/main.rs\nindex 2ce4484a..824e782d 100644\n--- a/src/bin/upgrade/main.rs\n+++ b/src/bin/upgrade/main.rs\n@@ -151,7 +151,7 @@ fn deprecated_message(message: &str) -> Result<()> {\n }\n \n fn dry_run_message() -> Result<()> {\n-    let bufwtr = BufferWriter::stdout(ColorChoice::Always);\n+    let bufwtr = BufferWriter::stderr(ColorChoice::Always);\n     let mut buffer = bufwtr.buffer();\n     buffer\n         .set_color(ColorSpec::new().set_fg(Some(Color::Cyan)).set_bold(true))\n"}
{"instance_id": "bevyengine__bevy-15546", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_asset/src/server/mod.rs b/crates/bevy_asset/src/server/mod.rs\nindex a527a7bd2..2676d7183 100644\n--- a/crates/bevy_asset/src/server/mod.rs\n+++ b/crates/bevy_asset/src/server/mod.rs\n@@ -367,9 +367,9 @@ impl AssetServer {\n         self.load_with_meta_transform(path, Some(loader_settings_meta_transform(settings)), guard)\n     }\n \n-    pub(crate) fn load_with_meta_transform<'a, A: Asset, G: Send + Sync + 'static>(\n+    pub(crate) fn load_with_meta_transform<A: Asset, G: Send + Sync + 'static>(\n         &self,\n-        path: impl Into<AssetPath<'a>>,\n+        path: impl Into<AssetPath>,\n         meta_transform: Option<MetaTransform>,\n         guard: G,\n     ) -> Handle<A> {\n@@ -413,9 +413,9 @@ impl AssetServer {\n         self.load_internal(None, path, false, None).await\n     }\n \n-    pub(crate) fn load_untyped_with_meta_transform<'a>(\n+    pub(crate) fn load_untyped_with_meta_transform(\n         &self,\n-        path: impl Into<AssetPath<'a>>,\n+        path: impl Into<AssetPath>,\n         meta_transform: Option<MetaTransform>,\n     ) -> Handle<LoadedUntypedAsset> {\n         let path = path.into().into_owned();\n@@ -1131,15 +1131,15 @@ impl AssetServer {\n             .0\n     }\n \n-    pub(crate) async fn get_meta_loader_and_reader<'a>(\n-        &'a self,\n-        asset_path: &'a AssetPath<'_>,\n+    pub(crate) async fn get_meta_loader_and_reader(\n+        &self,\n+        asset_path: &AssetPath,\n         asset_type_id: Option<TypeId>,\n     ) -> Result<\n         (\n             Box<dyn AssetMetaDyn>,\n             Arc<dyn ErasedAssetLoader>,\n-            Box<dyn Reader + 'a>,\n+            Box<dyn Reader + '_>,\n         ),\n         AssetLoadError,\n     > {\n"}
{"instance_id": "bevyengine__bevy-488", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_render/src/camera/camera.rs b/crates/bevy_render/src/camera/camera.rs\nindex 973ce35f6..21ae139be 100644\n--- a/crates/bevy_render/src/camera/camera.rs\n+++ b/crates/bevy_render/src/camera/camera.rs\n@@ -69,11 +69,10 @@ pub fn camera_system<T: CameraProjection + Component>(\n \n     for (mut camera, mut camera_projection) in &mut query.iter() {\n         if let Some(window) = windows.get(camera.window) {\n-            if changed_window_ids.contains(&window.id) {\n-                camera_projection.update(window.width as usize, window.height as usize);\n-                camera.projection_matrix = camera_projection.get_projection_matrix();\n-                camera.depth_calculation = camera_projection.depth_calculation();\n-            }\n+            // Always update all cameras so newly spawned cameras get initialized\n+            camera_projection.update(window.width as usize, window.height as usize);\n+            camera.projection_matrix = camera_projection.get_projection_matrix();\n+            camera.depth_calculation = camera_projection.depth_calculation();\n         }\n     }\n }\n"}
{"instance_id": "async-graphql__async-graphql-562", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/examples b/examples\n--- a/examples\n+++ b/examples\n@@ -1 +1 @@\n-Subproject commit 45b58bf1ce53ad76275d3d29c011e37de00e3bb7\n+Subproject commit 45b58bf1ce53ad76275d3d29c011e37de00e3bb7-dirty\n"}
{"instance_id": "async-graphql__async-graphql-584", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/http/playground_source.rs b/src/http/playground_source.rs\nindex c1ea7c62..e7db0eae 100644\n--- a/src/http/playground_source.rs\n+++ b/src/http/playground_source.rs\n@@ -1,6 +1,7 @@\n use std::collections::HashMap;\n \n use serde::Serialize;\n+use serde_json::Value;\n \n /// Generate the page for GraphQL Playground\n ///\n@@ -597,7 +598,8 @@ impl<'a> GraphQLPlaygroundConfig<'a> {\n     }\n \n     /// Set Playground setting for per query.\n-    pub fn with_setting(mut self, name: &'a str, value: &'a str) -> Self {\n+    pub fn with_setting<V: Into<Value>>(mut self, name: &'a str, value: V) -> Self {\n+        let value = value.into();\n         if let Some(settings) = &mut self.settings {\n             settings.insert(name, value);\n         } else {\n"}
{"instance_id": "bevyengine__bevy-7931", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ecs/src/change_detection.rs b/crates/bevy_ecs/src/change_detection.rs\nindex 1bf6a22d1..0dabc4df9 100644\n--- a/crates/bevy_ecs/src/change_detection.rs\n+++ b/crates/bevy_ecs/src/change_detection.rs\n@@ -564,6 +564,24 @@ pub struct Mut<'a, T: ?Sized> {\n     pub(crate) ticks: TicksMut<'a>,\n }\n \n+impl<'a, T: ?Sized> Mut<'a, T> {\n+    /// Advanced API for testing: construct a `Mut<T>` from a raw `&mut T` plus a `Ticks` value.\n+    ///\n+    /// # Safety\n+    /// The caller must initialize the given `Ticks` appropriately (e.g. via\n+    /// `TicksMut::set_last_changed`) before calling this method to preserve\n+    /// change\u2010detection invariants.\n+    pub fn new(value: &'a mut T, mut ticks: Ticks<'a>) -> Self {\n+        let ticks_mut = TicksMut {\n+            added:    &mut ticks.added,\n+            changed:  &mut ticks.changed,\n+            last_run: ticks.last_run,\n+            this_run: ticks.this_run,\n+        };\n+        Mut { value, ticks: ticks_mut }\n+    }\n+}\n+\n impl<'a, T: ?Sized> Mut<'a, T> {\n     /// Creates a new change-detection enabled smart pointer.\n     /// In almost all cases you do not need to call this method manually,\n"}
{"instance_id": "boa-dev__boa-506", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/function/mod.rs b/boa/src/builtins/function/mod.rs\nindex 65668958..6b821a69 100644\n--- a/boa/src/builtins/function/mod.rs\n+++ b/boa/src/builtins/function/mod.rs\n@@ -204,9 +204,10 @@ impl Function {\n                             self.add_rest_param(param, i, args_list, interpreter, &local_env);\n                             break;\n                         }\n-\n-                        let value = args_list.get(i).expect(\"Could not get value\");\n-                        self.add_arguments_to_environment(param, value.clone(), &local_env);\n+                    \n+                        // If the argument is missing, bind it as undefined instead of panicking\n+                        let value = args_list.get(i).cloned().unwrap_or(Value::undefined());\n+                        self.add_arguments_to_environment(param, value, &local_env);\n                     }\n \n                     // Add arguments object\n"}
{"instance_id": "chronotope__chrono-711", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/naive/datetime/mod.rs b/src/naive/datetime/mod.rs\nindex ec0d842..59f5629 100644\n--- a/src/naive/datetime/mod.rs\n+++ b/src/naive/datetime/mod.rs\n@@ -882,6 +882,17 @@ impl NaiveDateTime {\n         self.format_with_items(StrftimeItems::new(fmt))\n     }\n \n+    /// Convert this naive local datetime to a timezone\u2010aware `DateTime<Tz>`.\n+    ///\n+    /// Shorthand for `tz.from_local_datetime(self)`.\n+    #[inline]\n+    pub fn to_datetime_local<Tz: TimeZone>(\n+        &self,\n+        tz: Tz,\n+    ) -> LocalResult<DateTime<Tz>> {\n+        tz.from_local_datetime(self)\n+    }\n+\n     /// Converts the `NaiveDateTime` into the timezone-aware `DateTime<Tz>`\n     /// with the provided timezone, if possible.\n     ///\n"}
{"instance_id": "bincode-org__bincode-475", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/de/mod.rs b/src/de/mod.rs\nindex ca12881..c31e31c 100644\n--- a/src/de/mod.rs\n+++ b/src/de/mod.rs\n@@ -38,6 +38,19 @@ pub trait BorrowDecode<'de>: Sized {\n     fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>;\n }\n \n+#[cfg(feature = \"serde\")]\n+impl<'de, T> BorrowDecode<'de> for T\n+where\n+    T: serde::de::Deserialize<'de>,\n+{\n+    /// Fallback implementation for owned-only types (i.e. no borrowed fields).\n+    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n+        // Delegate to Serde's owned Deserialize path\n+        let mut serde_decoder = crate::features::serde::de::SerdeDecoder { de: decoder };\n+        T::deserialize(&mut serde_decoder)\n+    }\n+}\n+\n impl<'de, T: Decode> BorrowDecode<'de> for T {\n     fn borrow_decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n         Decode::decode(decoder)\n"}
{"instance_id": "tokio-rs__axum-892", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/handler/mod.rs b/axum/src/handler/mod.rs\nindex f30fb775..0c922fe3 100644\n--- a/axum/src/handler/mod.rs\n+++ b/axum/src/handler/mod.rs\n@@ -250,12 +250,9 @@ pub trait Handler<T, B = Body>: Clone + Send + Sized + 'static {\n     ///\n     /// [`MakeService`]: tower::make::MakeService\n     /// [`Router::into_make_service_with_connect_info`]: crate::routing::Router::into_make_service_with_connect_info\n-    fn into_make_service_with_connect_info<C, Target>(\n+    fn into_make_service_with_connect_info<C>(\n         self,\n-    ) -> IntoMakeServiceWithConnectInfo<IntoService<Self, T, B>, C>\n-    where\n-        C: Connected<Target>,\n-    {\n+    ) -> IntoMakeServiceWithConnectInfo<IntoService<Self, T, B>, C> {\n         IntoMakeServiceWithConnectInfo::new(self.into_service())\n     }\n }\ndiff --git a/axum/src/routing/mod.rs b/axum/src/routing/mod.rs\nindex 8f38f0a1..648e1023 100644\n--- a/axum/src/routing/mod.rs\n+++ b/axum/src/routing/mod.rs\n@@ -405,12 +405,9 @@ where\n     }\n \n     #[doc = include_str!(\"../docs/routing/into_make_service_with_connect_info.md\")]\n-    pub fn into_make_service_with_connect_info<C, Target>(\n+    pub fn into_make_service_with_connect_info<C>(\n         self,\n-    ) -> IntoMakeServiceWithConnectInfo<Self, C>\n-    where\n-        C: Connected<Target>,\n-    {\n+    ) -> IntoMakeServiceWithConnectInfo<Self, C> {\n         IntoMakeServiceWithConnectInfo::new(self)\n     }\n \n"}
{"instance_id": "rust-fuzz__cargo-fuzz-344", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/project.rs b/src/project.rs\nindex fec00a3..3312605 100644\n--- a/src/project.rs\n+++ b/src/project.rs\n@@ -175,6 +175,13 @@ impl FuzzProject {\n \n         if !build.no_cfg_fuzzing {\n             rustflags.push_str(\" --cfg fuzzing\");\n+            // If the last arg is a file on disk, we are in \"reproduce crash\" mode;\n+            // add a separate cfg flag so users can use #[cfg(fuzz_repro)].\n+            if let Some(arg) = build.args.last() {\n+                if std::path::Path::new(arg).is_file() {\n+                    rustflags.push_str(\" --cfg fuzz_repro\");\n+                }\n+            }\n         }\n \n         if !build.strip_dead_code {\n"}
{"instance_id": "boa-dev__boa-173", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/environment/lexical_environment.rs b/src/lib/environment/lexical_environment.rs\nindex e8e5fcae..d416d979 100644\n--- a/src/lib/environment/lexical_environment.rs\n+++ b/src/lib/environment/lexical_environment.rs\n@@ -90,6 +90,34 @@ impl LexicalEnvironment {\n         self.environment_stack.pop_back();\n     }\n \n+    /// Walks the environment stack from innermost to outermost\n+    /// and returns the first function environment record found.\n+    /// This is where `var` declarations should land.\n+    fn get_function_environment(&self) -> Environment {\n+        for env in self.environment_stack.iter().rev() {\n+            if env.borrow().is_function_environment() {\n+                return env.clone();\n+            }\n+        }\n+        // Fallback to the global or first environment\n+        self.environment_stack\n+            .front()\n+            .expect(\"there is always at least one env\")\n+            .clone()\n+    }\n+\n+    /// Define a `var` binding at the nearest function environment.\n+    pub fn define_var(&mut self, name: &str, strict: bool) {\n+        let func_env = self.get_function_environment();\n+        // create the mutable binding and initialize to undefined\n+        func_env\n+            .borrow_mut()\n+            .create_mutable_binding(name.to_string(), strict);\n+        func_env\n+            .borrow_mut()\n+            .initialize_binding(name, crate::js::value::undefined());\n+    }\n+\n     pub fn get_global_object(&self) -> Option<Value> {\n         self.environment_stack\n             .get(0)\n"}
{"instance_id": "rust-lang__cc-rs-226", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 9af1793..8559863 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -10,7 +10,7 @@\n //!\n //! The purpose of this crate is to provide the utility functions necessary to\n //! compile C code into a static archive which is then linked into a Rust crate.\n-//! Configuration is available through the `Config` builder.\n+//! Configuration is available through the `Builder` builder.\n //!\n //! This crate will automatically detect situations such as cross compilation or\n //! other environment variables set by Cargo and will build code appropriately.\n@@ -19,7 +19,7 @@\n //! be passed to a C or C++ compiler. As such, assembly files with extensions\n //! `.s` (gcc/clang) and `.asm` (MSVC) can also be compiled.\n //!\n-//! [`Config`]: struct.Config.html\n+//! [`Builder`]: struct.Builder.html\n //!\n //! # Examples\n //!\n@@ -29,7 +29,7 @@\n //! extern crate gcc;\n //!\n //! fn main() {\n-//!     gcc::Config::new()\n+//!     gcc::Builder::new()\n //!                 .file(\"src/foo.c\")\n //!                 .define(\"FOO\", Some(\"bar\"))\n //!                 .include(\"src\")\n@@ -68,7 +68,7 @@ pub mod windows_registry;\n \n /// Extra configuration to pass to gcc.\n #[derive(Clone, Debug)]\n-pub struct Config {\n+pub struct Builder {\n     include_directories: Vec<PathBuf>,\n     definitions: Vec<(String, Option<String>)>,\n     objects: Vec<PathBuf>,\n@@ -93,6 +93,9 @@ pub struct Config {\n     check_file_created: bool,\n }\n \n+/// Alias for backwards compatibility.\n+pub type Config = Builder;\n+\n /// Configuration used to represent an invocation of a C compiler.\n ///\n /// This can be used to figure out what compiler is in use, what the arguments\n@@ -176,7 +179,7 @@ pub fn compile_library(output: &str, files: &[&str]) {\n     c.compile(output);\n }\n \n-impl Config {\n+impl Builder {\n     /// Construct a new instance of a blank set of configuration.\n     ///\n     /// This builder is finished with the [`compile`] function.\n@@ -1269,9 +1272,9 @@ impl Config {\n     }\n }\n \n-impl Default for Config {\n-    fn default() -> Config {\n-        Config::new()\n+impl Default for Builder {\n+    fn default() -> Builder {\n+        Builder::new()\n     }\n }\n \n"}
{"instance_id": "bincode-org__bincode-212", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/internal.rs b/src/internal.rs\nindex 8c100f2..cb14315 100644\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -31,16 +31,26 @@ pub enum ErrorKind {\n     /// If the error stems from the reader/writer that is being used\n     /// during (de)serialization, that error will be stored and returned here.\n     Io(io::Error),\n-    /// If the bytes in the reader are not decodable because of an invalid\n-    /// encoding, this error will be returned.  This error is only possible\n-    /// if a stream is corrupted.  A stream produced from `encode` or `encode_into`\n-    /// should **never** produce an InvalidEncoding error.\n-    InvalidEncoding {\n-        #[allow(missing_docs)]\n-        desc: &'static str,\n+    /// UTF-8 string decoding failed.\n+    InvalidUtf8 {\n         #[allow(missing_docs)]\n         detail: Option<String>\n     },\n+    /// Boolean decoding failed because the byte was not 0 or 1.\n+    InvalidBool {\n+        #[allow(missing_docs)]\n+        found: u8\n+    },\n+    /// Character decoding failed due to an invalid codepoint.\n+    InvalidChar {\n+        #[allow(missing_docs)]\n+        found: u32\n+    },\n+    /// Option tag decoding failed because the byte was not 0 or 1.\n+    InvalidOptionTag {\n+        #[allow(missing_docs)]\n+        found: u8\n+    },\n     /// Serde has a deserialize_any method that lets the format hint to the\n     /// object which route to take in deserializing.\n     DeserializeAnyNotSupported,\n"}
{"instance_id": "chronotope__chrono-1285", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/offset/mod.rs b/src/offset/mod.rs\nindex 419550e..19b491b 100644\n--- a/src/offset/mod.rs\n+++ b/src/offset/mod.rs\n@@ -432,6 +432,31 @@ pub trait TimeZone: Sized + Clone {\n         }\n         self.timestamp_opt(secs, nanos as u32).unwrap()\n     }\n+    \n+    /// Makes a new `DateTime` from the number of non-leap microseconds\n+    /// since January 1, 1970 0:00:00 UTC (aka \u201cUNIX timestamp\u201d).\n+    ///\n+    /// Panics on out-of-range number of microseconds;\n+    /// for a non-panicking version see [`timestamp_micros_opt()`].\n+    #[deprecated(since = \"0.4.23\", note = \"use `timestamp_micros_opt()` instead\")]\n+    fn timestamp_micros(&self, micros: i64) -> DateTime<Self> {\n+        self.timestamp_micros_opt(micros).unwrap()\n+    }\n+    \n+    /// Makes a new `DateTime` from the number of non-leap microseconds\n+    /// since January 1, 1970 0:00:00 UTC (aka \u201cUNIX timestamp\u201d).\n+    ///\n+    /// Returns `LocalResult::None` on out-of-range number of microseconds,\n+    /// otherwise always `LocalResult::Single`.\n+    fn timestamp_micros_opt(&self, micros: i64) -> LocalResult<DateTime<Self>> {\n+        let (mut secs, mut micros) = (micros / 1_000_000, micros % 1_000_000);\n+        if micros < 0 {\n+            secs -= 1;\n+            micros += 1_000_000;\n+        }\n+        // convert microseconds to nanoseconds\n+        self.timestamp_opt(secs, micros as u32 * 1_000)\n+    }\n \n     /// Parses a string with the specified format string and returns a\n     /// `DateTime` with the current offset.\n"}
{"instance_id": "boa-dev__boa-130", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/syntax/lexer.rs b/src/lib/syntax/lexer.rs\nindex 6967da48..087c0d38 100644\n--- a/src/lib/syntax/lexer.rs\n+++ b/src/lib/syntax/lexer.rs\n@@ -523,9 +523,28 @@ impl<'a> Lexer<'a> {\n                         return Err(LexerError::new(\"Expecting Token /,*,= or regex\"));\n                     }\n                 }\n-                '*' => op!(self, Punctuator::AssignMul, Punctuator::Mul, {\n-                    '*' => vop!(self, Punctuator::AssignPow, Punctuator::Pow)\n-                }),\n+                '*' => {\n+                    // Exponentiation (**) and exponentiation assignment (**=)\n+                    if self.next_is('*') {\n+                        // consume the second '*'\n+                        let _ = self.next()?;\n+                        if self.next_is('=') {\n+                            // consume '=' and emit exponentiation-assignment\n+                            let _ = self.next()?;\n+                            self.push_punc(Punctuator::AssignPow);\n+                        } else {\n+                            // emit exponentiation\n+                            self.push_punc(Punctuator::Pow);\n+                        }\n+                    }\n+                    // Otherwise, handle *= or simple *\n+                    else if self.next_is('=') {\n+                        let _ = self.next()?;\n+                        self.push_punc(Punctuator::AssignMul);\n+                    } else {\n+                        self.push_punc(Punctuator::Mul);\n+                    }\n+                },\n                 '+' => op!(self, Punctuator::AssignAdd, Punctuator::Add, {\n                     '+' => Punctuator::Inc\n                 }),\n"}
{"instance_id": "tokio-rs__bytes-450", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/buf/buf_impl.rs b/src/buf/buf_impl.rs\nindex 3c596f1..c8b0076 100644\n--- a/src/buf/buf_impl.rs\n+++ b/src/buf/buf_impl.rs\n@@ -115,19 +115,19 @@ pub trait Buf {\n     ///\n     /// let mut buf = &b\"hello world\"[..];\n     ///\n-    /// assert_eq!(buf.bytes(), &b\"hello world\"[..]);\n+    /// assert_eq!(buf.chunk(), &b\"hello world\"[..]);\n     ///\n     /// buf.advance(6);\n     ///\n-    /// assert_eq!(buf.bytes(), &b\"world\"[..]);\n+    /// assert_eq!(buf.chunk(), &b\"world\"[..]);\n     /// ```\n     ///\n     /// # Implementer notes\n     ///\n     /// This function should never panic. Once the end of the buffer is reached,\n-    /// i.e., `Buf::remaining` returns 0, calls to `bytes` should return an\n+    /// i.e., `Buf::remaining` returns 0, calls to `chunk` should return an\n     /// empty slice.\n-    fn bytes(&self) -> &[u8];\n+    fn chunk(&self) -> &[u8];\n \n     /// Fills `dst` with potentially multiple slices starting at `self`'s\n     /// current position.\n@@ -163,7 +163,7 @@ pub trait Buf {\n         }\n \n         if self.has_remaining() {\n-            dst[0] = IoSlice::new(self.bytes());\n+            dst[0] = IoSlice::new(self.chunk());\n             1\n         } else {\n             0\n@@ -253,7 +253,7 @@ pub trait Buf {\n             let cnt;\n \n             unsafe {\n-                let src = self.bytes();\n+                let src = self.chunk();\n                 cnt = cmp::min(src.len(), dst.len() - off);\n \n                 ptr::copy_nonoverlapping(src.as_ptr(), dst[off..].as_mut_ptr(), cnt);\n@@ -283,7 +283,7 @@ pub trait Buf {\n     /// This function panics if there is no more remaining data in `self`.\n     fn get_u8(&mut self) -> u8 {\n         assert!(self.remaining() >= 1);\n-        let ret = self.bytes()[0];\n+        let ret = self.chunk()[0];\n         self.advance(1);\n         ret\n     }\n@@ -306,7 +306,7 @@ pub trait Buf {\n     /// This function panics if there is no more remaining data in `self`.\n     fn get_i8(&mut self) -> i8 {\n         assert!(self.remaining() >= 1);\n-        let ret = self.bytes()[0] as i8;\n+        let ret = self.chunk()[0] as i8;\n         self.advance(1);\n         ret\n     }\ndiff --git a/src/buf/buf_mut.rs b/src/buf/buf_mut.rs\nindex fb3623d..4183609 100644\n--- a/src/buf/buf_mut.rs\n+++ b/src/buf/buf_mut.rs\n@@ -135,14 +135,14 @@ pub unsafe trait BufMut {\n     ///\n     /// unsafe {\n     ///     // MaybeUninit::as_mut_ptr\n-    ///     buf.bytes_mut()[0..].as_mut_ptr().write(b'h');\n-    ///     buf.bytes_mut()[1..].as_mut_ptr().write(b'e');\n+    ///     buf.chunk_mut()[0..].as_mut_ptr().write(b'h');\n+    ///     buf.chunk_mut()[1..].as_mut_ptr().write(b'e');\n     ///\n     ///     buf.advance_mut(2);\n     ///\n-    ///     buf.bytes_mut()[0..].as_mut_ptr().write(b'l');\n-    ///     buf.bytes_mut()[1..].as_mut_ptr().write(b'l');\n-    ///     buf.bytes_mut()[2..].as_mut_ptr().write(b'o');\n+    ///     buf.chunk_mut()[0..].as_mut_ptr().write(b'l');\n+    ///     buf.chunk_mut()[1..].as_mut_ptr().write(b'l');\n+    ///     buf.chunk_mut()[2..].as_mut_ptr().write(b'o');\n     ///\n     ///     buf.advance_mut(3);\n     /// }\n@@ -153,12 +153,12 @@ pub unsafe trait BufMut {\n     ///\n     /// # Implementer notes\n     ///\n-    /// This function should never panic. `bytes_mut` should return an empty\n+    /// This function should never panic. `chunk_mut` should return an empty\n     /// slice **if and only if** `remaining_mut` returns 0. In other words,\n-    /// `bytes_mut` returning an empty slice implies that `remaining_mut` will\n-    /// return 0 and `remaining_mut` returning 0 implies that `bytes_mut` will\n+    /// `chunk_mut` returning an empty slice implies that `remaining_mut` will\n+    /// return 0 and `remaining_mut` returning 0 implies that `chunk_mut` will\n     /// return an empty slice.\n-    fn bytes_mut(&mut self) -> &mut UninitSlice;\n+    fn chunk_mut(&mut self) -> &mut UninitSlice;\n \n     /// Transfer bytes into `self` from `src` and advance the cursor by the\n     /// number of bytes written.\n@@ -190,8 +190,8 @@ pub unsafe trait BufMut {\n             let l;\n \n             unsafe {\n-                let s = src.bytes();\n-                let d = self.bytes_mut();\n+                let s = src.chunk();\n+                let d = self.chunk_mut();\n                 l = cmp::min(s.len(), d.len());\n \n                 ptr::copy_nonoverlapping(s.as_ptr(), d.as_mut_ptr() as *mut u8, l);\n@@ -237,7 +237,7 @@ pub unsafe trait BufMut {\n             let cnt;\n \n             unsafe {\n-                let dst = self.bytes_mut();\n+                let dst = self.chunk_mut();\n                 cnt = cmp::min(dst.len(), src.len() - off);\n \n                 ptr::copy_nonoverlapping(src[off..].as_ptr(), dst.as_mut_ptr() as *mut u8, cnt);\n"}
{"instance_id": "boa-dev__boa-157", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/js/array.rs b/src/lib/js/array.rs\nindex cd1e6a8d..daae4d64 100644\n--- a/src/lib/js/array.rs\n+++ b/src/lib/js/array.rs\n@@ -435,6 +435,39 @@ pub fn find(this: &Value, args: &[Value], interpreter: &mut Interpreter) -> Resu\n     Ok(Gc::new(ValueData::Undefined))\n }\n \n+/// Array.prototype.every ( callback, [thisArg] )\n+///\n+/// The every method executes the callback once for each element until\n+/// the callback returns a falsy value. If so, every immediately returns false;\n+/// otherwise, true is returned.\n+/// <https://tc39.es/ecma262/#sec-array.prototype.every>\n+pub fn every(this: &Value, args: &[Value], interpreter: &mut Interpreter) -> ResultValue {\n+    if args.is_empty() {\n+        return Err(to_value(\n+            \"missing callback when calling function Array.prototype.every\".to_string(),\n+        ));\n+    }\n+    let callback = &args[0];\n+    let this_arg = if args.len() > 1 {\n+        args[1].clone()\n+    } else {\n+        Gc::new(ValueData::Undefined)\n+    };\n+    let len: i32 = from_value(this.get_field_slice(\"length\")).unwrap();\n+    for i in 0..len {\n+        let element = this.get_field(&i.to_string());\n+        let result = interpreter.call(\n+            callback,\n+            &this_arg,\n+            vec![element.clone(), to_value(i), this.clone()],\n+        )?;\n+        if !result.is_true() {\n+            return Ok(to_value(false));\n+        }\n+    }\n+    Ok(to_value(true))\n+}\n+\n /// Create a new `Array` object\n pub fn create_constructor(global: &Value) -> Value {\n     // Create Constructor\n"}
{"instance_id": "chronotope__chrono-508", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/round.rs b/src/round.rs\nindex 92d7c3a..88b1236 100644\n--- a/src/round.rs\n+++ b/src/round.rs\n@@ -158,20 +158,28 @@ impl<Tz: TimeZone> DurationRound for DateTime<Tz> {\n             if span > stamp.abs() {\n                 return Err(RoundingError::DurationExceedsTimestamp);\n             }\n+            // compute how far down we are from a clean multiple\n             let delta_down = stamp % span;\n             if delta_down == 0 {\n+                // already aligned\n                 Ok(self)\n             } else {\n+                // decide whether to round up or down\n                 let (delta_up, delta_down) = if delta_down < 0 {\n                     (delta_down.abs(), span - delta_down.abs())\n                 } else {\n                     (span - delta_down, delta_down)\n                 };\n-                if delta_up <= delta_down {\n-                    Ok(self + Duration::nanoseconds(delta_up))\n+                // pick the new nanosecond count\n+                let new_stamp = if delta_up <= delta_down {\n+                    stamp + delta_up\n                 } else {\n-                    Ok(self - Duration::nanoseconds(delta_down))\n-                }\n+                    stamp - delta_down\n+                };\n+                // re\u2010build DateTime<Tz> from the raw timestamp\n+                let secs = new_stamp.div_euclid(1_000_000_000);\n+                let nsecs = new_stamp.rem_euclid(1_000_000_000) as u32;\n+                Ok(self.timezone().timestamp(secs, nsecs))\n             }\n         } else {\n             Err(RoundingError::DurationExceedsLimit)\n@@ -187,11 +195,23 @@ impl<Tz: TimeZone> DurationRound for DateTime<Tz> {\n             if span > stamp.abs() {\n                 return Err(RoundingError::DurationExceedsTimestamp);\n             }\n+            // how many nanoseconds to go back to the last multiple\n             let delta_down = stamp % span;\n-            match delta_down.cmp(&0) {\n-                Ordering::Equal => Ok(self),\n-                Ordering::Greater => Ok(self - Duration::nanoseconds(delta_down)),\n-                Ordering::Less => Ok(self - Duration::nanoseconds(span - delta_down.abs())),\n+            if delta_down == 0 {\n+                // already exactly on a multiple\n+                Ok(self)\n+            } else {\n+                // compute new timestamp by truncation\n+                let new_stamp = if delta_down > 0 {\n+                    stamp - delta_down\n+                } else {\n+                    // negative remainder: move back by the complement\n+                    stamp - (span - delta_down.abs())\n+                };\n+                // rebuild preserving the same timezone\n+                let secs = new_stamp.div_euclid(1_000_000_000);\n+                let nsecs = new_stamp.rem_euclid(1_000_000_000) as u32;\n+                Ok(self.timezone().timestamp(secs, nsecs))\n             }\n         } else {\n             Err(RoundingError::DurationExceedsLimit)\n"}
{"instance_id": "mozilla__cbindgen-519", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bindgen/config.rs b/src/bindgen/config.rs\nindex 580c9e0..bd0da29 100644\n--- a/src/bindgen/config.rs\n+++ b/src/bindgen/config.rs\n@@ -663,6 +663,8 @@ pub struct ParseConfig {\n     pub include: Option<Vec<String>>,\n     /// The names of crates to not parse\n     pub exclude: Vec<String>,\n+    /// List of module paths (e.g. \"foo::bar\") to skip entirely during parsing.\n+    pub exclude_modules: Vec<String>,\n     /// The configuration options for `rustc --pretty=expanded`\n     #[serde(deserialize_with = \"retrocomp_parse_expand_config_deserialize\")]\n     pub expand: ParseExpandConfig,\ndiff --git a/src/bindgen/parser.rs b/src/bindgen/parser.rs\nindex 8cb64de..cafbbea 100644\n--- a/src/bindgen/parser.rs\n+++ b/src/bindgen/parser.rs\n@@ -93,6 +93,9 @@ struct Parser<'a> {\n \n     cfg_stack: Vec<Cfg>,\n \n+    // Track the current module path (e.g. [\"foo\", \"bar\"]) for exclusion checks\n+    mod_path_stack: Vec<String>,\n+\n     out: Parse,\n }\n \n"}
{"instance_id": "rust-fuzz__cargo-fuzz-234", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/project.rs b/src/project.rs\nindex 13372ae..5fbb87e 100644\n--- a/src/project.rs\n+++ b/src/project.rs\n@@ -432,11 +432,26 @@ impl FuzzProject {\n                 eprintln!();\n             }\n \n-            eprintln!(\n-                \"Reproduce with:\\n\\n\\tcargo fuzz run {target} {artifact}\\n\",\n-                target = &run.target,\n-                artifact = artifact.display()\n-            );\n+            {\n+                // Reconstruct the exact command (toolchain + all flags) that was used.\n+                let mut parts = Vec::new();\n+                parts.push(\"cargo\".to_string());\n+                if let Some(ref tc) = run.toolchain {\n+                    parts.push(format!(\"+{}\", tc));\n+                }\n+                parts.push(\"fuzz\".to_string());\n+                parts.push(\"run\".to_string());\n+                parts.push(run.target.clone());\n+                // Include sanitizer / time / memory / other flags:\n+                parts.extend(run.args.iter().cloned());\n+                let cmd = parts.join(\" \");\n+\n+                eprintln!(\n+                    \"Reproduce with:\\n\\n\\t{} {artifact}\\n\",\n+                    cmd,\n+                    artifact = artifact.display()\n+                );\n+            }\n             eprintln!(\n                 \"Minimize test case with:\\n\\n\\tcargo fuzz tmin {target} {artifact}\\n\",\n                 target = &run.target,\n@@ -511,11 +526,25 @@ impl FuzzProject {\n                 eprintln!();\n             }\n \n-            eprintln!(\n-                \"Reproduce with:\\n\\n\\tcargo fuzz run {target} {artifact}\\n\",\n-                target = &tmin.target,\n-                artifact = artifact.display()\n-            );\n+            {\n+                // Reconstruct the full command including toolchain and flags\n+                let mut parts = Vec::new();\n+                parts.push(\"cargo\".to_string());\n+                if let Some(ref tc) = tmin.toolchain {\n+                    parts.push(format!(\"+{}\", tc));\n+                }\n+                parts.push(\"fuzz\".to_string());\n+                parts.push(\"run\".to_string());\n+                parts.push(tmin.target.clone());\n+                parts.extend(tmin.args.iter().cloned());\n+                let cmd = parts.join(\" \");\n+\n+                eprintln!(\n+                    \"Reproduce with:\\n\\n\\t{} {artifact}\\n\",\n+                    cmd,\n+                    artifact = artifact.display()\n+                );\n+            }\n         }\n \n         Ok(())\n"}
{"instance_id": "rust-fuzz__cargo-fuzz-388", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/project.rs b/src/project.rs\nindex c62bfe9..a63572e 100644\n--- a/src/project.rs\n+++ b/src/project.rs\n@@ -233,7 +233,10 @@ impl FuzzProject {\n         if !build.release || build.debug_assertions || build.careful_mode {\n             rustflags.push_str(\" -Cdebug-assertions\");\n         }\n-        if build.triple.contains(\"-msvc\") {\n+        if build.triple.contains(\"-msvc\")\n+            // don\u2019t force\u2010include main when producing a DLL\n+            && !matches!(build.crate_type.as_str(), \"cdylib\")\n+        {\n             // The entrypoint is in the bundled libfuzzer rlib, this gets the linker to find it.\n             rustflags.push_str(\" -Clink-arg=/include:main\");\n         }\n"}
{"instance_id": "tokio-rs__axum-2992", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/response/sse.rs b/axum/src/response/sse.rs\nindex e77b8c78..346f1470 100644\n--- a/axum/src/response/sse.rs\n+++ b/axum/src/response/sse.rs\n@@ -213,7 +213,10 @@ impl Event {\n         }\n \n         self.buffer.extend_from_slice(b\"data: \");\n-        serde_json::to_writer((&mut self.buffer).writer(), &data).map_err(axum_core::Error::new)?;\n+        // Serialize JSON into the buffer, filtering out any embedded newlines.\n+        let writer = (&mut self.buffer).writer();\n+        let mut filter = NoNewlineWriter { inner: writer };\n+        serde_json::to_writer(&mut filter, &data).map_err(axum_core::Error::new)?;\n         self.buffer.put_u8(b'\\n');\n \n         self.flags.insert(EventFlags::HAS_DATA);\n"}
{"instance_id": "tokio-rs__bytes-265", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes.rs b/src/bytes.rs\nindex 5cb3d75..0edde54 100644\n--- a/src/bytes.rs\n+++ b/src/bytes.rs\n@@ -3,6 +3,45 @@ use buf::IntoIter;\n use debug;\n \n use std::{cmp, fmt, mem, hash, ops, slice, ptr, usize};\n+use std::ops::Bound;\n+\n+/// A trait to mirror `std::ops::RangeArgument` on stable Rust.\n+pub trait RangeArgument<Idx> {\n+    /// Returns the start bound (`Included`, `Excluded` or `Unbounded`).\n+    fn start_bound(&self) -> Bound<&Idx>;\n+    /// Returns the end bound (`Included`, `Excluded` or `Unbounded`).\n+    fn end_bound(&self) -> Bound<&Idx>;\n+}\n+\n+impl<Idx> RangeArgument<Idx> for ops::RangeFull {\n+    fn start_bound(&self) -> Bound<&Idx> { Bound::Unbounded }\n+    fn end_bound(&self) -> Bound<&Idx>   { Bound::Unbounded }\n+}\n+\n+impl<Idx> RangeArgument<Idx> for ops::RangeFrom<Idx> {\n+    fn start_bound(&self) -> Bound<&Idx> { Bound::Included(&self.start) }\n+    fn end_bound(&self) -> Bound<&Idx>   { Bound::Unbounded }\n+}\n+\n+impl<Idx> RangeArgument<Idx> for ops::RangeTo<Idx> {\n+    fn start_bound(&self) -> Bound<&Idx> { Bound::Unbounded }\n+    fn end_bound(&self) -> Bound<&Idx>   { Bound::Excluded(&self.end) }\n+}\n+\n+impl<Idx> RangeArgument<Idx> for ops::RangeInclusive<Idx> {\n+    fn start_bound(&self) -> Bound<&Idx> { Bound::Included(self.start()) }\n+    fn end_bound(&self) -> Bound<&Idx>   { Bound::Included(self.end()) }\n+}\n+\n+impl<Idx> RangeArgument<Idx> for ops::RangeToInclusive<Idx> {\n+    fn start_bound(&self) -> Bound<&Idx> { Bound::Unbounded }\n+    fn end_bound(&self) -> Bound<&Idx>   { Bound::Included(&self.end) }\n+}\n+\n+impl<Idx> RangeArgument<Idx> for ops::Range<Idx> {\n+    fn start_bound(&self) -> Bound<&Idx> { Bound::Included(&self.start) }\n+    fn end_bound(&self) -> Bound<&Idx>   { Bound::Excluded(&self.end) }\n+}\n use std::borrow::{Borrow, BorrowMut};\n use std::sync::atomic::{self, AtomicUsize, AtomicPtr};\n use std::sync::atomic::Ordering::{Relaxed, Acquire, Release, AcqRel};\n"}
{"instance_id": "bevyengine__bevy-15166", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs\nindex c6676fa26..cffa6aaf7 100644\n--- a/crates/bevy_ecs/src/system/commands/mod.rs\n+++ b/crates/bevy_ecs/src/system/commands/mod.rs\n@@ -1174,6 +1174,34 @@ impl EntityCommands<'_> {\n         self.add(try_insert(bundle, InsertMode::Keep))\n     }\n \n+    /// Similar to [`Self::insert_if_new`] but will only insert if the predicate returns true.\n+    /// This is useful for chaining method calls.\n+    #[track_caller]\n+    pub fn insert_if_new_and<F>(self, bundle: impl Bundle, condition: F) -> Self\n+    where\n+        F: FnOnce() -> bool,\n+    {\n+        if condition() {\n+            self.insert_if_new(bundle)\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// Similar to [`Self::try_insert_if_new`] but will only try to insert if the predicate returns true.\n+    /// This is useful for chaining method calls.\n+    #[track_caller]\n+    pub fn try_insert_if_new_and<F>(self, bundle: impl Bundle, condition: F) -> Self\n+    where\n+        F: FnOnce() -> bool,\n+    {\n+        if condition() {\n+            self.try_insert_if_new(bundle)\n+        } else {\n+            self\n+        }\n+    }\n+\n     /// Removes a [`Bundle`] of components from the entity.\n     ///\n     /// # Example\n"}
{"instance_id": "cargo-generate__cargo-generate-525", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/git.rs b/src/git.rs\nindex e2c923c..b834014 100644\n--- a/src/git.rs\n+++ b/src/git.rs\n@@ -314,6 +314,15 @@ pub fn init(project_dir: &Path, branch: &str) -> Result<Repository> {\n     })\n }\n \n+/// Force initialization of a new git repository in the given directory,\n+/// ignoring any existing repository in parent directories.\n+pub fn init_force(project_dir: &Path, branch: &str) -> Result<Repository> {\n+    let mut opts = RepositoryInitOptions::new();\n+    opts.bare(false);\n+    opts.initial_head(branch);\n+    Repository::init_opts(project_dir, &opts).context(\"Couldn't force init new repository\")\n+}\n+\n /// determines what kind of repository we got\n fn determine_repo_kind(remote_url: &str) -> RepoKind {\n     if remote_url.starts_with(\"git@\") {\n"}
{"instance_id": "biomejs__biome-4179", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_analyze/src/lint/style.rs b/crates/biome_js_analyze/src/lint/style.rs\nindex e2ceb4f30a..2337ee9fd1 100644\n--- a/crates/biome_js_analyze/src/lint/style.rs\n+++ b/crates/biome_js_analyze/src/lint/style.rs\n@@ -23,6 +23,7 @@ pub mod no_yoda_expression;\n pub mod use_as_const_assertion;\n pub mod use_block_statements;\n pub mod use_collapsed_else_if;\n+pub mod use_collapsed_if;\n pub mod use_consistent_array_type;\n pub mod use_consistent_builtin_instantiation;\n pub mod use_const;\n@@ -78,6 +79,7 @@ declare_lint_group! {\n             self :: use_as_const_assertion :: UseAsConstAssertion ,\n             self :: use_block_statements :: UseBlockStatements ,\n             self :: use_collapsed_else_if :: UseCollapsedElseIf ,\n+            self :: use_collapsed_if :: UseCollapsedIf ,\n             self :: use_consistent_array_type :: UseConsistentArrayType ,\n             self :: use_consistent_builtin_instantiation :: UseConsistentBuiltinInstantiation ,\n             self :: use_const :: UseConst ,\ndiff --git a/crates/biome_js_analyze/src/options.rs b/crates/biome_js_analyze/src/options.rs\nindex 93ab2a8335..eb46f0b6d6 100644\n--- a/crates/biome_js_analyze/src/options.rs\n+++ b/crates/biome_js_analyze/src/options.rs\n@@ -302,6 +302,8 @@ pub type UseButtonType =\n     <lint::a11y::use_button_type::UseButtonType as biome_analyze::Rule>::Options;\n pub type UseCollapsedElseIf =\n     <lint::style::use_collapsed_else_if::UseCollapsedElseIf as biome_analyze::Rule>::Options;\n+pub type UseCollapsedIf =\n+    <lint::style::use_collapsed_if::UseCollapsedIf as biome_analyze::Rule>::Options;\n pub type UseComponentExportOnlyModules = < lint :: nursery :: use_component_export_only_modules :: UseComponentExportOnlyModules as biome_analyze :: Rule > :: Options ;\n pub type UseConsistentArrayType = < lint :: style :: use_consistent_array_type :: UseConsistentArrayType as biome_analyze :: Rule > :: Options ;\n pub type UseConsistentBuiltinInstantiation = < lint :: style :: use_consistent_builtin_instantiation :: UseConsistentBuiltinInstantiation as biome_analyze :: Rule > :: Options ;\n"}
{"instance_id": "tokio-rs__tokio-5144", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/sync/semaphore.rs b/tokio/src/sync/semaphore.rs\nindex ccf44ba8..057a24b9 100644\n--- a/tokio/src/sync/semaphore.rs\n+++ b/tokio/src/sync/semaphore.rs\n@@ -123,6 +123,10 @@ fn bounds() {\n }\n \n impl Semaphore {\n+    /// The maximum number of permits a semaphore may be initialized with.\n+    /// Matches the internal cap used by the low\u2010level semaphore implementation.\n+    pub const MAX_PERMITS: usize = usize::MAX >> 3;\n+\n     /// Creates a new semaphore with the initial number of permits.\n     #[track_caller]\n     pub fn new(permits: usize) -> Self {\n"}
{"instance_id": "clap-rs__clap-2653", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/arg/mod.rs b/src/build/arg/mod.rs\nindex 54f6f96b..c98c9b9a 100644\n--- a/src/build/arg/mod.rs\n+++ b/src/build/arg/mod.rs\n@@ -4642,10 +4642,9 @@ impl<'help> Arg<'help> {\n     // Used for positionals when printing\n     pub(crate) fn multiple_str(&self) -> &str {\n         let mult_vals = self.val_names.len() > 1;\n-        if (self.is_set(ArgSettings::MultipleValues)\n-            || self.is_set(ArgSettings::MultipleOccurrences))\n-            && !mult_vals\n-        {\n+        // Only emit \u201c\u2026\u201d when the arg truly supports multiple values, not just\n+        // when MultipleOccurrences is on (e.g. Option<Option<T>>).\n+        if self.is_set(ArgSettings::MultipleValues) && !mult_vals {\n             \"...\"\n         } else {\n             \"\"\n"}
{"instance_id": "tokio-rs__tokio-6967", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/io/async_fd.rs b/tokio/src/io/async_fd.rs\nindex 0fda5da4..887b5060 100644\n--- a/tokio/src/io/async_fd.rs\n+++ b/tokio/src/io/async_fd.rs\n@@ -185,6 +185,70 @@ pub struct AsyncFd<T: AsRawFd> {\n     inner: Option<T>,\n }\n \n+impl<T: AsRawFd> AsyncFd<T> {\n+    /// Perform an I/O operation on the inner object, asynchronously waiting\n+    /// for the specified readiness. The provided closure `f` is invoked when\n+    /// the descriptor is ready; if it returns `Err(std::io::ErrorKind::WouldBlock)`,\n+    /// the readiness is cleared and the operation retried.\n+    ///\n+    /// This is a convenience wrapper over the usual:\n+    ///\n+    /// ```ignore\n+    /// loop {\n+    ///     let mut guard = match interest {\n+    ///         Interest::READABLE => async_fd.readable().await?,\n+    ///         Interest::WRITABLE => async_fd.writable().await?,\n+    ///     };\n+    ///\n+    ///     match guard.try_io(&mut |io| /* your I/O */ ) {\n+    ///         Ok(res) => break Ok(res),\n+    ///         Err(_would_block) => continue,\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// # use std::os::unix::io::AsRawFd;\n+    /// # use std::io;\n+    /// # use tokio::io::{AsyncFd, Interest};\n+    /// # use libc::sendmsg;\n+    /// async fn send_on_socket(fd: AsyncFd<std::os::unix::net::UnixDatagram>, msg: libc::msghdr) -> io::Result<usize> {\n+    ///     async_fd.try_io(Interest::WRITABLE, |inner| {\n+    ///         // `inner` is the underlying `UnixDatagram`\n+    ///         // call libc::sendmsg or any raw I/O\n+    ///         let n = unsafe { sendmsg(inner.as_raw_fd(), &msg, 0) };\n+    ///         if n < 0 {\n+    ///             Err(io::Error::last_os_error())\n+    ///         } else {\n+    ///             Ok(n as usize)\n+    ///         }\n+    ///     }).await\n+    /// }\n+    /// ```\n+    pub async fn try_io<R, F>(&self, interest: Interest, mut f: F) -> io::Result<R>\n+    where\n+        F: FnMut(&mut T) -> io::Result<R>,\n+    {\n+        loop {\n+            // Wait for the requested readiness\n+            let mut guard = match interest {\n+                Interest::READABLE => self.readable().await?,\n+                Interest::WRITABLE => self.writable().await?,\n+            };\n+\n+            // Try the operation\n+            match guard.try_io(|inner| f(inner)) {\n+                // Success, return the result\n+                Ok(r) => return Ok(r),\n+                // Not ready after all, retry\n+                Err(_would_block) => continue,\n+            }\n+        }\n+    }\n+}\n+\n /// Represents an IO-ready event detected on a particular file descriptor that\n /// has not yet been acknowledged. This is a `must_use` structure to help ensure\n /// that you do not forget to explicitly clear (or not clear) the event.\n"}
{"instance_id": "bincode-org__bincode-470", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/derive/src/derive_struct.rs b/derive/src/derive_struct.rs\nindex 934678b..e26f45c 100644\n--- a/derive/src/derive_struct.rs\n+++ b/derive/src/derive_struct.rs\n@@ -2,6 +2,36 @@ use super::FieldAttribute;\n use virtue::generate::Generator;\n use virtue::parse::Fields;\n use virtue::prelude::*;\n+use syn::{Type, PathArguments, GenericArgument};\n+use syn::spanned::Spanned;\n+\n+/// Walk a `syn::Type` and return true if any path segment\n+/// matches `ident` (i.e. a direct self\u2010reference).\n+fn type_contains_ident(ty: &Type, ident: &str) -> bool {\n+    match ty {\n+        Type::Path(type_path) => {\n+            for segment in &type_path.path.segments {\n+                if segment.ident == ident {\n+                    return true;\n+                }\n+                if let PathArguments::AngleBracketed(angle) = &segment.arguments {\n+                    for arg in &angle.args {\n+                        if let GenericArgument::Type(inner_ty) = arg {\n+                            if type_contains_ident(inner_ty, ident) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            false\n+        }\n+        Type::Reference(r) => type_contains_ident(&r.elem, ident),\n+        Type::Array(a)     => type_contains_ident(&a.elem, ident),\n+        Type::Tuple(t)     => t.elems.iter().any(|elem| type_contains_ident(elem, ident)),\n+        _                  => false,\n+    }\n+}\n \n pub struct DeriveStruct {\n     pub fields: Fields,\n"}
{"instance_id": "dtolnay__async-trait-227", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/expand.rs b/src/expand.rs\nindex 53918cb..ff485b9 100644\n--- a/src/expand.rs\n+++ b/src/expand.rs\n@@ -352,16 +352,18 @@ fn transform_block(context: Context, sig: &mut Signature, block: &mut Block) {\n         .iter()\n         .enumerate()\n         .map(|(i, arg)| match arg {\n-            FnArg::Receiver(Receiver {\n-                self_token,\n-                mutability,\n-                ..\n-            }) => {\n+            FnArg::Receiver(arg) => {\n+                // forward any attributes (e.g. #[cfg(...)]) on the receiver\n+                let attrs = &arg.attrs;\n+                let mutability = &arg.mutability;\n+                let self_token = &arg.self_token;\n                 let ident = Ident::new(\"__self\", self_token.span);\n                 self_span = Some(self_token.span);\n-                quote!(let #mutability #ident = #self_token;)\n+                quote!(#(#attrs)* let #mutability #ident = #self_token;)\n             }\n             FnArg::Typed(arg) => {\n+                // forward any attributes (e.g. #[cfg(...)]) on the parameter\n+                let attrs = &arg.attrs;\n                 if let Pat::Ident(PatIdent {\n                     ident, mutability, ..\n                 }) = &*arg.pat\n@@ -369,17 +371,17 @@ fn transform_block(context: Context, sig: &mut Signature, block: &mut Block) {\n                     if ident == \"self\" {\n                         self_span = Some(ident.span());\n                         let prefixed = Ident::new(\"__self\", ident.span());\n-                        quote!(let #mutability #prefixed = #ident;)\n+                        quote!(#(#attrs)* let #mutability #prefixed = #ident;)\n                     } else {\n-                        quote!(let #mutability #ident = #ident;)\n+                        quote!(#(#attrs)* let #mutability #ident = #ident;)\n                     }\n                 } else {\n                     let pat = &arg.pat;\n                     let ident = positional_arg(i, pat);\n                     if let Pat::Wild(_) = **pat {\n-                        quote!(let #ident = #ident;)\n+                        quote!(#(#attrs)* let #ident = #ident;)\n                     } else {\n-                        quote!(let #pat = #ident;)\n+                        quote!(#(#attrs)* let #pat = #ident;)\n                     }\n                 }\n             }\n"}
{"instance_id": "clap-rs__clap-2633", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/arg/mod.rs b/src/build/arg/mod.rs\nindex a6bcb519..becc7675 100644\n--- a/src/build/arg/mod.rs\n+++ b/src/build/arg/mod.rs\n@@ -2555,8 +2555,9 @@ impl<'help> Arg<'help> {\n     /// [positional]: Arg::index()\n     /// [`Arg::takes_value(true)`]: Arg::takes_value()\n     pub fn value_name(mut self, name: &'help str) -> Self {\n-        let l = self.val_names.len();\n-        self.val_names.insert(l, name);\n+        // Remove any previously\u2013inserted default metavar so only the user\u2019s name remains\n+        self.val_names.clear();\n+        self.val_names.insert(0, name);\n         self.takes_value(true)\n     }\n \n"}
{"instance_id": "biomejs__biome-4186", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_factory/src/utils.rs b/crates/biome_js_factory/src/utils.rs\nindex e47e71cabd..dbdc1d0c2e 100644\n--- a/crates/biome_js_factory/src/utils.rs\n+++ b/crates/biome_js_factory/src/utils.rs\n@@ -23,10 +23,12 @@ pub fn escape<'a>(\n         \"escaping_char must be a valid ASCII character.\"\n     );\n     let mut escaped = String::new();\n-    let mut iter = unescaped_string.bytes().enumerate();\n+    // Convert to char_indices so idx is always a valid UTF-8 boundary\n+    let esc_char = escaping_char as char;\n+    let mut iter = unescaped_string.char_indices();\n     let mut last_copied_idx = 0;\n-    while let Some((idx, byte)) = iter.next() {\n-        if byte == escaping_char {\n+    while let Some((idx, ch)) = iter.next() {\n+        if ch == esc_char {\n             // The next character is escaped\n             iter.next();\n         } else {\n@@ -36,9 +38,10 @@ pub fn escape<'a>(\n                         escaped = String::with_capacity(unescaped_string.len() * 2 - idx);\n                     }\n                     escaped.push_str(&unescaped_string[last_copied_idx..idx]);\n-                    escaped.push(escaping_char as char);\n+                    escaped.push(esc_char);\n                     escaped.push_str(candidate);\n-                    for _ in candidate.bytes().skip(1) {\n+                    // Skip the remaining characters of the candidate\n+                    for _ in candidate.chars().skip(1) {\n                         iter.next();\n                     }\n                     last_copied_idx = idx + candidate.len();\n"}
{"instance_id": "tokio-rs__bytes-710", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes_mut.rs b/src/bytes_mut.rs\nindex 537f01a..4310a6f 100644\n--- a/src/bytes_mut.rs\n+++ b/src/bytes_mut.rs\n@@ -1189,6 +1189,12 @@ impl<'a> From<&'a str> for BytesMut {\n     }\n }\n \n+impl From<Bytes> for BytesMut {\n+    fn from(src: Bytes) -> BytesMut {\n+        src.make_mut()\n+    }\n+}\n+\n impl From<BytesMut> for Bytes {\n     fn from(src: BytesMut) -> Bytes {\n         src.freeze()\n"}
{"instance_id": "tokio-rs__bytes-547", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes.rs b/src/bytes.rs\nindex 576e905..d301b2d 100644\n--- a/src/bytes.rs\n+++ b/src/bytes.rs\n@@ -480,6 +480,22 @@ impl Bytes {\n         self.truncate(0);\n     }\n \n+    /// Converts this `Bytes` into a `Vec<u8>` by cloning the data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use bytes::Bytes;\n+    ///\n+    /// let bytes = Bytes::from(&b\"hello\"[..]);\n+    /// let vec = bytes.into_vec();\n+    /// assert_eq!(vec, b\"hello\");\n+    /// ```\n+    #[inline]\n+    pub fn into_vec(self) -> Vec<u8> {\n+        self.as_ref().to_vec()\n+    }\n+\n     #[inline]\n     pub(crate) unsafe fn with_vtable(\n         ptr: *const u8,\n@@ -845,6 +861,17 @@ impl From<String> for Bytes {\n     }\n }\n \n+impl From<Bytes> for Vec<u8> {\n+    /// Converts a `Bytes` into a `Vec<u8>`.\n+    ///\n+    /// This simply clones the bytes; for a zero-copy path when you know\n+    /// this was the sole owner of a `Vec<u8>` backing, you can later\n+    /// detect that and optimize here.\n+    fn from(bytes: Bytes) -> Vec<u8> {\n+        bytes.into_vec()\n+    }\n+}\n+\n // ===== impl Vtable =====\n \n impl fmt::Debug for Vtable {\n"}
{"instance_id": "tracel-ai__burn-1087", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/burn-compute/src/tune/tune_cache.rs b/burn-compute/src/tune/tune_cache.rs\nindex d91b70ec..1ce8cce9 100644\n--- a/burn-compute/src/tune/tune_cache.rs\n+++ b/burn-compute/src/tune/tune_cache.rs\n@@ -5,9 +5,21 @@ use alloc::boxed::Box;\n use hashbrown::HashMap;\n \n /// Use to find and reuse the best kernel for some input\n+use std::path::{PathBuf, Path};\n+use std::fs;\n+use serde::{Serialize, Deserialize};\n+\n #[derive(Debug, Default)]\n pub(crate) struct TuneCache<K> {\n     cache: HashMap<K, usize>,\n+    path: PathBuf,\n+    version: String,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+struct OnDiskCache<K> {\n+    version: String,\n+    entries: HashMap<K, usize>,\n }\n \n /// Result of the cache try\n"}
{"instance_id": "rinja-rs__askama-911", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/askama_parser/src/node.rs b/askama_parser/src/node.rs\nindex 4da1742..c016274 100644\n--- a/askama_parser/src/node.rs\n+++ b/askama_parser/src/node.rs\n@@ -232,7 +232,7 @@ impl<'a> Target<'a> {\n #[derive(Debug, PartialEq)]\n pub struct When<'a> {\n     pub ws: Ws,\n-    pub target: Target<'a>,\n+    pub targets: Vec<Target<'a>>,\n     pub nodes: Vec<Node<'a>>,\n }\n \n"}
{"instance_id": "biomejs__biome-384", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_analyze/src/analyzers/complexity/no_multiple_spaces_in_regular_expression_literals.rs b/crates/biome_js_analyze/src/analyzers/complexity/no_multiple_spaces_in_regular_expression_literals.rs\nindex 691ec1a8b6..cc68133054 100644\n--- a/crates/biome_js_analyze/src/analyzers/complexity/no_multiple_spaces_in_regular_expression_literals.rs\n+++ b/crates/biome_js_analyze/src/analyzers/complexity/no_multiple_spaces_in_regular_expression_literals.rs\n@@ -132,7 +132,15 @@ impl Rule for NoMultipleSpacesInRegularExpressionLiterals {\n             previous_start = *end;\n             eg_length += *end - *start;\n         }\n-        normalized_string_token += &trimmed_token_string[previous_start..];\n+        // Append the remaining pattern, but if it starts with a quantifier\n+        // (+ * ? {), escape that first character so it stays literal.\n+        let tail = &trimmed_token_string[previous_start..];\n+        if let Some(first_char) = tail.chars().next() {\n+            if \"+*?{\".contains(first_char) {\n+                normalized_string_token.push('\\\\');\n+            }\n+        }\n+        normalized_string_token += tail;\n         let next_trimmed_token = JsSyntaxToken::new_detached(\n             JsSyntaxKind::JS_REGEX_LITERAL,\n             &normalized_string_token,\n"}
{"instance_id": "tokio-rs__tracing-1291", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tracing-attributes/src/lib.rs b/tracing-attributes/src/lib.rs\nindex 65a2b216..6b5aac52 100644\n--- a/tracing-attributes/src/lib.rs\n+++ b/tracing-attributes/src/lib.rs\n@@ -451,39 +451,46 @@ pub fn instrument(\n \n     let instrumented_function_name = input.sig.ident.to_string();\n \n-    // check for async_trait-like patterns in the block and wrap the\n-    // internal function with Instrument instead of wrapping the\n-    // async_trait generated wrapper\n+    // check for async_trait-like patterns in the block\n     if let Some(internal_fun) = get_async_trait_info(&input.block, input.sig.asyncness.is_some()) {\n-        // let's rewrite some statements!\n+        // try to rewrite only a legacy inner function match\n         let mut stmts: Vec<Stmt> = input.block.stmts.to_vec();\n+        let mut found_inner = false;\n         for stmt in &mut stmts {\n             if let Stmt::Item(Item::Fn(fun)) = stmt {\n-                // instrument the function if we considered it as the one we truly want to trace\n                 if fun.sig.ident == internal_fun.name {\n+                    // legacy async-trait pattern: instrument the inner fn\n                     *stmt = syn::parse2(gen_body(\n                         fun,\n                         args,\n-                        instrumented_function_name,\n+                        instrumented_function_name.clone(),\n                         Some(internal_fun),\n                     ))\n                     .unwrap();\n+                    found_inner = true;\n                     break;\n                 }\n             }\n         }\n-\n-        let vis = &input.vis;\n-        let sig = &input.sig;\n-        let attrs = &input.attrs;\n-        quote!(\n-            #(#attrs) *\n-            #vis #sig {\n-                #(#stmts) *\n-            }\n-        )\n-        .into()\n+        if found_inner {\n+            // legacy: re-emit wrapper with the one instrumented inner function\n+            let vis = &input.vis;\n+            let sig = &input.sig;\n+            let attrs = &input.attrs;\n+            quote!(\n+                #(#attrs)*\n+                #vis #sig {\n+                    #(#stmts)*\n+                }\n+            )\n+            .into()\n+        } else {\n+            // new async-trait pattern (Box::pin(async move { \u2026 })):\n+            // instrument the outer wrapper itself\n+            gen_body(&input, args, instrumented_function_name, Some(internal_fun)).into()\n+        }\n     } else {\n+        // no async-trait pattern: normal instrumentation of this fn\n         gen_body(&input, args, instrumented_function_name, None).into()\n     }\n }\n@@ -1112,42 +1119,56 @@ struct AsyncTraitInfo {\n \n // Return the informations necessary to process a function annotated with async-trait.\n fn get_async_trait_info(block: &Block, block_is_async: bool) -> Option<AsyncTraitInfo> {\n-    let fun = get_async_trait_function(block, block_is_async)?;\n-\n-    // if \"_self\" is present as an argument, we store its type to be able to rewrite \"Self\" (the\n-    // parameter type) with the type of \"_self\"\n-    let self_type = fun\n-        .sig\n-        .inputs\n-        .iter()\n-        .map(|arg| {\n-            if let FnArg::Typed(ty) = arg {\n-                if let Pat::Ident(PatIdent { ident, .. }) = &*ty.pat {\n-                    if ident == \"_self\" {\n-                        let mut ty = &*ty.ty;\n-                        // extract the inner type if the argument is \"&self\" or \"&mut self\"\n-                        if let syn::Type::Reference(syn::TypeReference { elem, .. }) = ty {\n-                            ty = &*elem;\n-                        }\n-                        if let syn::Type::Path(tp) = ty {\n-                            return Some(tp.clone());\n+    // first attempt the legacy async-trait detection\n+    if let Some(fun) = get_async_trait_function(block, block_is_async) {\n+        // legacy: extract \"_self\" type if present\n+        let self_type = fun\n+            .sig\n+            .inputs\n+            .iter()\n+            .map(|arg| {\n+                if let FnArg::Typed(ty) = arg {\n+                    if let Pat::Ident(PatIdent { ident, .. }) = &*ty.pat {\n+                        if ident == \"_self\" {\n+                            let mut ty = &*ty.ty;\n+                            if let syn::Type::Reference(syn::TypeReference { elem, .. }) = ty {\n+                                ty = &*elem;\n+                            }\n+                            if let syn::Type::Path(tp) = ty {\n+                                return Some(tp.clone());\n+                            }\n                         }\n                     }\n                 }\n-            }\n+                None\n+            })\n+            .next()\n+            .unwrap_or(None);\n \n-            None\n-        })\n-        .next();\n-    let self_type = match self_type {\n-        Some(x) => x,\n-        None => None,\n-    };\n+        return Some(AsyncTraitInfo {\n+            name: fun.sig.ident.to_string(),\n+            self_type,\n+        });\n+    }\n+\n+    // detect the new async-trait expansion: a single `Box::pin(async move { \u2026 })` expression\n+    if !block_is_async {\n+        if let Some(Stmt::Expr(Expr::Call(ExprCall { func: outside, args: outside_args, .. })) ) = block.stmts.last() {\n+            if let Expr::Path(path) = outside.as_ref() {\n+                if path_to_string(&path.path) == \"Box::pin\" && outside_args.len() == 1 {\n+                    if matches!(outside_args[0], Expr::Async(_)) {\n+                        // new anonymous-future pattern: instrument the wrapper\n+                        return Some(AsyncTraitInfo {\n+                            name: String::new(),\n+                            self_type: None,\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n-    Some(AsyncTraitInfo {\n-        name: fun.sig.ident.to_string(),\n-        self_type,\n-    })\n+    None\n }\n \n // Return a path as a String\n"}
{"instance_id": "biomejs__biome-1393", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_analyze/src/semantic_analyzers/correctness/use_hook_at_top_level.rs b/crates/biome_js_analyze/src/semantic_analyzers/correctness/use_hook_at_top_level.rs\nindex 1273ffbedf..b800efab32 100644\n--- a/crates/biome_js_analyze/src/semantic_analyzers/correctness/use_hook_at_top_level.rs\n+++ b/crates/biome_js_analyze/src/semantic_analyzers/correctness/use_hook_at_top_level.rs\n@@ -108,6 +108,12 @@ fn enclosing_function_if_call_is_at_top_level(call: &JsCallExpression) -> Option\n                 | JsSyntaxKind::JS_CALL_ARGUMENT_LIST\n                 | JsSyntaxKind::JS_CALL_ARGUMENTS\n                 | JsSyntaxKind::JS_STATIC_MEMBER_EXPRESSION\n+                | JsSyntaxKind::JS_COMPUTED_MEMBER_EXPRESSION\n+                | JsSyntaxKind::JS_OBJECT_EXPRESSION\n+                | JsSyntaxKind::JS_ARRAY_EXPRESSION\n+                | JsSyntaxKind::JS_PROPERTY_OBJECT_MEMBER\n+                | JsSyntaxKind::JS_SHORTHAND_PROPERTY_OBJECT_MEMBER\n+                | JsSyntaxKind::JS_ARRAY_ELEMENT_LIST\n                 | JsSyntaxKind::JS_INITIALIZER_CLAUSE\n                 | JsSyntaxKind::JS_VARIABLE_DECLARATOR\n                 | JsSyntaxKind::JS_VARIABLE_DECLARATOR_LIST\n"}
{"instance_id": "clap-rs__clap-3700", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/arg.rs b/src/build/arg.rs\nindex 80c5199d..9af8674c 100644\n--- a/src/build/arg.rs\n+++ b/src/build/arg.rs\n@@ -1215,6 +1215,11 @@ impl<'help> Arg<'help> {\n     #[must_use]\n     pub fn number_of_values(mut self, qty: usize) -> Self {\n         self.num_vals = Some(qty);\n+        debug_assert!(\n+            self.val_names.len() <= 1 || self.val_names.len() == qty,\n+            \"value_names mismatch: previously set {:?} names, but number_of_values qty is {}\",\n+            self.val_names.len(), qty,\n+        );\n         self.takes_value(true).multiple_values(true)\n     }\n \n@@ -1455,6 +1460,11 @@ impl<'help> Arg<'help> {\n     #[must_use]\n     pub fn value_names(mut self, names: &[&'help str]) -> Self {\n         self.val_names = names.to_vec();\n+        debug_assert!(\n+            self.num_vals.map_or(true, |n| names.len() <= 1 || names.len() == n),\n+            \"number_of_values mismatch: previously set to '{:?}', but value_names length is {}\",\n+            self.num_vals, names.len(),\n+        );\n         self.takes_value(true)\n     }\n \n"}
{"instance_id": "clap-rs__clap-2190", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/arg/mod.rs b/src/build/arg/mod.rs\nindex 3b8b8680..1096342b 100644\n--- a/src/build/arg/mod.rs\n+++ b/src/build/arg/mod.rs\n@@ -2835,8 +2835,11 @@ impl<'help> Arg<'help> {\n     /// [`OsStr`]s instead.\n     #[inline]\n     pub fn env_os(mut self, name: &'help OsStr) -> Self {\n-        // FIXME: What. The. Fuck.\n-        if !self.is_set(ArgSettings::MultipleOccurrences) {\n+        // Only set TakesValue if the user has not explicitly disabled it.\n+        // This prevents flags (takes_value(false)) from being converted into options.\n+        if !self.is_set(ArgSettings::MultipleOccurrences)\n+            && !self.is_set(ArgSettings::TakesValueInferredFalse)\n+        {\n             self.set_mut(ArgSettings::TakesValue);\n         }\n \ndiff --git a/src/parse/matches/arg_matches.rs b/src/parse/matches/arg_matches.rs\nindex c7d06e69..0e11176f 100644\n--- a/src/parse/matches/arg_matches.rs\n+++ b/src/parse/matches/arg_matches.rs\n@@ -516,7 +516,20 @@ impl ArgMatches {\n                 return true;\n             }\n         }\n-        self.args.contains_key(&id)\n+        // Regular presence check\n+        if self.args.contains_key(&id) {\n+            return true;\n+        }\n+        // If the arg has an env var, does not take a value, and the var is non-empty?\n+        if let Some(arg) = self.app().find(id) {\n+            if !arg.is_set(ArgSettings::TakesValue)\n+               && arg.env.is_some()\n+               && arg.env.as_ref().unwrap().1.is_some()\n+            {\n+                return true;\n+            }\n+        }\n+        false\n     }\n \n     /// Returns the number of times an argument was used at runtime. If an argument isn't present\n"}
{"instance_id": "tokio-rs__tokio-6345", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/io/async_fd.rs b/tokio/src/io/async_fd.rs\nindex aaf17584..cdfe2cd9 100644\n--- a/tokio/src/io/async_fd.rs\n+++ b/tokio/src/io/async_fd.rs\n@@ -181,6 +181,16 @@ pub struct AsyncFd<T: AsRawFd> {\n     inner: Option<T>,\n }\n \n+/// Error returned if AsyncFd creation fails. Contains the original `inner`\n+/// so the caller can recover it.\n+#[derive(Debug)]\n+pub struct AsyncFdError<T> {\n+    /// The IO object passed into AsyncFd\n+    pub inner: T,\n+    /// The error that occurred during reactor registration\n+    pub error: std::io::Error,\n+}\n+\n /// Represents an IO-ready event detected on a particular file descriptor that\n /// has not yet been acknowledged. This is a `must_use` structure to help ensure\n /// that you do not forget to explicitly clear (or not clear) the event.\n@@ -219,7 +229,7 @@ impl<T: AsRawFd> AsyncFd<T> {\n     /// feature flag is not enabled.\n     #[inline]\n     #[track_caller]\n-    pub fn new(inner: T) -> io::Result<Self>\n+    pub fn new(inner: T) -> Result<Self, AsyncFdError<T>>\n     where\n         T: AsRawFd,\n     {\n@@ -236,7 +246,7 @@ impl<T: AsRawFd> AsyncFd<T> {\n     /// feature flag is not enabled.\n     #[inline]\n     #[track_caller]\n-    pub fn with_interest(inner: T, interest: Interest) -> io::Result<Self>\n+    pub fn with_interest(inner: T, interest: Interest) -> Result<Self, AsyncFdError<T>>\n     where\n         T: AsRawFd,\n     {\n"}
{"instance_id": "clap-rs__clap-1710", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/parse/parser.rs b/src/parse/parser.rs\nindex 89a39a08..9643ad8e 100644\n--- a/src/parse/parser.rs\n+++ b/src/parse/parser.rs\n@@ -739,11 +739,14 @@ where\n                         self.app.color(),\n                     ));\n                 } else {\n-                    return Err(ClapError::unrecognized_subcommand(\n-                        arg_os.to_string_lossy().into_owned(),\n-                        self.app.bin_name.as_ref().unwrap_or(&self.app.name),\n-                        self.app.color(),\n-                    ));\n+                    // If inference enabled, attempt suggestion/ambiguous listing\n+                    match self.possible_subcommand(arg_os) {\n+                        Ok((sc, _)) => {\n+                            // Found unique inference: recurse into subcommand parsing\n+                            return self.parse_subcommand(sc, it)?; \n+                        }\n+                        Err(err) => return Err(err),\n+                    }\n                 }\n             } else {\n                 return Err(ClapError::unknown_argument(\n@@ -860,11 +863,14 @@ where\n                         break;\n                     }\n                 } else {\n-                    return Err(ClapError::unrecognized_subcommand(\n-                        cmd.to_string_lossy().into_owned(),\n-                        self.app.bin_name.as_ref().unwrap_or(&self.app.name),\n-                        self.app.color(),\n-                    ));\n+                    // Help subcommand parse: handle inferred or ambiguous prefixes\n+                    match self.possible_subcommand(cmd) {\n+                        Ok((sc, _)) => {\n+                            // Found unique inference: display help for that subcommand\n+                            return self.print_help_for_subcommand(sc);\n+                        }\n+                        Err(err) => return Err(err),\n+                    }\n                 }\n \n                 bin_name = format!(\"{} {}\", bin_name, &*sc.name);\n"}
{"instance_id": "biomejs__biome-2250", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_analyze/src/utils.rs b/crates/biome_js_analyze/src/utils.rs\nindex fb55f75e29..6e17d4f9a9 100644\n--- a/crates/biome_js_analyze/src/utils.rs\n+++ b/crates/biome_js_analyze/src/utils.rs\n@@ -99,14 +99,16 @@ pub(crate) fn find_variable_position(\n         .filter_map(AnyJsExpression::cast)\n         .map(|child| child.omit_parentheses())\n         .filter(|child| child.syntax().text_trimmed() == variable)\n-        .map(|child| {\n-            if child.syntax().text_trimmed_range().end() < operator_range.start() {\n-                return VariablePosition::Left;\n-            } else if operator_range.end() < child.syntax().text_trimmed_range().start() {\n-                return VariablePosition::Right;\n+        .filter_map(|child| {\n+            let range = child.syntax().text_trimmed_range();\n+            if range.end() <= operator_range.start() {\n+                Some(VariablePosition::Left)\n+            } else if operator_range.end() <= range.start() {\n+                Some(VariablePosition::Right)\n+            } else {\n+                // Overlapping or otherwise ambiguous\u2014skip rather than panic\n+                None\n             }\n-\n-            unreachable!(\"The node can't have the same range of the operator.\")\n         })\n         .next()\n }\n"}
{"instance_id": "clap-rs__clap-3453", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/arg.rs b/src/build/arg.rs\nindex 499eade3..dae58eba 100644\n--- a/src/build/arg.rs\n+++ b/src/build/arg.rs\n@@ -116,12 +116,14 @@ impl<'help> Arg<'help> {\n     /// Set the identifier used for referencing this argument in the clap API.\n     ///\n     /// See [`Arg::new`] for more details.\n+    /// **Deprecated:** use `.id(...)` to override the internal argument identifier.\n+    /// `.name(...)` now only sets the *value* placeholder, identical to `.value_name(...)`.\n+    #[deprecated(note = \"Use `Arg::id(...)` to set the internal identifier; `name(...)` now sets only the value placeholder.\")]\n     #[must_use]\n-    pub fn name<S: Into<&'help str>>(mut self, n: S) -> Self {\n+    pub fn name<S: Into<&'help str>>(self, n: S) -> Self {\n         let name = n.into();\n-        self.id = Id::from(&*name);\n-        self.name = name;\n-        self\n+        // Only set the user\u2010facing placeholder, not the internal id.\n+        self.value_name(name)\n     }\n \n     /// Sets the short version of the argument without the preceding `-`.\n"}
{"instance_id": "rust-lang__chalk-55", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/fold/mod.rs b/src/fold/mod.rs\nindex b952acc7..e3d33335 100644\n--- a/src/fold/mod.rs\n+++ b/src/fold/mod.rs\n@@ -15,6 +15,25 @@ pub use self::instantiate::Subst;\n pub trait Folder {\n     fn fold_free_var(&mut self, depth: usize, binders: usize) -> Result<Ty>;\n     fn fold_free_lifetime_var(&mut self, depth: usize, binders: usize) -> Result<Lifetime>;\n+\n+    /// Callback invoked when folding a free \u201ckrate\u201d variable\n+    /// (i.e., a `Krate` that lives outside any binders).\n+    /// By default, it just returns `Krate::Var(depth)`.\n+    fn fold_free_krate_var(&mut self, depth: usize, binders: usize) -> Result<Krate> {\n+        Ok(Krate::Var(depth))\n+    }\n+\n+    /// Entry-point for folding an arbitrary type.  The default\n+    /// just calls `ty.fold_with(self, binders)`.\n+    fn fold_ty(&mut self, ty: &Ty, binders: usize) -> Result<Ty> {\n+        ty.fold_with(self, binders)\n+    }\n+\n+    /// Entry-point for folding an arbitrary lifetime.  The default\n+    /// just calls `lifetime.fold_with(self, binders)`.\n+    fn fold_lifetime(&mut self, lifetime: &Lifetime, binders: usize) -> Result<Lifetime> {\n+        lifetime.fold_with(self, binders)\n+    }\n }\n \n impl<'f, F: Folder + ?Sized> Folder for &'f mut F {\n"}
{"instance_id": "clap-rs__clap-2701", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/arg/mod.rs b/src/build/arg/mod.rs\nindex 1db343fe..598c556b 100644\n--- a/src/build/arg/mod.rs\n+++ b/src/build/arg/mod.rs\n@@ -4656,8 +4656,11 @@ impl<'help> Arg<'help> {\n     // Used for positionals when printing\n     pub(crate) fn multiple_str(&self) -> &str {\n         let mult_vals = self.val_names.len() > 1;\n-        if (self.is_set(ArgSettings::MultipleValues)\n-            || self.is_set(ArgSettings::MultipleOccurrences))\n+        // Only show \"...\" for truly unbounded values:\n+        //  1) unlimited occurrences\n+        //  2) unlimited values (MultipleValues with no fixed num_vals)\n+        if ((self.is_set(ArgSettings::MultipleOccurrences))\n+            || (self.is_set(ArgSettings::MultipleValues) && self.num_vals.is_none()))\n             && !mult_vals\n         {\n             \"...\"\n"}
{"instance_id": "sharkdp__fd-986", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/app.rs b/src/app.rs\nindex 01ddc1d..39d79a3 100644\n--- a/src/app.rs\n+++ b/src/app.rs\n@@ -101,13 +101,24 @@ pub fn build_app() -> Command<'static> {\n             Arg::new(\"rg-alias-hidden-ignore\")\n                 .short('u')\n                 .long(\"unrestricted\")\n-                .overrides_with_all(&[\"ignore\", \"no-hidden\"])\n-                .multiple_occurrences(true)\n+                // Override all filter-related flags so -u disables every filter exactly once\n+                .overrides_with_all(&[\n+                    \"ignore\",\n+                    \"hidden\",\n+                    \"ignore-vcs\",\n+                    \"no-ignore-parent\",\n+                    \"no-global-ignore-file\",\n+                ])\n                 .hide_short_help(true)\n-                .help(\"Alias for '--no-ignore', and '--hidden' when given twice\")\n-                .long_help(\n-                    \"Alias for '--no-ignore'. Can be repeated. '-uu' is an alias for \\\n-                         '--no-ignore --hidden'.\",\n+                .help(\"Do not apply any ignore or filtering rules (equivalent to -I -H --no-ignore-vcs --no-ignore-parent --no-global-ignore-file)\")\n+                .long_help(\n+                    \"Disable all built-in ignore and filter rules:\\n\\n\\\n+                     \u2022 ignore files (.ignore, .fdignore, .gitignore)\\n\\\n+                     \u2022 hidden files and directories\\n\\\n+                     \u2022 VCS ignore rules\\n\\\n+                     \u2022 parent-directory ignore files\\n\\\n+                     \u2022 global ignore file\\n\\n\\\n+                     Any other filters configured by default will also be bypassed.\",\n                 ),\n         )\n         .arg(\n"}
{"instance_id": "rust-lang__cc-rs-167", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 7d19e13..95dddde 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -543,6 +543,8 @@ impl Config {\n     pub fn get_compiler(&self) -> Tool {\n         let opt_level = self.get_opt_level();\n         let target = self.get_target();\n+        // Only link fully static on musl when crt-static is requested by Cargo\n+        let target_features = env::var(\"CARGO_CFG_TARGET_FEATURE\").unwrap_or_default();\n \n         let mut cmd = self.get_base_compiler();\n         let nvcc = cmd.path.file_name()\n@@ -618,7 +620,8 @@ impl Config {\n                     cmd.args.push(\"-m64\".into());\n                 }\n \n-                if target.contains(\"musl\") {\n+                // Only add -static on musl if Cargo requested crt-static\n+                if target.contains(\"musl\") && target_features.contains(\"crt-static\") {\n                     cmd.args.push(\"-static\".into());\n                 }\n \n"}
{"instance_id": "clap-rs__clap-2804", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/arg/debug_asserts.rs b/src/build/arg/debug_asserts.rs\nindex 9ef5bc81..9adb4dfc 100644\n--- a/src/build/arg/debug_asserts.rs\n+++ b/src/build/arg/debug_asserts.rs\n@@ -35,11 +35,12 @@ pub(crate) fn assert_arg(arg: &Arg) {\n         );\n     }\n \n-    // Positionals should not have multiple_occurrences\n+    // Positionals should not have multiple_occurrences unless they also allow multiple values\n     if arg.is_positional() {\n         assert!(\n-            !arg.is_set(ArgSettings::MultipleOccurrences),\n-            \"Argument '{}' is a positional argument and can't be set as multiple occurrences\",\n+            !(arg.is_set(ArgSettings::MultipleOccurrences) \n+              && !arg.is_set(ArgSettings::MultipleValues)),\n+            \"Argument '{}' is a positional argument and can't be set as multiple occurrences without multiple values (e.g., via number_of_values)\",\n             arg.name\n         );\n     }\n"}
{"instance_id": "boa-dev__boa-485", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/exec/mod.rs b/boa/src/exec/mod.rs\nindex 37fea703..76c4acdf 100644\n--- a/boa/src/exec/mod.rs\n+++ b/boa/src/exec/mod.rs\n@@ -381,9 +381,14 @@ impl Interpreter {\n     #[allow(clippy::wrong_self_convention)]\n     pub(crate) fn to_object(&mut self, value: &Value) -> ResultValue {\n         match value.data() {\n-            ValueData::Undefined | ValueData::Integer(_) | ValueData::Null => {\n+            ValueData::Undefined | ValueData::Null => {\n                 Err(Value::undefined())\n             }\n+            ValueData::Integer(n) => {\n+                let number_constructor = context.global_object().constructors().number().constructor();\n+                let value = Value::from(*n);\n+                self.construct(number_constructor, &[value])\n+            }\n             ValueData::Boolean(_) => {\n                 let proto = self\n                     .realm\n"}
{"instance_id": "tokio-rs__axum-412", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/routing/mod.rs b/src/routing/mod.rs\nindex 3a6403ad..b2dbd32d 100644\n--- a/src/routing/mod.rs\n+++ b/src/routing/mod.rs\n@@ -52,6 +52,22 @@ impl RouteId {\n     }\n }\n \n+use std::sync::Arc;\n+\n+/// Extension for storing the matched route path pattern.\n+///\n+/// After routing, the chosen route\u2019s template (e.g. \"/api/hello/:name\")\n+/// will be inserted under this key.\n+#[derive(Clone, Debug)]\n+pub struct MatchedPathPattern(pub Arc<str>);\n+\n+impl MatchedPathPattern {\n+    /// Get the pattern string.\n+    pub fn as_str(&self) -> &str {\n+        &self.0\n+    }\n+}\n+\n /// The router type for composing handlers and services.\n pub struct Router<B = Body> {\n     routes: HashMap<RouteId, Route<B>>,\n@@ -786,7 +802,15 @@ where\n         let path = req.uri().path().to_string();\n \n         match self.node.at(&path) {\n-            Ok(match_) => self.call_route(match_, req),\n+            Ok(match_) => {\n+                // Store the matched route pattern in request extensions\n+                if let Some((pattern, &id)) =\n+                    self.node.paths.iter().find(|(_, &id)| id == *match_.value)\n+                {\n+                    req.extensions_mut().insert(MatchedPathPattern(pattern.clone()));\n+                }\n+                self.call_route(match_, req)\n+            }\n             Err(err) => {\n                 if err.tsr()\n                     // workaround for https://github.com/ibraheemdev/matchit/issues/7\n"}
{"instance_id": "biomejs__biome-3304", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_css_analyze/src/suppression_action.rs b/crates/biome_css_analyze/src/suppression_action.rs\nindex 40c99cf98e..d2d62d6fb7 100644\n--- a/crates/biome_css_analyze/src/suppression_action.rs\n+++ b/crates/biome_css_analyze/src/suppression_action.rs\n@@ -9,18 +9,35 @@ impl SuppressionAction for CssSuppressionAction {\n \n     fn find_token_to_apply_suppression(\n         &self,\n-        _original_token: SyntaxToken<Self::Language>,\n+        original_token: SyntaxToken<Self::Language>,\n     ) -> Option<ApplySuppression<Self::Language>> {\n-        // TODO: property implement. Look for the JsSuppressionAction for an example\n-        None\n+        // for now, always attach the suppression directly to the token\n+        Some(ApplySuppression {\n+            token_to_apply_suppression: original_token,\n+            token_has_trailing_comments: false,\n+            should_insert_leading_newline: false,\n+        })\n     }\n \n     fn apply_suppression(\n         &self,\n-        _mutation: &mut BatchMutation<Self::Language>,\n-        _apply_suppression: ApplySuppression<Self::Language>,\n-        _suppression_text: &str,\n+        mutation: &mut BatchMutation<Self::Language>,\n+        apply_suppression: ApplySuppression<Self::Language>,\n+        suppression_text: &str,\n     ) {\n-        unreachable!(\"find_token_to_apply_suppression return None\")\n+        // figure out where the token actually starts (trimmed)\n+        let range = apply_suppression\n+            .token_to_apply_suppression\n+            .text_trimmed_range();\n+\n+        // build a /* \u2026 */ comment\n+        let comment = format!(\"/* {} */ \", suppression_text);\n+\n+        // insert it immediately before the token\n+        mutation.insert(\n+            TextSize::from(range.start()),\n+            Mode::Before,\n+            comment,\n+        );\n     }\n }\n"}
{"instance_id": "tokio-rs__tokio-6339", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio-macros/src/select.rs b/tokio-macros/src/select.rs\nindex 324b8f94..43a9bee0 100644\n--- a/tokio-macros/src/select.rs\n+++ b/tokio-macros/src/select.rs\n@@ -30,16 +30,29 @@ pub(crate) fn declare_output_enum(input: TokenStream) -> TokenStream {\n         Span::call_site(),\n     );\n \n-    TokenStream::from(quote! {\n-        pub(super) enum Out<#( #variants ),*> {\n-            #( #variants(#variants), )*\n-            // Include a `Disabled` variant signifying that all select branches\n-            // failed to resolve.\n-            Disabled,\n-        }\n+    // Special-case zero-branch: emit a non-generic enum with only Disabled.\n+    if variants.is_empty() {\n+        TokenStream::from(quote! {\n+            pub(super) enum Out {\n+                // Include a `Disabled` variant signifying that all select branches\n+                // failed to resolve.\n+                Disabled,\n+            }\n \n-        pub(super) type Mask = #mask;\n-    })\n+            pub(super) type Mask = #mask;\n+        })\n+    } else {\n+        TokenStream::from(quote! {\n+            pub(super) enum Out<#( #variants ),*> {\n+                #( #variants(#variants), )*\n+                // Include a `Disabled` variant signifying that all select branches\n+                // failed to resolve.\n+                Disabled,\n+            }\n+\n+            pub(super) type Mask = #mask;\n+        })\n+    }\n }\n \n pub(crate) fn clean_pattern_macro(input: TokenStream) -> TokenStream {\n"}
{"instance_id": "bevyengine__bevy-8040", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_render/src/color/mod.rs b/crates/bevy_render/src/color/mod.rs\nindex 770a7bee9..361e982fc 100644\n--- a/crates/bevy_render/src/color/mod.rs\n+++ b/crates/bevy_render/src/color/mod.rs\n@@ -525,7 +525,7 @@ impl Color {\n                 let [red, green, blue] =\n                     LchRepresentation::lch_to_nonlinear_srgb(*lightness, *chroma, *hue);\n \n-                Color::Rgba {\n+                Color::RgbaLinear {\n                     red: red.nonlinear_to_linear_srgb(),\n                     green: green.nonlinear_to_linear_srgb(),\n                     blue: blue.nonlinear_to_linear_srgb(),\n"}
{"instance_id": "killercup__cargo-edit-558", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bin/add/main.rs b/src/bin/add/main.rs\nindex 4063b7db..f3fa3116 100644\n--- a/src/bin/add/main.rs\n+++ b/src/bin/add/main.rs\n@@ -69,11 +69,14 @@ mod errors {\n use crate::errors::*;\n \n fn print_msg(dep: &Dependency, section: &[String], optional: bool) -> Result<()> {\n+    #[cfg(feature = \"atty\")]\n     let colorchoice = if atty::is(atty::Stream::Stdout) {\n         ColorChoice::Auto\n     } else {\n         ColorChoice::Never\n     };\n+    #[cfg(not(feature = \"atty\"))]\n+    let colorchoice = ColorChoice::Never;\n     let mut output = StandardStream::stderr(colorchoice);\n     output.set_color(ColorSpec::new().set_fg(Some(Color::Green)).set_bold(true))?;\n     write!(output, \"{:>12}\", \"Adding\")?;\ndiff --git a/src/bin/rm/main.rs b/src/bin/rm/main.rs\nindex f65d9d35..cf907274 100644\n--- a/src/bin/rm/main.rs\n+++ b/src/bin/rm/main.rs\n@@ -94,11 +94,14 @@ impl Args {\n }\n \n fn print_msg(name: &str, section: &str) -> Result<()> {\n+    #[cfg(feature = \"atty\")]\n     let colorchoice = if atty::is(atty::Stream::Stdout) {\n         ColorChoice::Auto\n     } else {\n         ColorChoice::Never\n     };\n+    #[cfg(not(feature = \"atty\"))]\n+    let colorchoice = ColorChoice::Never;\n     let mut output = StandardStream::stderr(colorchoice);\n     output.set_color(ColorSpec::new().set_fg(Some(Color::Green)).set_bold(true))?;\n     write!(output, \"{:>12}\", \"Removing\")?;\ndiff --git a/src/fetch.rs b/src/fetch.rs\nindex 5ed28cdc..96c63887 100644\n--- a/src/fetch.rs\n+++ b/src/fetch.rs\n@@ -217,11 +217,14 @@ pub fn get_features_from_registry(\n \n /// update registry index for given project\n pub fn update_registry_index(registry: &Url, quiet: bool) -> Result<()> {\n+    #[cfg(feature = \"atty\")]\n     let colorchoice = if atty::is(atty::Stream::Stdout) {\n         ColorChoice::Auto\n     } else {\n         ColorChoice::Never\n     };\n+    #[cfg(not(feature = \"atty\"))]\n+    let colorchoice = ColorChoice::Never;\n     let mut output = StandardStream::stderr(colorchoice);\n \n     let mut index = crates_index::Index::from_url(registry.as_str())?;\n"}
{"instance_id": "tokio-rs__tokio-6280", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/task/join_set.rs b/tokio/src/task/join_set.rs\nindex 4eb15a24..4ef4c9ff 100644\n--- a/tokio/src/task/join_set.rs\n+++ b/tokio/src/task/join_set.rs\n@@ -284,6 +284,26 @@ impl<T: 'static> JoinSet<T> {\n         crate::future::poll_fn(|cx| self.poll_join_next(cx)).await\n     }\n \n+    /// Attempts to retrieve the next completed task without waiting.\n+    ///\n+    /// If a task has already finished, it is removed from the set and the\n+    /// output (or error) is returned immediately. If there is no ready task\n+    /// (or the set is empty), returns `None`.\n+    pub fn try_join_next(&mut self) -> Option<Result<T, JoinError>> {\n+        // Try to pop a notified entry without registering a waker.\n+        let mut entry = self.inner.try_pop_notified()?;\n+        // Poll it once.\n+        let res = entry.with_value_and_context(|jh, cx| Pin::new(jh).poll(cx));\n+        if let Poll::Ready(res) = res {\n+            // Remove and return.\n+            let _ = entry.remove();\n+            Some(res)\n+        } else {\n+            // Unexpected: we popped a notified item but it's not ready.\n+            None\n+        }\n+    }\n+\n     /// Waits until one of the tasks in the set completes and returns its\n     /// output, along with the [task ID] of the completed task.\n     ///\ndiff --git a/tokio/src/util/idle_notified_set.rs b/tokio/src/util/idle_notified_set.rs\nindex 430f2e75..f8e9a5f7 100644\n--- a/tokio/src/util/idle_notified_set.rs\n+++ b/tokio/src/util/idle_notified_set.rs\n@@ -203,6 +203,32 @@ impl<T> IdleNotifiedSet<T> {\n         Some(EntryInOneOfTheLists { entry, set: self })\n     }\n \n+    /// Attempts to pop a notified entry without registering or updating any waker.\n+    /// The entry is moved to the idle list, but no waker is touched.\n+    pub(crate) fn try_pop_notified(&mut self) -> Option<EntryInOneOfTheLists<'_, T>> {\n+        // Fast path: empty set.\n+        if self.length == 0 {\n+            return None;\n+        }\n+\n+        let mut lock = self.lists.lock();\n+\n+        // Pop the entry if available.\n+        let entry = lock.notified.pop_back()?;\n+\n+        // Move to idle list.\n+        lock.idle.push_front(entry.clone());\n+\n+        // Safety: We hold the lock.\n+        unsafe {\n+            entry.my_list.with_mut(|ptr| *ptr = List::Idle);\n+        }\n+\n+        drop(lock);\n+\n+        Some(EntryInOneOfTheLists { entry, set: self })\n+    }\n+\n     /// Call a function on every element in this list.\n     pub(crate) fn for_each<F: FnMut(&mut T)>(&mut self, mut func: F) {\n         fn get_ptrs<T>(list: &mut LinkedList<T>, ptrs: &mut Vec<*mut T>) {\n"}
{"instance_id": "starkware-libs__cairo-6649", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/cairo-lang-language-server/src/ide/hover/mod.rs b/crates/cairo-lang-language-server/src/ide/hover/mod.rs\nindex 9d27b1378..9d94e3fc9 100644\n--- a/crates/cairo-lang-language-server/src/ide/hover/mod.rs\n+++ b/crates/cairo-lang-language-server/src/ide/hover/mod.rs\n@@ -24,6 +24,17 @@ pub fn hover(params: HoverParams, db: &AnalysisDatabase) -> Option<Hover> {\n         return Some(hover);\n     }\n \n+    // --- new: handle hovering over individual path segments (e.g. in `use`/import)\n+    if let Some(seg_node) = db\n+        .find_syntax_node_at_position(file_id, position)\n+        .and_then(|node| ast::PathSegment::cast(node.clone()))\n+    {\n+        // attempt to resolve this segment\u2019s definition (module/item) and show hover\n+        if let Some(hover) = render::definition_path_segment(db, &seg_node, file_id) {\n+            return Some(hover);\n+        }\n+    }\n+\n     None\n \n     // TODO(mkaput): If client only supports plaintext, strip markdown formatting here like RA.\n"}
{"instance_id": "tokio-rs__tokio-6742", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/runtime/builder.rs b/tokio/src/runtime/builder.rs\nindex 16be7709..b17b672b 100644\n--- a/tokio/src/runtime/builder.rs\n+++ b/tokio/src/runtime/builder.rs\n@@ -642,38 +642,39 @@ impl Builder {\n         self\n     }\n \n-    /// Executes function `f` just after a thread unparks (starts executing tasks).\n+    /// Execute `wrapper` on each spawned task future before it is scheduled.\n     ///\n-    /// This is intended for bookkeeping and monitoring use cases; note that work\n-    /// in this callback will increase latencies when the application has allowed one or\n-    /// more runtime threads to go idle.\n-    ///\n-    /// Note: There can only be one unpark callback for a runtime; calling this function\n-    /// more than once replaces the last callback defined, rather than adding to it.\n+    /// The wrapper is handed the boxed future; its returned future is\n+    /// then what actually gets spawned.  This allows instrumentation or\n+    /// per-task-lifecycle hooks (creation, polling, drop, etc.).\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # use tokio::runtime;\n-    /// # pub fn main() {\n-    /// let runtime = runtime::Builder::new_multi_thread()\n-    ///     .on_thread_unpark(|| {\n-    ///         println!(\"thread unparking\");\n+    /// use tokio::runtime::Builder;\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    ///\n+    /// // A simple wrapper that logs when a task is dropped.\n+    /// fn logger<F>(fut: Pin<Box<dyn Future<Output = ()> + Send + 'static>>)\n+    ///     -> Pin<Box<dyn Future<Output = ()> + Send + 'static>>\n+    /// {\n+    ///     Box::pin(async move {\n+    ///         let __guard = DropGuard(|| println!(\"task ended\"));\n+    ///         fut.await;\n     ///     })\n-    ///     .build();\n+    /// }\n     ///\n-    /// runtime.unwrap().block_on(async {\n-    ///    tokio::task::yield_now().await;\n-    ///    println!(\"Hello from Tokio!\");\n-    /// })\n-    /// # }\n+    /// let rt = Builder::new_multi_thread()\n+    ///     .on_spawn(logger)\n+    ///     .build()\n+    ///     .unwrap();\n     /// ```\n-    #[cfg(not(loom))]\n-    pub fn on_thread_unpark<F>(&mut self, f: F) -> &mut Self\n+    pub fn on_spawn<F>(&mut self, wrapper: F) -> &mut Self\n     where\n-        F: Fn() + Send + Sync + 'static,\n+        F: Fn(crate::util::future::BoxFuture<()>) -> crate::util::future::BoxFuture<()> + Send + Sync + 'static,\n     {\n-        self.after_unpark = Some(std::sync::Arc::new(f));\n+        self.on_spawn = Some(std::sync::Arc::new(wrapper));\n         self\n     }\n \n"}
{"instance_id": "cargo-generate__cargo-generate-677", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/args.rs b/src/args.rs\nindex cf024ba..7214e79 100644\n--- a/src/args.rs\n+++ b/src/args.rs\n@@ -77,8 +77,9 @@ pub struct GenerateArgs {\n     pub config: Option<PathBuf>,\n \n     /// Specify the VCS used to initialize the generated template.\n-    #[clap(long, default_value = \"git\", value_parser)]\n-    pub vcs: Vcs,\n+    /// If omitted, we will respect a `default_vcs` in the template; otherwise we fall back to \"git\".\n+    #[clap(long, value_parser)]\n+    pub vcs: Option<Vcs>,\n \n     /// Populates a template variable `crate_type` with value `\"lib\"`\n     #[clap(long, conflicts_with = \"bin\", action)]\n"}
{"instance_id": "bevyengine__bevy-15398", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_ecs/src/entity/mod.rs b/crates/bevy_ecs/src/entity/mod.rs\nindex 3ad78f73a..1edc32854 100644\n--- a/crates/bevy_ecs/src/entity/mod.rs\n+++ b/crates/bevy_ecs/src/entity/mod.rs\n@@ -714,9 +714,11 @@ impl Entities {\n \n     /// Destroy an entity, allowing it to be reused.\n     ///\n-    /// Must not be called while reserved entities are awaiting `flush()`.\n+    /// Spawning new entities in an `OnRemove` observer may create pending reservations,\n+    /// so we no longer enforce \u201cmust flush\u201d here.\n     pub fn free(&mut self, entity: Entity) -> Option<EntityLocation> {\n-        self.verify_flushed();\n+        // skip the flush-check to avoid panics when an observer spawns entities\n+        // self.verify_flushed();\n \n         let meta = &mut self.meta[entity.index() as usize];\n         if meta.generation != entity.generation {\n"}
{"instance_id": "sharkdp__fd-1394", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/cli.rs b/src/cli.rs\nindex a60260e..1019420 100644\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -26,7 +26,7 @@ use crate::filter::SizeFilter;\n     max_term_width = 98,\n     args_override_self = true,\n     group(ArgGroup::new(\"execs\").args(&[\"exec\", \"exec_batch\", \"list_details\"]).conflicts_with_all(&[\n-            \"max_results\", \"has_results\", \"count\"])),\n+            \"max_results\", \"max_one_result\", \"has_results\", \"count\"])),\n )]\n pub struct Opts {\n     /// Include hidden directories and files in the search results (default:\n"}
{"instance_id": "tokio-rs__bytes-721", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes.rs b/src/bytes.rs\nindex e0c33b3..c6d797f 100644\n--- a/src/bytes.rs\n+++ b/src/bytes.rs\n@@ -531,6 +531,26 @@ impl Bytes {\n         }\n     }\n \n+    /// Convert this `Bytes` into a `BytesMut`, preserving zero\u2010copy when\n+    /// uniquely owned and otherwise performing a copy.\n+    ///\n+    /// This is simply `BytesMut::from(self)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use bytes::{Bytes, BytesMut};\n+    ///\n+    /// let bytes = Bytes::from(b\"world\".to_vec());\n+    /// let mut buf: BytesMut = bytes.into_mut();\n+    /// assert_eq!(&buf[..], b\"world\");\n+    /// ```\n+    #[inline]\n+    pub fn into_mut(self) -> BytesMut {\n+        // Delegate to the existing `From<Bytes> for BytesMut` impl\n+        self.into()\n+    }\n+\n     #[inline]\n     pub(crate) unsafe fn with_vtable(\n         ptr: *const u8,\n"}
{"instance_id": "clap-rs__clap-3169", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/clap_generate/src/generators/shells/fish.rs b/clap_generate/src/generators/shells/fish.rs\nindex fdeaf12d..3c350029 100644\n--- a/clap_generate/src/generators/shells/fish.rs\n+++ b/clap_generate/src/generators/shells/fish.rs\n@@ -97,7 +97,7 @@ fn gen_fish_inner(root_command: &str, parent_commands: &[&str], app: &App, buffe\n         buffer.push('\\n');\n     }\n \n-    for flag in utils::flags(app) {\n+    for flag in utils::flags(app).filter(|flag| !flag.is_hide_set()) {\n         let mut template = basic_template.clone();\n \n         if let Some(shorts) = flag.get_short_and_visible_aliases() {\n@@ -120,22 +120,22 @@ fn gen_fish_inner(root_command: &str, parent_commands: &[&str], app: &App, buffe\n         buffer.push('\\n');\n     }\n \n-    for subcommand in app.get_subcommands() {\n+    for subcommand in app.get_subcommands().filter(|sc| !sc.is_hide_set()) {\n         let mut template = basic_template.clone();\n-\n+    \n         template.push_str(\" -f\");\n         template.push_str(format!(\" -a \\\"{}\\\"\", &subcommand.get_name()).as_str());\n-\n+    \n         if let Some(data) = subcommand.get_about() {\n             template.push_str(format!(\" -d '{}'\", escape_string(data)).as_str())\n         }\n-\n+    \n         buffer.push_str(template.as_str());\n         buffer.push('\\n');\n     }\n \n     // generate options of subcommands\n-    for subcommand in app.get_subcommands() {\n+    for subcommand in app.get_subcommands().filter(|sc| !sc.is_hide_set()) {\n         let mut parent_commands: Vec<_> = parent_commands.into();\n         parent_commands.push(subcommand.get_name());\n         gen_fish_inner(root_command, &parent_commands, subcommand, buffer);\n"}
{"instance_id": "boa-dev__boa-235", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/syntax/lexer.rs b/src/lib/syntax/lexer.rs\nindex a512c8fa..7b6e3a14 100644\n--- a/src/lib/syntax/lexer.rs\n+++ b/src/lib/syntax/lexer.rs\n@@ -416,8 +416,15 @@ impl<'a> Lexer<'a> {\n                                     break 'digitloop;\n                                 }\n                             },\n-                            'e' | '+' | '-' => {\n+                            'e' => {\n+                                // consume the exponent marker\n                                 buf.push(self.next());\n+                                // optional '+' or '-' as exponent sign\n+                                if let Some(sign) = self.preview_next() {\n+                                    if sign == '+' || sign == '-' {\n+                                        buf.push(self.next());\n+                                    }\n+                                }\n                             }\n                             _ if ch.is_digit(10) => {\n                                 buf.push(self.next());\n"}
{"instance_id": "clap-rs__clap-3670", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/output/usage.rs b/src/output/usage.rs\nindex 45cfa746..46dbecde 100644\n--- a/src/output/usage.rs\n+++ b/src/output/usage.rs\n@@ -433,7 +433,7 @@ impl<'help, 'cmd> Usage<'help, 'cmd> {\n             .filter_map(|pos| self.cmd.find(pos))\n             .filter(|&pos| incl_last || !pos.is_last_set())\n             .filter(|pos| !args_in_groups.contains(&pos.id))\n-            .map(|pos| (pos.index.unwrap(), pos))\n+            .filter_map(|pos| pos.index.map(|idx| (idx, pos)))\n             .collect::<Vec<(usize, &Arg)>>();\n         pvec.sort_by_key(|(ind, _)| *ind); // sort by index\n \n"}
{"instance_id": "tokio-rs__tracing-1252", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tracing/src/span.rs b/tracing/src/span.rs\nindex 0a86ca84..d0f50ba6 100644\n--- a/tracing/src/span.rs\n+++ b/tracing/src/span.rs\n@@ -382,6 +382,21 @@ pub struct Entered<'a> {\n     _not_send: PhantomData<*mut ()>,\n }\n \n+/// An owned guard returned by `Span::enter_owned`.\n+/// When dropped, this guard exits the span. Unlike `Entered<'_>`,\n+/// it owns a `Span` and is `Send + 'static`, so it may be held\n+/// across await points or moved to another thread.\n+#[derive(Debug)]\n+pub struct OwnedEntered(pub Span);\n+\n+impl Drop for OwnedEntered {\n+    fn drop(&mut self) {\n+        if let Some(ref inner) = self.0.inner {\n+            inner.collector.exit(&inner.id);\n+        }\n+    }\n+}\n+\n /// `log` target for all span lifecycle (creation/enter/exit/close) records.\n #[cfg(feature = \"log\")]\n const LIFECYCLE_LOG_TARGET: &str = \"tracing::span\";\n@@ -815,6 +830,29 @@ impl Span {\n         let _enter = self.enter();\n         f()\n     }\n+    \n+    /// Enters this span and returns an owned, `Send`-able guard that will\n+    /// exit the span when dropped, even across `.await` or on another thread.\n+    pub fn enter_owned(&self) -> OwnedEntered {\n+        if let Some(ref inner) = self.inner {\n+            inner.collector.enter(&inner.id);\n+        }\n+        OwnedEntered(self.clone())\n+    }\n+    \n+    /// Manually emits an \u201center\u201d event for this span without returning a guard.\n+    pub fn emit_enter(&self) {\n+        if let Some(ref inner) = self.inner {\n+            inner.collector.enter(&inner.id);\n+        }\n+    }\n+    \n+    /// Manually emits a \u201cleave\u201d event for this span without requiring a guard.\n+    pub fn emit_exit(&self) {\n+        if let Some(ref inner) = self.inner {\n+            inner.collector.exit(&inner.id);\n+        }\n+    }\n \n     /// Returns a [`Field`](super::field::Field) for the field with the\n     /// given `name`, if one exists,\n"}
{"instance_id": "async-graphql__async-graphql-1099", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/http/graphiql_v2_source.rs b/src/http/graphiql_v2_source.rs\nindex 3f4cb8b3..12615f0d 100644\n--- a/src/http/graphiql_v2_source.rs\n+++ b/src/http/graphiql_v2_source.rs\n@@ -18,6 +18,8 @@ pub struct GraphiQLSource<'a> {\n     endpoint: &'a str,\n     subscription_endpoint: Option<&'a str>,\n     headers: Option<HashMap<&'a str, &'a str>>,\n+    /// Optional HTML document title\n+    title: Option<&'a str>,\n }\n \n impl<'a> GraphiQLSource<'a> {\n@@ -53,6 +55,15 @@ impl<'a> GraphiQLSource<'a> {\n         }\n     }\n \n+    /// Sets the HTML document title for the GraphiQL (v2) page.\n+    #[must_use]\n+    pub fn title(self, title: &'a str) -> GraphiQLSource<'a> {\n+        GraphiQLSource {\n+            title: Some(title),\n+            ..self\n+        }\n+    }\n+\n     /// Returns a GraphiQL (v2) HTML page.\n     pub fn finish(self) -> String {\n         let graphiql_url = format!(\"'{}'\", self.endpoint);\n"}
{"instance_id": "boa-dev__boa-1312", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/syntax/ast/node/statement_list/mod.rs b/boa/src/syntax/ast/node/statement_list/mod.rs\nindex 9f7b4eaf..1415c0f8 100644\n--- a/boa/src/syntax/ast/node/statement_list/mod.rs\n+++ b/boa/src/syntax/ast/node/statement_list/mod.rs\n@@ -48,7 +48,18 @@ impl StatementList {\n             node.display(f, indentation + 1)?;\n \n             match node {\n-                Node::Block(_) | Node::If(_) | Node::Switch(_) | Node::WhileLoop(_) => {}\n+                // these nodes emit their own brace/terminator, so no extra semicolon:\n+                Node::Block(_)\n+              | Node::If(_)\n+              | Node::Switch(_)\n+              | Node::WhileLoop(_)\n+              | Node::DoWhileLoop(_)\n+              | Node::ForLoop(_)\n+              | Node::ForInLoop(_)\n+              | Node::ForOfLoop(_)\n+              | Node::Try(_)\n+              | Node::FunctionDecl(_)\n+              => {}\n                 _ => write!(f, \";\")?,\n             }\n             writeln!(f)?;\n"}
{"instance_id": "aya-rs__aya-897", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/aya-bpf-macros/src/cgroup_skb.rs b/aya-bpf-macros/src/cgroup_skb.rs\nindex 15b5a122..5b90e7aa 100644\n--- a/aya-bpf-macros/src/cgroup_skb.rs\n+++ b/aya-bpf-macros/src/cgroup_skb.rs\n@@ -26,10 +26,11 @@ impl CgroupSkb {\n     }\n \n     pub(crate) fn expand(&self) -> Result<TokenStream> {\n-        let section_name: Cow<'_, _> = if self.attach_type.is_some() {\n-            format!(\"cgroup_skb/{}\", self.attach_type.as_ref().unwrap()).into()\n+        let section_name: Cow<'_, _> = if let Some(ref t) = self.attach_type {\n+            format!(\"cgroup_skb/{}\", t).into()\n         } else {\n-            \"cgroup_skb\".into()\n+            // default to ingress if no attach type is specified\n+            \"cgroup_skb/ingress\".into()\n         };\n         let fn_vis = &self.item.vis;\n         let fn_name = self.item.sig.ident.clone();\n"}
{"instance_id": "tokio-rs__tracing-1619", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tracing-subscriber/src/filter/layer_filters.rs b/tracing-subscriber/src/filter/layer_filters.rs\nindex 9b234194..75150806 100644\n--- a/tracing-subscriber/src/filter/layer_filters.rs\n+++ b/tracing-subscriber/src/filter/layer_filters.rs\n@@ -386,7 +386,7 @@ where\n             id if id == TypeId::of::<MagicPlfDowncastMarker>() => {\n                 Some(&self.id as *const _ as *const ())\n             }\n-            _ => None,\n+            _ => self.layer.downcast_raw(id),\n         }\n     }\n }\n"}
{"instance_id": "biomejs__biome-2621", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_json_syntax/src/lib.rs b/crates/biome_json_syntax/src/lib.rs\nindex 8a412e8b45..5f486bb234 100644\n--- a/crates/biome_json_syntax/src/lib.rs\n+++ b/crates/biome_json_syntax/src/lib.rs\n@@ -116,10 +116,17 @@ impl TryFrom<JsonSyntaxKind> for TriviaPieceKind {\n pub fn inner_string_text(token: &JsonSyntaxToken) -> TokenText {\n     let mut text = token.token_text_trimmed();\n     if token.kind() == JsonSyntaxKind::JSON_STRING_LITERAL {\n-        // remove string delimiters\n-        // SAFETY: string literal token have a delimiters at the start and the end of the string\n-        let range = TextRange::new(1.into(), text.len() - TextSize::from(1));\n-        text = text.slice(range);\n+        // remove string delimiters if the literal is at least 2 characters long\n+        let len = text.len();\n+        if len >= TextSize::from(2) {\n+            let start = TextSize::from(1);\n+            let end = len - TextSize::from(1);\n+            let range = TextRange::new(start, end);\n+            text = text.slice(range);\n+        } else {\n+            // unterminated or too short string literal; return empty slice to avoid panic\n+            text = text.slice(TextRange::new(0.into(), 0.into()));\n+        }\n     }\n     text\n }\n"}
{"instance_id": "clap-rs__clap-3179", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/output/help.rs b/src/output/help.rs\nindex e567edce..204b35d0 100644\n--- a/src/output/help.rs\n+++ b/src/output/help.rs\n@@ -760,12 +760,27 @@ impl<'help, 'app, 'parser, 'writer> Help<'help, 'app, 'parser, 'writer> {\n         };\n \n         if !non_pos.is_empty() {\n-            if !first {\n-                self.none(\"\\n\\n\")?;\n+            // split into flags (no values) vs. options (take values)\n+            let (flags, opts): (Vec<_>, Vec<_>) = non_pos.into_iter()\n+                .partition(|arg| !arg.takes_value());\n+\n+            if !flags.is_empty() {\n+                if !first {\n+                    self.none(\"\\n\\n\")?;\n+                }\n+                self.warning(\"FLAGS:\\n\")?;\n+                self.write_args(&flags)?;\n+                first = false;\n+            }\n+\n+            if !opts.is_empty() {\n+                if !first {\n+                    self.none(\"\\n\\n\")?;\n+                }\n+                self.warning(\"OPTIONS:\\n\")?;\n+                self.write_args(&opts)?;\n+                first = false;\n             }\n-            self.warning(\"OPTIONS:\\n\")?;\n-            self.write_args(&non_pos)?;\n-            first = false;\n         }\n         if !custom_headings.is_empty() {\n             for heading in custom_headings {\n"}
{"instance_id": "tokio-rs__bytes-643", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes.rs b/src/bytes.rs\nindex 9fed3d2..e0b3f55 100644\n--- a/src/bytes.rs\n+++ b/src/bytes.rs\n@@ -111,6 +111,8 @@ pub(crate) struct Vtable {\n     /// fn(data, ptr, len)\n     ///\n     /// takes `Bytes` to value\n+    /// Returns true if this `Bytes` is the unique owner of the underlying storage.\n+    pub is_unique: unsafe fn(&AtomicPtr<()>) -> bool,\n     pub to_vec: unsafe fn(&AtomicPtr<()>, *const u8, usize) -> Vec<u8>,\n     /// fn(data, ptr, len)\n     pub drop: unsafe fn(&mut AtomicPtr<()>, *const u8, usize),\n"}
{"instance_id": "tokio-rs__tokio-5781", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/io/ready.rs b/tokio/src/io/ready.rs\nindex c2a80264..b1016dff 100644\n--- a/tokio/src/io/ready.rs\n+++ b/tokio/src/io/ready.rs\n@@ -51,41 +51,46 @@ impl Ready {\n     // Must remain crate-private to avoid adding a public dependency on Mio.\n     pub(crate) fn from_mio(event: &mio::event::Event) -> Ready {\n         let mut ready = Ready::EMPTY;\n-\n+    \n         #[cfg(all(target_os = \"freebsd\", feature = \"net\"))]\n         {\n             if event.is_aio() {\n                 ready |= Ready::READABLE;\n             }\n-\n+    \n             if event.is_lio() {\n                 ready |= Ready::READABLE;\n             }\n         }\n-\n+    \n         if event.is_readable() {\n             ready |= Ready::READABLE;\n         }\n-\n+    \n         if event.is_writable() {\n             ready |= Ready::WRITABLE;\n         }\n-\n+    \n         if event.is_read_closed() {\n             ready |= Ready::READ_CLOSED;\n         }\n-\n+    \n         if event.is_write_closed() {\n             ready |= Ready::WRITE_CLOSED;\n         }\n-\n+    \n         #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n         {\n             if event.is_priority() {\n                 ready |= Ready::PRIORITY;\n             }\n         }\n-\n+    \n+        // Map Mio\u2019s error condition into our ERROR flag.\n+        if event.is_error() {\n+            ready |= Ready::ERROR;\n+        }\n+    \n         ready\n     }\n \n@@ -213,23 +218,26 @@ impl Ready {\n \n     pub(crate) fn from_interest(interest: Interest) -> Ready {\n         let mut ready = Ready::EMPTY;\n-\n+    \n         if interest.is_readable() {\n             ready |= Ready::READABLE;\n             ready |= Ready::READ_CLOSED;\n         }\n-\n+    \n         if interest.is_writable() {\n             ready |= Ready::WRITABLE;\n             ready |= Ready::WRITE_CLOSED;\n         }\n-\n+    \n         #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n         if interest.is_priority() {\n             ready |= Ready::PRIORITY;\n             ready |= Ready::READ_CLOSED;\n         }\n-\n+    \n+        // Always subscribe to socket\u2010error readiness so MSG_ERRQUEUE wakes us up.\n+        ready |= Ready::ERROR;\n+    \n         ready\n     }\n \n"}
{"instance_id": "boa-dev__boa-667", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/object/gcobject.rs b/boa/src/builtins/object/gcobject.rs\nindex 15b1d7d1..070de597 100644\n--- a/boa/src/builtins/object/gcobject.rs\n+++ b/boa/src/builtins/object/gcobject.rs\n@@ -99,19 +99,24 @@ impl GcObject {\n     // <https://tc39.es/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist>\n     pub fn call(&self, this: &Value, args: &[Value], ctx: &mut Interpreter) -> Result<Value> {\n         let this_function_object = self.clone();\n-        let object = self.borrow();\n-        if let Some(function) = object.as_function() {\n+        // Clone out the Function so the borrow is dropped immediately.\n+        let function = {\n+            let object = self.borrow();\n+            object.as_function().cloned()\n+        };\n+        if let Some(function) = function {\n             if function.is_callable() {\n                 match function {\n+                    // built\u2010in functions just work\n                     Function::BuiltIn(BuiltInFunction(function), _) => function(this, args, ctx),\n+                    // ordinary functions: all fields have been cloned so no borrow is held here\n                     Function::Ordinary {\n                         body,\n                         params,\n                         environment,\n                         flags,\n                     } => {\n-                        // Create a new Function environment who's parent is set to the scope of the function declaration (self.environment)\n-                        // <https://tc39.es/ecma262/#sec-prepareforordinarycall>\n+                        // Create a new Function environment whose parent is the declaration scope\n                         let local_env = new_function_environment(\n                             this_function_object,\n                             if flags.is_lexical_this_mode() {\n@@ -120,14 +125,13 @@ impl GcObject {\n                                 Some(this.clone())\n                             },\n                             Some(environment.clone()),\n-                            // Arrow functions do not have a this binding https://tc39.es/ecma262/#sec-function-environment-records\n                             if flags.is_lexical_this_mode() {\n                                 BindingStatus::Lexical\n                             } else {\n                                 BindingStatus::Uninitialized\n                             },\n                         );\n-\n+        \n                         // Add argument bindings to the function environment\n                         for (i, param) in params.iter().enumerate() {\n                             // Rest Parameters\n@@ -135,11 +139,11 @@ impl GcObject {\n                                 function.add_rest_param(param, i, args, ctx, &local_env);\n                                 break;\n                             }\n-\n+        \n                             let value = args.get(i).cloned().unwrap_or_else(Value::undefined);\n                             function.add_arguments_to_environment(param, value, &local_env);\n                         }\n-\n+        \n                         // Add arguments object\n                         let arguments_obj = create_unmapped_arguments_object(args);\n                         local_env\n@@ -148,13 +152,13 @@ impl GcObject {\n                         local_env\n                             .borrow_mut()\n                             .initialize_binding(\"arguments\", arguments_obj);\n-\n+        \n                         ctx.realm.environment.push(local_env);\n-\n-                        // Call body should be set before reaching here\n+        \n+                        // Execute the function body\n                         let result = body.run(ctx);\n-\n-                        // local_env gets dropped here, its no longer needed\n+        \n+                        // Pop the function environment\n                         ctx.realm.environment.pop();\n                         result\n                     }\n@@ -174,10 +178,14 @@ impl GcObject {\n     // <https://tc39.es/ecma262/#sec-ecmascript-function-objects-construct-argumentslist-newtarget>\n     pub fn construct(&self, args: &[Value], ctx: &mut Interpreter) -> Result<Value> {\n         let this = Object::create(self.borrow().get(&PROTOTYPE.into())).into();\n-\n+        \n         let this_function_object = self.clone();\n-        let object = self.borrow();\n-        if let Some(function) = object.as_function() {\n+        // Clone out the Function so we drop the borrow immediately\n+        let function = {\n+            let object = self.borrow();\n+            object.as_function().cloned()\n+        };\n+        if let Some(function) = function {\n             if function.is_constructable() {\n                 match function {\n                     Function::BuiltIn(BuiltInFunction(function), _) => {\n@@ -190,20 +198,18 @@ impl GcObject {\n                         environment,\n                         flags,\n                     } => {\n-                        // Create a new Function environment who's parent is set to the scope of the function declaration (self.environment)\n-                        // <https://tc39.es/ecma262/#sec-prepareforordinarycall>\n+                        // Create a new Function environment whose parent is the declaration scope\n                         let local_env = new_function_environment(\n                             this_function_object,\n                             Some(this),\n                             Some(environment.clone()),\n-                            // Arrow functions do not have a this binding https://tc39.es/ecma262/#sec-function-environment-records\n                             if flags.is_lexical_this_mode() {\n                                 BindingStatus::Lexical\n                             } else {\n                                 BindingStatus::Uninitialized\n                             },\n                         );\n-\n+        \n                         // Add argument bindings to the function environment\n                         for (i, param) in params.iter().enumerate() {\n                             // Rest Parameters\n@@ -211,11 +217,11 @@ impl GcObject {\n                                 function.add_rest_param(param, i, args, ctx, &local_env);\n                                 break;\n                             }\n-\n+        \n                             let value = args.get(i).cloned().unwrap_or_else(Value::undefined);\n                             function.add_arguments_to_environment(param, value, &local_env);\n                         }\n-\n+        \n                         // Add arguments object\n                         let arguments_obj = create_unmapped_arguments_object(args);\n                         local_env\n@@ -224,13 +230,13 @@ impl GcObject {\n                         local_env\n                             .borrow_mut()\n                             .initialize_binding(\"arguments\", arguments_obj);\n-\n+        \n                         ctx.realm.environment.push(local_env);\n-\n-                        // Call body should be set before reaching here\n+        \n+                        // Execute the constructor body\n                         let _ = body.run(ctx);\n-\n-                        // local_env gets dropped here, its no longer needed\n+        \n+                        // Retrieve the new binding\n                         let binding = ctx.realm.environment.get_this_binding();\n                         Ok(binding)\n                     }\n"}
{"instance_id": "boa-dev__boa-410", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/json/mod.rs b/boa/src/builtins/json/mod.rs\nindex ad7cd378..9f546b4c 100644\n--- a/boa/src/builtins/json/mod.rs\n+++ b/boa/src/builtins/json/mod.rs\n@@ -38,17 +38,71 @@ mod tests;\n /// [spec]: https://tc39.es/ecma262/#sec-json.parse\n /// [mdn]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n // TODO: implement optional revever argument.\n-pub fn parse(_: &mut Value, args: &[Value], _: &mut Interpreter) -> ResultValue {\n-    match serde_json::from_str::<JSONValue>(\n+pub fn parse(_: &mut Value, args: &[Value], interpreter: &mut Interpreter) -> ResultValue {\n+    // 1) Parse the text to serde_json::Value\n+    let parsed = match serde_json::from_str::<JSONValue>(\n         &args\n             .get(0)\n             .expect(\"cannot get argument for JSON.parse\")\n             .clone()\n             .to_string(),\n     ) {\n-        Ok(json) => Ok(Value::from(json)),\n-        Err(err) => Err(Value::from(err.to_string())),\n+        Ok(json) => Value::from(json),\n+        Err(err) => return Err(Value::from(err.to_string())),\n+    };\n+\n+    // If no reviver provided or not callable, return parsed as-is\n+    let reviver = args.get(1);\n+    if reviver.is_none() || !reviver.unwrap().is_callable() {\n+        return Ok(parsed);\n     }\n+    let reviver = reviver.unwrap().clone();\n+\n+    // Helper function: Walk(holder, key)\n+    fn walk(\n+        holder: &Value,\n+        key: &str,\n+        reviver: &Value,\n+        interpreter: &mut Interpreter,\n+    ) -> Result<Value, Value> {\n+        // 1. Let value = holder[key]\n+        let mut value = holder.get_field(key);\n+\n+        // 2. If value is object or array, process its properties\n+        if value.is_object() {\n+            // Collect own property keys in ascending order\n+            let mut keys: Vec<String> = value\n+                .clone()\n+                .get_own_property_keys()\n+                .into_iter()\n+                .map(|k| k.to_string())\n+                .collect();\n+            keys.sort();\n+            for prop in keys {\n+                // Recurse\n+                let new_val = walk(&value, &prop, reviver, interpreter)?;\n+                if new_val.is_undefined() {\n+                    // delete property\n+                    value.delete_property(&prop);\n+                } else {\n+                    // set property\n+                    value.set_field(prop.clone(), new_val);\n+                }\n+            }\n+        }\n+\n+        // 3. Call reviver with (key, value)\n+        let this_arg = Value::null();\n+        let args = [Value::from(key.to_string()), value.clone()];\n+        interpreter.call(&reviver, &mut this_arg.clone(), &args)\n+    }\n+\n+    // 2) Create holder object and set [\"\"] = parsed\n+    let mut holder = Value::new_object(Some(interpreter));\n+    holder.set_field(\"\".to_string(), parsed);\n+\n+    // 3) Return Walk(holder, \"\")\n+    walk(&holder, \"\", &reviver, interpreter).map(Ok)?.map_err(Err)?\n }\n \n /// `JSON.stringify( value[, replacer[, space]] )`\n"}
{"instance_id": "bevyengine__bevy-16747", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_animation/src/animation_curves.rs b/crates/bevy_animation/src/animation_curves.rs\nindex e41f83157..59e381c87 100644\n--- a/crates/bevy_animation/src/animation_curves.rs\n+++ b/crates/bevy_animation/src/animation_curves.rs\n@@ -983,4 +983,9 @@ macro_rules! animated_field {\n             &mut component.$field\n         })\n     };\n+    ($component:ident::$index:literal) => {\n+        AnimatedField::new_unchecked(stringify!($index), |component: &mut $component| {\n+            &mut component.$index\n+        })\n+    };\n }\n"}
{"instance_id": "clap-rs__clap-3732", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/parser/matches/arg_matches.rs b/src/parser/matches/arg_matches.rs\nindex 50757e77..041a4cc1 100644\n--- a/src/parser/matches/arg_matches.rs\n+++ b/src/parser/matches/arg_matches.rs\n@@ -1127,6 +1127,18 @@ impl ArgMatches {\n \n // Private methods\n impl ArgMatches {\n+    /// Disable panicking on invalid argument or group names in debug builds.\n+    /// After calling this, methods like `value_of(...)` will return `None` instead of panic\n+    /// when passed an unknown key.  In non-debug (release) builds this is a no-op.\n+    #[must_use]\n+    pub fn disable_asserts(mut self) -> Self {\n+        #[cfg(debug_assertions)]\n+        {\n+            self.disable_asserts = true;\n+        }\n+        self\n+    }\n+    \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)]\n     fn get_arg(&self, arg: &Id) -> Option<&MatchedArg> {\n@@ -1147,7 +1159,7 @@ impl ArgMatches {\n                 );\n             }\n         }\n-\n+    \n         self.args.get(arg)\n     }\n \n"}
{"instance_id": "biomejs__biome-385", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_analyze/src/analyzers/correctness/no_self_assign.rs b/crates/biome_js_analyze/src/analyzers/correctness/no_self_assign.rs\nindex 07093fea12..e5bc8d005a 100644\n--- a/crates/biome_js_analyze/src/analyzers/correctness/no_self_assign.rs\n+++ b/crates/biome_js_analyze/src/analyzers/correctness/no_self_assign.rs\n@@ -193,7 +193,19 @@ impl SameIdentifiers {\n                 new_assignment_like\n             }\n             AnyAssignmentLike::StaticExpression { left, right } => {\n-                Self::next_static_expression(left, right)\n+                // Only consider it a self-assign if the entire object chains match\n+                if let (Ok(left_obj), Ok(right_obj)) = (left.object(), right.object()) {\n+                    if left_obj.syntax().text_trimmed() == right_obj.syntax().text_trimmed() {\n+                        // now delegate to the existing property\u2010name check\n+                        Self::next_static_expression(left, right)\n+                    } else {\n+                        // different objects \u21d2 not a self-assign\n+                        None\n+                    }\n+                } else {\n+                    // if we can't access the sub-expressions, bail out\n+                    None\n+                }\n             }\n             AnyAssignmentLike::None | AnyAssignmentLike::Identifiers { .. } => {\n                 let new_assignment = self.current_assignment_like.clone();\n"}
{"instance_id": "tokio-rs__tokio-6205", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/sync/mpsc/bounded.rs b/tokio/src/sync/mpsc/bounded.rs\nindex 3a795d55..85eef8a0 100644\n--- a/tokio/src/sync/mpsc/bounded.rs\n+++ b/tokio/src/sync/mpsc/bounded.rs\n@@ -68,6 +68,45 @@ pub struct Permit<'a, T> {\n     chan: &'a chan::Tx<T, Semaphore>,\n }\n \n+/// A permit to send up to `n` messages into the channel.\n+///\n+/// `ManyPermit` values are returned by `Sender::reserve_many` and\n+/// `Sender::try_reserve_many` and are used to guarantee channel capacity\n+/// before generating messages to send.\n+pub struct ManyPermit<'a, T> {\n+    chan: &'a chan::Tx<T, Semaphore>,\n+    remaining: usize,\n+}\n+\n+impl<'a, T> ManyPermit<'a, T> {\n+    /// Sends a value using one unit of the reserved capacity.\n+    ///\n+    /// Panics if called more times than the original `n`.\n+    pub fn send(&mut self, value: T) {\n+        if self.remaining == 0 {\n+            panic!(\"ManyPermit: no permits left\");\n+        }\n+        // forward to the inner channel\n+        self.chan.send(value);\n+        self.remaining -= 1;\n+    }\n+}\n+\n+impl<'a, T> Drop for ManyPermit<'a, T> {\n+    fn drop(&mut self) {\n+        // Return any unused permits\n+        if self.remaining > 0 {\n+            // The underlying semaphore is stored in `chan.semaphore().semaphore`\n+            let sem = &self.chan.semaphore().semaphore;\n+            sem.add_permits(self.remaining);\n+            // If the channel is closed and no tasks remain waiting, wake the receiver\n+            if sem.is_closed() && sem.is_idle() {\n+                self.chan.wake_rx();\n+            }\n+        }\n+    }\n+}\n+\n /// Owned permit to send one value into the channel.\n ///\n /// This is identical to the [`Permit`] type, except that it moves the sender\n@@ -1079,6 +1118,34 @@ impl<T> Sender<T> {\n         Ok(Permit { chan: &self.chan })\n     }\n \n+    /// Asynchronously reserves capacity for up to `n` messages.\n+    ///\n+    /// Returns a `ManyPermit` guard which must have `send(...)` called\n+    /// up to `n` times, or dropped early to release unused slots.\n+    pub async fn reserve_many(&self, n: usize) -> Result<ManyPermit<'_, T>, SendError<()>> {\n+        match self.chan.semaphore().semaphore.acquire_many(n).await {\n+            Ok(()) => {}\n+            Err(AcquireError::Closed) => return Err(SendError(())),\n+        }\n+        Ok(ManyPermit {\n+            chan: &self.chan,\n+            remaining: n,\n+        })\n+    }\n+\n+    /// Tries to reserve capacity for up to `n` messages without waiting.\n+    pub fn try_reserve_many(&self, n: usize) -> Result<ManyPermit<'_, T>, TrySendError<()>> {\n+        match self.chan.semaphore().semaphore.try_acquire(n) {\n+            Ok(()) => {}\n+            Err(TryAcquireError::Closed) => return Err(TrySendError::Closed(())),\n+            Err(TryAcquireError::NoPermits) => return Err(TrySendError::Full(())),\n+        }\n+        Ok(ManyPermit {\n+            chan: &self.chan,\n+            remaining: n,\n+        })\n+    }\n+\n     /// Tries to acquire a slot in the channel without waiting for the slot to become\n     /// available, returning an owned permit.\n     ///\n"}
{"instance_id": "biomejs__biome-1327", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_analyze/src/semantic_analyzers/correctness/use_exhaustive_dependencies.rs b/crates/biome_js_analyze/src/semantic_analyzers/correctness/use_exhaustive_dependencies.rs\nindex 1a1a1ed901..d518fea38a 100644\n--- a/crates/biome_js_analyze/src/semantic_analyzers/correctness/use_exhaustive_dependencies.rs\n+++ b/crates/biome_js_analyze/src/semantic_analyzers/correctness/use_exhaustive_dependencies.rs\n@@ -399,12 +399,12 @@ pub enum Fix {\n fn get_whole_static_member_expression(\n     reference: &JsSyntaxNode,\n ) -> Option<JsStaticMemberExpression> {\n-    let root = reference\n+    // Climb the AST to find every JsStaticMemberExpression ancestor,\n+    // then pick the last one (the outermost member chain).\n+    reference\n         .ancestors()\n-        .skip(2) //IDENT and JS_REFERENCE_IDENTIFIER\n-        .take_while(|x| x.kind() == JsSyntaxKind::JS_STATIC_MEMBER_EXPRESSION)\n-        .last()?;\n-    root.cast()\n+        .filter_map(JsStaticMemberExpression::cast)\n+        .last()\n }\n \n // Test if a capture needs to be in the dependency list\n"}
{"instance_id": "tokio-rs__tokio-5343", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/sync/broadcast.rs b/tokio/src/sync/broadcast.rs\nindex ede990b0..5a69ee5c 100644\n--- a/tokio/src/sync/broadcast.rs\n+++ b/tokio/src/sync/broadcast.rs\n@@ -603,6 +603,23 @@ impl<T> Sender<T> {\n         new_receiver(shared)\n     }\n \n+    /// Returns the number of messages currently stored in the broadcast buffer.\n+    ///\n+    /// If fewer messages than the channel's capacity have been sent, this returns\n+    /// the total number of messages sent.  Otherwise it returns the channel\u2019s\n+    /// capacity (i.e., the buffer is full).\n+    pub fn len(&self) -> usize {\n+        // Lock the tail to read the total number of items ever sent.\n+        let tail = self.shared.tail.lock();\n+        let sent = tail.pos as usize;\n+\n+        // The capacity is just the length of the internal ring buffer.\n+        let cap = self.shared.buffer.len();\n+\n+        // The current buffer occupancy is min(sent, cap).\n+        std::cmp::min(sent, cap)\n+    }\n+\n     /// Returns the number of active receivers\n     ///\n     /// An active receiver is a [`Receiver`] handle returned from [`channel`] or\n"}
{"instance_id": "sharkdp__fd-558", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/output.rs b/src/output.rs\nindex fcc9ed7..3753045 100644\n--- a/src/output.rs\n+++ b/src/output.rs\n@@ -11,6 +11,9 @@ use crate::exit_codes::ExitCode;\n use crate::filesystem::{replace_path_separator, strip_current_dir};\n use crate::options::Options;\n \n+#[cfg(unix)]\n+use std::os::unix::ffi::OsStrExt;  \n+\n // TODO: this function is performance critical and can probably be optimized\n pub fn print_entry(\n     stdout: &mut StdoutLock,\n@@ -52,11 +55,23 @@ fn print_entry_colorized(\n             .map(Style::to_ansi_term_style)\n             .unwrap_or(default_style);\n \n-        let mut path_string = component.to_string_lossy();\n-        if let Some(ref separator) = config.path_separator {\n-            *path_string.to_mut() = replace_path_separator(&path_string, &separator);\n+        #[cfg(unix)]\n+        {\n+            // On Unix, emit raw bytes with ANSI prefix/suffix\n+            let comp_bytes = component.as_os_str().as_bytes();\n+            stdout.write_all(style.prefix().as_bytes())?;\n+            stdout.write_all(comp_bytes)?;\n+            stdout.write_all(style.suffix().as_bytes())?;\n         }\n-        write!(stdout, \"{}\", style.paint(path_string))?;\n+        #[cfg(not(unix))]\n+        {\n+            // Fallback to the old, UTF-8\u2010lossy path\n+            let mut path_string = component.to_string_lossy();\n+            if let Some(ref separator) = config.path_separator {\n+                *path_string.to_mut() = replace_path_separator(&path_string, &separator);\n+            }\n+            write!(stdout, \"{}\", style.paint(path_string))?;\n+        }  \n \n         // TODO: can we move this out of the if-statement? Why do we call it that often?\n         if wants_to_quit.load(Ordering::Relaxed) {\n@@ -80,9 +95,33 @@ fn print_entry_uncolorized(\n ) -> io::Result<()> {\n     let separator = if config.null_separator { \"\\0\" } else { \"\\n\" };\n \n-    let mut path_string = path.to_string_lossy();\n-    if let Some(ref separator) = config.path_separator {\n-        *path_string.to_mut() = replace_path_separator(&path_string, &separator);\n+    #[cfg(unix)]\n+    {\n+        // On Unix, emit raw bytes and then the separator\n+        let path_bytes = path.as_os_str().as_bytes();\n+        if let Some(ref sep_str) = config.path_separator {\n+            // Replace the default '/' with the user separator\n+            let sep_bytes = sep_str.as_bytes();\n+            let segments: Vec<&[u8]> = path_bytes.split(|b| *b == b'/').collect();\n+            for (i, seg) in segments.iter().enumerate() {\n+                stdout.write_all(seg)?;\n+                if i + 1 != segments.len() {\n+                    stdout.write_all(sep_bytes)?;\n+                }\n+            }\n+        } else {\n+            stdout.write_all(path_bytes)?;\n+        }\n+        stdout.write_all(separator.as_bytes())?;\n+        Ok(())\n     }\n-    write!(stdout, \"{}{}\", path_string, separator)\n+    #[cfg(not(unix))]\n+    {\n+        // Fallback to the old, UTF-8\u2010lossy path\n+        let mut path_string = path.to_string_lossy();\n+        if let Some(ref sep_str) = config.path_separator {\n+            *path_string.to_mut() = replace_path_separator(&path_string, &sep_str);\n+        }\n+        write!(stdout, \"{}{}\", path_string, separator)\n+    }  \n }\n"}
{"instance_id": "tokio-rs__tokio-6252", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tokio/src/sync/watch.rs b/tokio/src/sync/watch.rs\nindex 587aa795..0c1f083d 100644\n--- a/tokio/src/sync/watch.rs\n+++ b/tokio/src/sync/watch.rs\n@@ -669,6 +669,18 @@ impl<T> Receiver<T> {\n         self.version.decrement();\n     }\n \n+    /// Marks the current value as seen without taking a read\u2010lock.\n+    ///\n+    /// After calling this method, `has_changed()` will return `false`\n+    /// (until the next `send`) and `changed().await` will suspend until a\n+    /// fresh value is sent. This is equivalent to that part of\n+    /// `borrow_and_update` which advances the receiver\u2019s internal version,\n+    /// but avoids any RwLock activity.\n+    pub fn mark_seen(&mut self) {\n+        let new_version = self.shared.state.load().version();\n+        self.version = new_version;\n+    }\n+\n     /// Waits for a change notification, then marks the newest value as seen.\n     ///\n     /// If the newest value in the channel has not yet been marked seen when\n"}
{"instance_id": "async-graphql__async-graphql-1491", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/validation/rules/default_values_of_correct_type.rs b/src/validation/rules/default_values_of_correct_type.rs\nindex 98d3349d..9ed6655c 100644\n--- a/src/validation/rules/default_values_of_correct_type.rs\n+++ b/src/validation/rules/default_values_of_correct_type.rs\n@@ -1,4 +1,4 @@\n-use async_graphql_parser::types::BaseType;\n+use async_graphql_parser::types::{BaseType, Value};\n \n use crate::{\n     context::QueryPathNode,\n@@ -28,16 +28,22 @@ impl<'a> Visitor<'a> for DefaultValuesOfCorrectType {\n             }\n         }\n \n-        if let Some(value) = &variable_definition.node.default_value {\n-            if !variable_definition.node.var_type.node.nullable {\n-                ctx.report_error(vec![variable_definition.pos],format!(\n-                    \"Argument \\\"{}\\\" has type \\\"{}\\\" and is not nullable, so it can't have a default value\",\n-                    variable_definition.node.name, variable_definition.node.var_type,\n-                ));\n+        if let Some(default) = &variable_definition.node.default_value {\n+            let var_type = &variable_definition.node.var_type;\n+            let default_node = &default.node;\n+            // Non-nullable variables may have defaults\u2014just not null.\n+            if !var_type.node.nullable && matches!(default_node, Value::Null) {\n+                ctx.report_error(\n+                    vec![variable_definition.pos],\n+                    format!(\n+                        \"Argument \\\"{}\\\" of type \\\"{}\\\" is non-nullable and cannot have null as a default value\",\n+                        variable_definition.node.name, var_type,\n+                    ),\n+                );\n             } else if let Some(reason) = is_valid_input_value(\n                 ctx.registry,\n-                &variable_definition.node.var_type.to_string(),\n-                &value.node,\n+                &var_type.to_string(),\n+                default_node,\n                 QueryPathNode {\n                     parent: None,\n                     segment: QueryPathSegment::Name(&variable_definition.node.name.node),\n"}
{"instance_id": "rinja-rs__askama-486", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/askama_escape/src/lib.rs b/askama_escape/src/lib.rs\nindex fcc36c6..791e55e 100644\n--- a/askama_escape/src/lib.rs\n+++ b/askama_escape/src/lib.rs\n@@ -129,7 +129,7 @@ impl Escaper for Html {\n                     b'&' => escaping_body!(start, i, fmt, bytes, \"&amp;\"),\n                     b'\"' => escaping_body!(start, i, fmt, bytes, \"&quot;\"),\n                     b'\\'' => escaping_body!(start, i, fmt, bytes, \"&#x27;\"),\n-                    b'/' => escaping_body!(start, i, fmt, bytes, \"&#x2f;\"),\n+                    // Removed slash escaping: '/' will now be written literally\n                     _ => (),\n                 }\n             }\n"}
{"instance_id": "cargo-generate__cargo-generate-511", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/args.rs b/src/args.rs\nindex ed4e9db..c273594 100644\n--- a/src/args.rs\n+++ b/src/args.rs\n@@ -47,11 +47,13 @@ pub struct Args {\n     pub subfolder: Option<String>,\n \n     /// Git repository to clone template from. Can be a URL (like\n-    /// `https://github.com/rust-cli/cli-template`), a path (relative or absolute), or an\n-    /// `owner/repo` abbreviated GitHub URL (like `rust-cli/cli-template`).\n+    /// `https://github.com/rust-cli/cli-template`), a path (relative or absolute),\n+    /// an owner/repo shorthand (like `rust-cli/cli-template`),\n+    /// or a prefixed shorthand: `gh:owner/repo` (GitHub, default), `gl:owner/repo` (GitLab),\n+    /// `bb:owner/repo` (Bitbucket).\n     ///\n-    /// Note that cargo generate will first attempt to interpret the `owner/repo` form as a\n-    /// relative path and only try a GitHub URL if the local path doesn't exist.\n+    /// Note that cargo-generate will first attempt to interpret a path or owner/repo\n+    /// form as a local path, before trying network URLs.\n     #[structopt(short, long, conflicts_with = \"subfolder\")]\n     pub git: Option<String>,\n \ndiff --git a/src/git.rs b/src/git.rs\nindex e40d88f..c56df5c 100644\n--- a/src/git.rs\n+++ b/src/git.rs\n@@ -80,8 +80,26 @@ impl<'a> GitConfig<'a> {\n         branch: Option<String>,\n         identity: Option<PathBuf>,\n     ) -> Result<Self> {\n+        let git_str = git.as_ref();\n+    \n+        // explicit prefixes\n+        if git_str.starts_with(\"gl:\") {\n+            let repo = &git_str[\"gl:\".len()..];\n+            let full_remote = format!(\"https://gitlab.com/{}.git\", repo);\n+            return Self::new(full_remote.into(), branch, identity);\n+        } else if git_str.starts_with(\"bb:\") {\n+            let repo = &git_str[\"bb:\".len()..];\n+            let full_remote = format!(\"https://bitbucket.org/{}.git\", repo);\n+            return Self::new(full_remote.into(), branch, identity);\n+        } else if git_str.starts_with(\"gh:\") {\n+            let repo = &git_str[\"gh:\".len()..];\n+            let full_remote = format!(\"https://github.com/{}.git\", repo);\n+            return Self::new(full_remote.into(), branch, identity);\n+        }\n+    \n+        // fallback: treat as-is or try GitHub owner/repo shorthand\n         Self::new(git.clone(), branch.clone(), identity.clone()).or_else(|_| {\n-            let full_remote = format!(\"https://github.com/{}.git\", &git);\n+            let full_remote = format!(\"https://github.com/{}.git\", git_str);\n             Self::new(full_remote.into(), branch, identity)\n         })\n     }\n"}
{"instance_id": "clap-rs__clap-3402", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/error/mod.rs b/src/error/mod.rs\nindex 6349661a..1b02a307 100644\n--- a/src/error/mod.rs\n+++ b/src/error/mod.rs\n@@ -41,6 +41,8 @@ pub struct Error {\n     /// Additional information depending on the error kind, like values and argument names.\n     /// Useful when you want to render an error of your own.\n     pub info: Vec<String>,\n+    /// When true, suppress the usage\u2010string and help hint in `.exit()`.\n+    suppress_usage: bool,\n }\n \n #[derive(Debug)]\n"}
{"instance_id": "clap-rs__clap-3684", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/builder/command.rs b/src/builder/command.rs\nindex 36b160af..ced801c6 100644\n--- a/src/builder/command.rs\n+++ b/src/builder/command.rs\n@@ -641,20 +641,48 @@ impl<'help> App<'help> {\n         if self.settings.is_set(AppSettings::Multicall) {\n             if let Some(argv0) = raw_args.next_os(&mut cursor) {\n                 let argv0 = Path::new(&argv0);\n-                if let Some(command) = argv0.file_stem().and_then(|f| f.to_str()) {\n-                    // Stop borrowing command so we can get another mut ref to it.\n-                    let command = command.to_owned();\n-                    debug!(\n-                        \"Command::try_get_matches_from_mut: Parsed command {} from argv\",\n-                        command\n-                    );\n-\n-                    debug!(\"Command::try_get_matches_from_mut: Reinserting command into arguments so subcommand parser matches it\");\n-                    raw_args.insert(&cursor, &[&command]);\n-                    debug!(\"Command::try_get_matches_from_mut: Clearing name and bin_name so that displayed command name starts with applet name\");\n-                    self.name.clear();\n-                    self.bin_name = None;\n-                    return self._do_parse(&mut raw_args, cursor);\n+                if let Some(file_name_os) = argv0.file_name() {\n+                    if let Some(file_name) = file_name_os.to_str() {\n+                        // Strip only the platform's executable suffix\n+                        let trimmed = {\n+                            let suffix = std::env::consts::EXE_SUFFIX;\n+                            if !suffix.is_empty() {\n+                                #[cfg(windows)]\n+                                {\n+                                    let fname_lower = file_name.to_lowercase();\n+                                    let suffix_lower = suffix.to_lowercase();\n+                                    if fname_lower.ends_with(&suffix_lower) {\n+                                        &file_name[..file_name.len() - suffix.len()]\n+                                    } else {\n+                                        file_name\n+                                    }\n+                                }\n+                                #[cfg(not(windows))]\n+                                {\n+                                    if file_name.ends_with(suffix) {\n+                                        &file_name[..file_name.len() - suffix.len()]\n+                                    } else {\n+                                        file_name\n+                                    }\n+                                }\n+                            } else {\n+                                file_name\n+                            }\n+                        };\n+                        // Stop borrowing command so we can get another mut ref to it.\n+                        let command = trimmed.to_owned();\n+                        debug!(\n+                            \"Command::try_get_matches_from_mut: Parsed command {} from argv\",\n+                            command\n+                        );\n+            \n+                        debug!(\"Command::try_get_matches_from_mut: Reinserting command into arguments so subcommand parser matches it\");\n+                        raw_args.insert(&cursor, &[&command]);\n+                        debug!(\"Command::try_get_matches_from_mut: Clearing name and bin_name so that displayed command name starts with applet name\");\n+                        self.name.clear();\n+                        self.bin_name = None;\n+                        return self._do_parse(&mut raw_args, cursor);\n+                    }\n                 }\n             }\n         };\n"}
{"instance_id": "boa-dev__boa-138", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/js/string.rs b/src/lib/js/string.rs\nindex b07d8ae9..ad7b74d6 100644\n--- a/src/lib/js/string.rs\n+++ b/src/lib/js/string.rs\n@@ -4,7 +4,7 @@ use crate::{\n         function::NativeFunctionData,\n         object::{Object, ObjectKind, PROTOTYPE},\n         property::Property,\n-        regexp::{make_regexp, r#match as regexp_match},\n+        regexp::{make_regexp, r#match as regexp_match, r#match_all as regexp_match_all},\n         value::{from_value, to_value, ResultValue, Value, ValueData},\n     },\n };\n"}
{"instance_id": "biomejs__biome-3907", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_configuration/src/editorconfig.rs b/crates/biome_configuration/src/editorconfig.rs\nindex 8dd505a928..71e5f22292 100644\n--- a/crates/biome_configuration/src/editorconfig.rs\n+++ b/crates/biome_configuration/src/editorconfig.rs\n@@ -83,9 +83,11 @@ impl EditorConfig {\n #[derive(Debug, Clone, Deserialize, Default)]\n #[serde(default)]\n pub struct EditorConfigOptions {\n+    #[serde(deserialize_with = \"deserialize_optional_indent_style_from_string\")]\n     indent_style: Option<IndentStyle>,\n     #[serde(deserialize_with = \"deserialize_optional_indent_width_from_string\")]\n     indent_size: Option<IndentWidth>,\n+    #[serde(deserialize_with = \"deserialize_optional_line_ending_from_string\")]\n     end_of_line: Option<LineEnding>,\n     #[serde(deserialize_with = \"deserialize_optional_line_width_from_string\")]\n     max_line_length: Option<LineWidth>,\n"}
{"instance_id": "clap-rs__clap-2609", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/output/usage.rs b/src/output/usage.rs\nindex 1df4ff8c..bbd87050 100644\n--- a/src/output/usage.rs\n+++ b/src/output/usage.rs\n@@ -182,7 +182,7 @@ impl<'help, 'app, 'parser> Usage<'help, 'app, 'parser> {\n         let mut usage = String::with_capacity(75);\n \n         let r_string = self\n-            .get_required_usage_from(used, None, true)\n+            .get_required_usage_from(used, Some(&self.p.matcher), true)\n             .iter()\n             .fold(String::new(), |acc, s| acc + &format!(\" {}\", s)[..]);\n \n"}
{"instance_id": "bevyengine__bevy-9530", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_app/src/plugin_group.rs b/crates/bevy_app/src/plugin_group.rs\nindex 22d174df9..4f65d0d36 100644\n--- a/crates/bevy_app/src/plugin_group.rs\n+++ b/crates/bevy_app/src/plugin_group.rs\n@@ -138,6 +138,41 @@ impl PluginGroupBuilder {\n         self\n     }\n \n+    /// Adds a nested [`PluginGroup`] into this builder, flattening its plugins\n+    /// into the current group in the subgroup\u2019s defined order.\n+    pub fn add_group<G: PluginGroup>(mut self, group: G) -> Self {\n+        // Build the subgroup so we can inspect its order and plugin entries\n+        let mut subgroup = group.build();\n+        for type_id in &subgroup.order {\n+            // Take ownership of each PluginEntry\n+            if let Some(mut entry) = subgroup.plugins.remove(type_id) {\n+                // New index in the parent builder\n+                let idx = self.order.len();\n+                self.order.push(*type_id);\n+                // Insert or replace in our plugins map, warning on replacement\n+                if let Some(old_entry) = self.plugins.insert(*type_id, entry) {\n+                    if old_entry.enabled {\n+                        warn!(\n+                            \"You are replacing plugin '{}' that was not disabled.\",\n+                            old_entry.plugin.name()\n+                        );\n+                    }\n+                    // Clean up any duplicate ordering that isn't our newly added slot\n+                    if let Some(to_remove) = self\n+                        .order\n+                        .iter()\n+                        .enumerate()\n+                        .find(|(i, &ty)| *i != idx && ty == *type_id)\n+                        .map(|(i, _)| i)\n+                    {\n+                        self.order.remove(to_remove);\n+                    }\n+                }\n+            }\n+        }\n+        self\n+    }\n+\n     /// Enables a [`Plugin`].\n     ///\n     /// [`Plugin`]s within a [`PluginGroup`] are enabled by default. This function is used to\n"}
{"instance_id": "tokio-rs__bytes-361", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bytes.rs b/src/bytes.rs\nindex 93ab84b..ac23efb 100644\n--- a/src/bytes.rs\n+++ b/src/bytes.rs\n@@ -757,33 +757,30 @@ impl From<&'static str> for Bytes {\n \n impl From<Vec<u8>> for Bytes {\n     fn from(vec: Vec<u8>) -> Bytes {\n-        // into_boxed_slice doesn't return a heap allocation for empty vectors,\n-        // so the pointer isn't aligned enough for the KIND_VEC stashing to\n-        // work.\n+        // Empty stays empty\n         if vec.is_empty() {\n             return Bytes::new();\n         }\n \n-        let slice = vec.into_boxed_slice();\n-        let len = slice.len();\n-        let ptr = slice.as_ptr();\n-        drop(Box::into_raw(slice));\n-\n-        if ptr as usize & 0x1 == 0 {\n-            let data = ptr as usize | KIND_VEC;\n-            Bytes {\n-                ptr,\n-                len,\n-                data: AtomicPtr::new(data as *mut _),\n-                vtable: &PROMOTABLE_EVEN_VTABLE,\n-            }\n-        } else {\n-            Bytes {\n-                ptr,\n-                len,\n-                data: AtomicPtr::new(ptr as *mut _),\n-                vtable: &PROMOTABLE_ODD_VTABLE,\n-            }\n+        // Instead of slicing into a boxed\u2010slice and later\n+        // needing to reconstruct raw parts (which loses\n+        // the original capacity), immediately wrap the Vec\n+        // in our Shared struct.  Shared holds the original\n+        // Vec (and thus its capacity) and will free it\n+        // correctly on drop via SHARED_VTABLE.\n+        let ptr = vec.as_ptr();\n+        let len = vec.len();\n+        let shared = Box::new(Shared {\n+            _vec: vec,\n+            ref_cnt: AtomicUsize::new(1),\n+        });\n+        let shared_ptr = Box::into_raw(shared);\n+\n+        Bytes {\n+            ptr,\n+            len,\n+            data: AtomicPtr::new(shared_ptr as *mut _),\n+            vtable: &SHARED_VTABLE,\n         }\n     }\n }\n"}
{"instance_id": "clap-rs__clap-3311", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/app/mod.rs b/src/build/app/mod.rs\nindex d3fd35e8..53ceed40 100644\n--- a/src/build/app/mod.rs\n+++ b/src/build/app/mod.rs\n@@ -2790,6 +2790,11 @@ impl<'help> App<'help> {\n         debug!(\"App::_propagate:{}\", self.name);\n         let mut subcommands = std::mem::take(&mut self.subcommands);\n         for sc in &mut subcommands {\n+            // First, carry over version info if PropagateVersion is set\n+            if self.settings.is_set(AppSettings::PropagateVersion) {\n+                sc.version = sc.version.clone().or_else(|| self.version.clone());\n+                sc.long_version = sc.long_version.clone().or_else(|| self.long_version.clone());\n+            }\n             self._propagate_subcommand(sc);\n         }\n         self.subcommands = subcommands;\n"}
{"instance_id": "google__autocxx-306", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/gen/cmd/src/main.rs b/gen/cmd/src/main.rs\nindex f392ac25..05d716c7 100644\n--- a/gen/cmd/src/main.rs\n+++ b/gen/cmd/src/main.rs\n@@ -103,6 +103,16 @@ fn main() {\n                 .help(\"include path\")\n                 .takes_value(true),\n         )\n+        .arg(\n+            Arg::with_name(\"define\")\n+                .short(\"D\")\n+                .long(\"define\")\n+                .multiple(true)\n+                .number_of_values(1)\n+                .value_name(\"DEFINE\")\n+                .help(\"Define a C++ preprocessor macro (FOO or FOO=BAR)\")\n+                .takes_value(true),\n+        )\n         .arg(\n             Arg::with_name(\"cpp-extension\")\n                 .long(\"cpp-extension\")\n@@ -159,12 +169,23 @@ fn main() {\n         .values_of(\"inc\")\n         .unwrap_or_default()\n         .map(PathBuf::from)\n-        .collect();\n+        .collect::<Vec<_>>();\n+    let defines = matches\n+        .values_of(\"define\")\n+        .unwrap_or_default()\n+        .map(|s| {\n+            if s.contains('=') {\n+                s.to_string()\n+            } else {\n+                format!(\"{}=1\", s)\n+            }\n+        })\n+        .collect::<Vec<_>>();\n     // In future, we should provide an option to write a .d file here\n     // by passing a callback into the dep_recorder parameter here.\n     // https://github.com/google/autocxx/issues/56\n     parsed_file\n-        .resolve_all(incs, None)\n+        .resolve_all(incs, Some(&defines))\n         .expect(\"Unable to resolve macro\");\n     let outdir: PathBuf = matches.value_of_os(\"outdir\").unwrap().into();\n     let desired_number = matches\n"}
{"instance_id": "tokio-rs__axum-2881", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/axum/src/serve.rs b/axum/src/serve.rs\nindex e23e6109..497f42da 100644\n--- a/axum/src/serve.rs\n+++ b/axum/src/serve.rs\n@@ -115,6 +115,12 @@ pub struct Serve<M, S> {\n \n #[cfg(all(feature = \"tokio\", any(feature = \"http1\", feature = \"http2\")))]\n impl<M, S> Serve<M, S> {\n+    /// Returns the local address that this server is bound to.\n+    ///\n+    /// This is simply forwarded to the underlying `TcpListener`.\n+    pub fn local_addr(&self) -> std::io::Result<std::net::SocketAddr> {\n+        self.tcp_listener.local_addr()\n+    }\n     /// Prepares a server to handle graceful shutdown when the provided future completes.\n     ///\n     /// # Example\n"}
{"instance_id": "clap-rs__clap-2635", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/build/arg/mod.rs b/src/build/arg/mod.rs\nindex 9dfac579..01a4bd75 100644\n--- a/src/build/arg/mod.rs\n+++ b/src/build/arg/mod.rs\n@@ -2628,6 +2628,57 @@ impl<'help> Arg<'help> {\n         self.default_values_os(&[OsStr::new(val)])\n     }\n \n+    /// Specifies a default value for the argument using a typed `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # use clap::{App, Arg};\n+    /// let m = App::new(\"prog\")\n+    ///     .arg(Arg::new(\"num\")\n+    ///         .long(\"count\")\n+    ///         .default_value_t(5u32))\n+    ///     .get_matches_from(vec![\"prog\"]);\n+    ///\n+    /// assert_eq!(m.value_of_t::<u32>(\"count\").unwrap(), 5);\n+    /// ```\n+    #[inline]\n+    pub fn default_value_t<T>(self, val: T) -> Self\n+    where\n+        T: ToString,\n+        T: 'help,\n+    {\n+        let s = val.to_string();\n+        // Safety: `s` is owned for 'help, and we immediately call default_value with &str.\n+        // Note: user must ensure 'help outlives the builder, e.g. T is 'static.\n+        self.default_value(&s)\n+    }\n+\n+    /// Specifies multiple default values for the argument using typed `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # use clap::{App, Arg};\n+    /// let m = App::new(\"prog\")\n+    ///     .arg(Arg::new(\"list\")\n+    ///         .long(\"items\")\n+    ///         .default_values_t(&[1, 2, 3]))\n+    ///     .get_matches_from(vec![\"prog\"]);\n+    ///\n+    /// assert_eq!(m.values_of_t::<i32>(\"items\").unwrap(), vec![1, 2, 3]);\n+    /// ```\n+    #[inline]\n+    pub fn default_values_t<T>(self, vals: &[T]) -> Self\n+    where\n+        T: ToString,\n+        T: 'help,\n+    {\n+        let strs: Vec<String> = vals.iter().map(|v| v.to_string()).collect();\n+        let refs: Vec<&str> = strs.iter().map(AsRef::as_ref).collect();\n+        self.default_values(&refs)\n+    }\n+\n     /// Provides a default value in the exact same manner as [`Arg::default_value`]\n     /// only using [`OsStr`]s instead.\n     ///\n"}
{"instance_id": "clap-rs__clap-3394", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/parse/errors.rs b/src/parse/errors.rs\nindex 70505bfe..a21da61e 100644\n--- a/src/parse/errors.rs\n+++ b/src/parse/errors.rs\n@@ -612,6 +612,27 @@ impl Error {\n         start_error(&mut c, \"The argument '\");\n         c.warning(&*arg);\n         c.none(\"' requires a value but none was supplied\");\n+        // If the argument defines possible values, list them after the error\n+        if let Some(arg_def) = app.find(&arg) {\n+            let vals: Vec<_> = arg_def\n+                .possible_vals\n+                .iter()\n+                .filter(|v| !v.is_hide_set())\n+                .collect();\n+            if !vals.is_empty() {\n+                c.none(\"\\nAvailable values:\\n\");\n+                for pv in vals {\n+                    // Print name and optional help\n+                    c.none(\"    \");\n+                    c.good(pv.get_name());\n+                    if let Some(help) = pv.get_help() {\n+                        c.none(\"    \");\n+                        c.none(help);\n+                    }\n+                    c.none(\"\\n\");\n+                }\n+            }\n+        }\n         put_usage(&mut c, usage);\n         try_help(app, &mut c);\n \n"}
{"instance_id": "rust-lang__chalk-755", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/chalk-solve/src/clauses.rs b/chalk-solve/src/clauses.rs\nindex e795c8fd..9dde28e6 100644\n--- a/chalk-solve/src/clauses.rs\n+++ b/chalk-solve/src/clauses.rs\n@@ -162,9 +162,12 @@ pub fn push_auto_trait_impls<I: Interner>(\n \n         // closures require binders, while the other types do not\n         TyKind::Closure(closure_id, _) => {\n+            // Fetch the closure's own substitution so its generic parameters\n+            // (e.g. T in `|x: T| ...`) get applied in the upvars.\n+            let substs = builder.db.closure_substitution(*closure_id);\n             let binders = builder\n                 .db\n-                .closure_upvars(*closure_id, &Substitution::empty(interner));\n+                .closure_upvars(*closure_id, &substs);\n             builder.push_binders(binders, |builder, upvar_ty| {\n                 let conditions = iter::once(mk_ref(upvar_ty));\n                 builder.push_clause(consequence, conditions);\n"}
{"instance_id": "clap-rs__clap-3775", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/builder/arg.rs b/src/builder/arg.rs\nindex d8892cef..c98e774e 100644\n--- a/src/builder/arg.rs\n+++ b/src/builder/arg.rs\n@@ -2171,7 +2171,7 @@ impl<'help> Arg<'help> {\n     /// at runtime, nor were the conditions met for `Arg::default_value_if`, the `Arg::default_value`\n     /// will be applied.\n     ///\n-    /// **NOTE:** This implicitly sets [`Arg::takes_value(true)`].\n+    /// **NOTE:** This does **not** implicitly set [`Arg::takes_value(true)`].\n     ///\n     /// # Examples\n     ///\n@@ -3294,7 +3294,8 @@ impl<'help> Arg<'help> {\n     ) -> Self {\n         self.default_vals_ifs\n             .push((arg_id.into(), val.into(), default));\n-        self.takes_value(true)\n+        // Do not implicitly set takes_value(true) here.\n+        self\n     }\n \n     /// Specifies multiple values and conditions in the same manner as [`Arg::default_value_if`].\n"}
{"instance_id": "boa-dev__boa-785", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/json/mod.rs b/boa/src/builtins/json/mod.rs\nindex dc442920..1a3c1ca8 100644\n--- a/boa/src/builtins/json/mod.rs\n+++ b/boa/src/builtins/json/mod.rs\n@@ -61,12 +61,12 @@ impl Json {\n     /// [spec]: https://tc39.es/ecma262/#sec-json.parse\n     /// [mdn]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n     pub(crate) fn parse(_: &Value, args: &[Value], ctx: &mut Context) -> Result<Value> {\n-        match serde_json::from_str::<JSONValue>(\n-            &args\n-                .get(0)\n-                .expect(\"cannot get argument for JSON.parse\")\n-                .to_string(ctx)?,\n-        ) {\n+        let text = args\n+            .get(0)\n+            .cloned()\n+            .unwrap_or(Value::undefined())\n+            .to_string(ctx)?;\n+        match serde_json::from_str::<JSONValue>(&text) {\n             Ok(json) => {\n                 let j = Value::from_json(json, ctx);\n                 match args.get(1) {\n"}
{"instance_id": "bevyengine__bevy-7454", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_reflect/src/impls/std.rs b/crates/bevy_reflect/src/impls/std.rs\nindex 9f21e2e3f..74d1d1f9b 100644\n--- a/crates/bevy_reflect/src/impls/std.rs\n+++ b/crates/bevy_reflect/src/impls/std.rs\n@@ -1445,6 +1445,120 @@ impl GetTypeRegistration for Cow<'static, Path> {\n     }\n }\n \n+// ============================================================================\n+// Support for Cow<'static, [T]> (borrowed or owned slices):\n+// mirror the Cow<str> / Cow<Path> implementations but treat it as a List.\n+// ============================================================================\n+impl<T: Reflect + FromReflect + TypePath + Clone + 'static> Reflect for Cow<'static, [T]> {\n+    fn type_name(&self) -> &str {\n+        std::any::type_name::<Self>()\n+    }\n+\n+    fn get_represented_type_info(&self) -> Option<&'static TypeInfo> {\n+        Some(<Self as Typed>::type_info())\n+    }\n+\n+    fn into_any(self: Box<Self>) -> Box<dyn Any> {\n+        self\n+    }\n+\n+    fn as_any(&self) -> &dyn Any {\n+        self\n+    }\n+\n+    fn as_any_mut(&mut self) -> &mut dyn Any {\n+        self\n+    }\n+\n+    fn into_reflect(self: Box<Self>) -> Box<dyn Reflect> {\n+        self\n+    }\n+\n+    fn as_reflect(&self) -> &dyn Reflect {\n+        self\n+    }\n+\n+    fn as_reflect_mut(&mut self) -> &mut dyn Reflect {\n+        self\n+    }\n+\n+    fn apply(&mut self, value: &dyn Reflect) {\n+        crate::list_apply(self, value);\n+    }\n+\n+    fn set(&mut self, value: Box<dyn Reflect>) -> Result<(), Box<dyn Reflect>> {\n+        *self = value.take()?;\n+        Ok(())\n+    }\n+\n+    fn reflect_ref(&self) -> ReflectRef {\n+        ReflectRef::List(self)\n+    }\n+\n+    fn reflect_mut(&mut self) -> ReflectMut {\n+        ReflectMut::List(self)\n+    }\n+\n+    fn reflect_owned(self: Box<Self>) -> ReflectOwned {\n+        ReflectOwned::List(self)\n+    }\n+\n+    fn clone_value(&self) -> Box<dyn Reflect> {\n+        Box::new(self.clone())\n+    }\n+\n+    fn reflect_hash(&self) -> Option<u64> {\n+        crate::list_hash(self)\n+    }\n+\n+    fn reflect_partial_eq(&self, value: &dyn Reflect) -> Option<bool> {\n+        crate::list_partial_eq(self, value)\n+    }\n+}\n+\n+impl<T: FromReflect + TypePath + Clone + 'static> Typed for Cow<'static, [T]> {\n+    fn type_info() -> &'static TypeInfo {\n+        static CELL: GenericTypeInfoCell = GenericTypeInfoCell::new();\n+        CELL.get_or_insert::<Self, _>(|| TypeInfo::List(ListInfo::new::<Self, T>()))\n+    }\n+}\n+\n+impl<T: TypePath + Clone + 'static> TypePath for Cow<'static, [T]> {\n+    fn type_path() -> &'static str {\n+        static CELL: GenericTypePathCell = GenericTypePathCell::new();\n+        CELL.get_or_insert::<Self, _>(|| {\n+            format!(\"std::borrow::Cow::<[{}]>\", T::type_path())\n+        })\n+    }\n+\n+    fn short_type_path() -> &'static str {\n+        static CELL: GenericTypePathCell = GenericTypePathCell::new();\n+        CELL.get_or_insert::<Self, _>(|| {\n+            format!(\"Cow<[{}]>\", T::short_type_path())\n+        })\n+    }\n+}\n+\n+impl<T: FromReflect + TypePath + Clone + 'static> GetTypeRegistration for Cow<'static, [T]> {\n+    fn get_type_registration() -> TypeRegistration {\n+        let mut registration = TypeRegistration::of::<Cow<'static, [T]>>();\n+        registration.insert::<ReflectDeserialize>(FromType::<Cow<'static, [T]>>::from_type());\n+        registration.insert::<ReflectFromPtr>(FromType::<Cow<'static, [T]>>::from_type());\n+        registration.insert::<ReflectSerialize>(FromType::<Cow<'static, [T]>>::from_type());\n+        registration.insert::<ReflectFromReflect>(FromType::<Cow<'static, [T]>>::from_type());\n+        registration\n+    }\n+}\n+\n+impl<T: FromReflect + TypePath + Clone + 'static> FromReflect for Cow<'static, [T]> {\n+    fn from_reflect(reflect: &dyn Reflect) -> Option<Self> {\n+        reflect\n+            .as_any()\n+            .downcast_ref::<Cow<'static, [T]>>()\n+            .map(Clone::clone)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate as bevy_reflect;\n"}
{"instance_id": "rust-lang__cc-rs-991", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 6999d14..0beb5fa 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1278,6 +1278,18 @@ impl Build {\n             }\n         }\n \n+        // Link the atomic library on 32-bit Android to support atomic builtins.\n+        {\n+            let target = self.get_target()?;\n+            if target.contains(\"android\")\n+                && !target.contains(\"aarch64\")\n+                && !target.contains(\"x86_64\")\n+            {\n+                self.cargo_output\n+                    .print_metadata(&format_args!(\"cargo:rustc-link-lib=atomic\"));\n+            }\n+        }\n+\n         let cudart = match &self.cudart {\n             Some(opt) => &*opt, // {none|shared|static}\n             None => \"none\",\n"}
{"instance_id": "aya-rs__aya-774", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/aya/src/maps/mod.rs b/aya/src/maps/mod.rs\nindex cd082530..9746a36c 100644\n--- a/aya/src/maps/mod.rs\n+++ b/aya/src/maps/mod.rs\n@@ -176,6 +176,29 @@ pub enum MapError {\n     },\n }\n \n+// Now also expose TryFrom<Map> for LruHashMap itself:\n+impl<'a, V: Pod, K: Pod> TryFrom<&'a mut Map> for LruHashMap<&'a mut MapData, V, K> {\n+    type Error = MapError;\n+\n+    fn try_from(map: &'a mut Map) -> Result<LruHashMap<&'a mut MapData, V, K>, MapError> {\n+        match map {\n+            Map::LruHashMap(m) => LruHashMap::new(m),\n+            _ => Err(MapError::InvalidMapType { map_type: map.map_type() }),\n+        }\n+    }\n+}\n+\n+impl<V: Pod, K: Pod> TryFrom<Map> for LruHashMap<MapData, V, K> {\n+    type Error = MapError;\n+\n+    fn try_from(map: Map) -> Result<LruHashMap<MapData, V, K>, MapError> {\n+        match map {\n+            Map::LruHashMap(m) => LruHashMap::new(m),\n+            _ => Err(MapError::InvalidMapType { map_type: map.map_type() }),\n+        }\n+    }\n+}\n+\n /// A map file descriptor.\n pub struct MapFd(RawFd);\n \n"}
{"instance_id": "clap-rs__clap-2771", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/output/usage.rs b/src/output/usage.rs\nindex 7f2a3bb5..d73c31b6 100644\n--- a/src/output/usage.rs\n+++ b/src/output/usage.rs\n@@ -464,6 +464,12 @@ impl<'help, 'app, 'parser> Usage<'help, 'app, 'parser> {\n             }\n         }\n \n+        // Remove duplicate entries while preserving order\n+        {\n+            use std::collections::HashSet;\n+            let mut seen = HashSet::new();\n+            ret_val.retain(|item| seen.insert(item.clone()));\n+        }\n         debug!(\"Usage::get_required_usage_from: ret_val={:?}\", ret_val);\n         ret_val\n     }\n"}
{"instance_id": "sagiegurari__cargo-make-714", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib/types.rs b/src/lib/types.rs\nindex 4614a5db..7c5287bf 100755\n--- a/src/lib/types.rs\n+++ b/src/lib/types.rs\n@@ -227,13 +227,23 @@ impl Workspace {\n     }\n }\n \n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+/// Represents the package version, either a literal string or a workspace inheritance.\n+#[serde(untagged)]\n+pub enum PackageVersion {\n+    /// A literal version string, e.g. \"0.1.0\"\n+    Literal(String),\n+    /// Workspace inheritance flag, e.g. version.workspace = true\n+    Workspace { workspace: bool },\n+}\n+\n #[derive(Serialize, Deserialize, Debug, Clone, Default)]\n /// Holds crate package information loaded from the Cargo.toml file package section.\n pub struct PackageInfo {\n     /// name\n     pub name: Option<String>,\n-    /// version\n-    pub version: Option<String>,\n+    /// version, which may be a literal or a workspace\u2010map\n+    pub version: Option<PackageVersion>,\n     /// description\n     pub description: Option<String>,\n     /// license\n"}
{"instance_id": "tokio-rs__tracing-1297", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/tracing-attributes/src/lib.rs b/tracing-attributes/src/lib.rs\nindex 54f5efeb..beb8c49c 100644\n--- a/tracing-attributes/src/lib.rs\n+++ b/tracing-attributes/src/lib.rs\n@@ -296,6 +296,9 @@ pub fn instrument(\n                     }\n                 }\n                 break;\n+            } else {\n+                // preserve all statements coming before the async wrapper\n+                out_stmts.push(quote! { #stmt });\n             }\n         }\n \n"}
{"instance_id": "dtolnay__async-trait-90", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 20af33e..b7bed72 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -312,11 +312,27 @@ use crate::parse::Item;\n use proc_macro::TokenStream;\n use quote::quote;\n use syn::parse_macro_input;\n+use syn::{parse2, Error};\n+use proc_macro2::TokenStream as TokenStream2;\n \n #[proc_macro_attribute]\n pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n     let args = parse_macro_input!(args as Args);\n-    let mut item = parse_macro_input!(input as Item);\n+\n+    // Parse the input item, and give a helpful error if a trait-object is missing `dyn`\n+    let ts2: TokenStream2 = input.clone().into();\n+    let mut item = match parse2::<Item>(ts2.clone()) {\n+        Ok(it) => it,\n+        Err(err) => {\n+            let src = ts2.to_string();\n+            if src.contains(\"for Fn\") && !src.contains(\"dyn Fn\") {\n+                return Error::new(err.span(), \"trait objects must be written `dyn Fn(...) + ...` (missing `dyn`)\").to_compile_error().into();\n+            } else {\n+                return err.to_compile_error().into();\n+            }\n+        }\n+    };\n+\n     expand(&mut item, args.local);\n     TokenStream::from(quote!(#item))\n }\n"}
{"instance_id": "boa-dev__boa-746", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/boa/src/builtins/object/mod.rs b/boa/src/builtins/object/mod.rs\nindex 7c53dd4c..705ad305 100644\n--- a/boa/src/builtins/object/mod.rs\n+++ b/boa/src/builtins/object/mod.rs\n@@ -53,6 +53,7 @@ impl BuiltIn for Object {\n         .static_method(Self::set_prototype_of, \"setPrototypeOf\", 2)\n         .static_method(Self::get_prototype_of, \"getPrototypeOf\", 1)\n         .static_method(Self::define_property, \"defineProperty\", 3)\n+        .static_method(Self::define_properties, \"defineProperties\", 2)\n         .static_method(Self::is, \"is\", 2)\n         .build();\n \n@@ -88,15 +89,27 @@ impl Object {\n         let prototype = args.get(0).cloned().unwrap_or_else(Value::undefined);\n         let properties = args.get(1).cloned().unwrap_or_else(Value::undefined);\n \n-        if properties != Value::Undefined {\n-            unimplemented!(\"propertiesObject argument of Object.create\")\n-        }\n-\n         match prototype {\n-            Value::Object(_) | Value::Null => Ok(Value::object(BuiltinObject::with_prototype(\n-                prototype,\n-                ObjectData::Ordinary,\n-            ))),\n+            Value::Object(_) | Value::Null => {\n+                // 1. Create the new object with the given prototype.\n+                let obj = Value::object(BuiltinObject::with_prototype(\n+                    prototype.clone(),\n+                    ObjectData::Ordinary,\n+                ));\n+\n+                // 2. If a propertiesObject was provided and is not null/undefined, define its properties.\n+                if properties != Value::Undefined && properties != Value::Null {\n+                    // We ignore the returned Value; define_properties will modify `obj` in place.\n+                    Object::define_properties(\n+                        &Value::undefined(),\n+                        &[obj.clone(), properties.clone()],\n+                        interpreter,\n+                    )?;\n+                }\n+\n+                // 3. Return the newly created object.\n+                Ok(obj)\n+            }\n             _ => interpreter.throw_type_error(format!(\n                 \"Object prototype may only be an Object or null: {}\",\n                 prototype.display()\n"}
{"instance_id": "bevyengine__bevy-12997", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/bevy_asset/src/io/file/mod.rs b/crates/bevy_asset/src/io/file/mod.rs\nindex 19a9ffb0c..3bbc5074f 100644\n--- a/crates/bevy_asset/src/io/file/mod.rs\n+++ b/crates/bevy_asset/src/io/file/mod.rs\n@@ -1,9 +1,9 @@\n #[cfg(feature = \"file_watcher\")]\n mod file_watcher;\n \n-#[cfg(feature = \"multi-threaded\")]\n+#[cfg(feature = \"multi_threaded\")]\n mod file_asset;\n-#[cfg(not(feature = \"multi-threaded\"))]\n+#[cfg(not(feature = \"multi_threaded\"))]\n mod sync_file_asset;\n \n use bevy_utils::tracing::error;\ndiff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs\nindex 4b3be75ec..16dda847c 100644\n--- a/crates/bevy_asset/src/lib.rs\n+++ b/crates/bevy_asset/src/lib.rs\n@@ -62,11 +62,11 @@ use bevy_reflect::{FromReflect, GetTypeRegistration, Reflect, TypePath};\n use bevy_utils::{tracing::error, HashSet};\n use std::{any::TypeId, sync::Arc};\n \n-#[cfg(all(feature = \"file_watcher\", not(feature = \"multi-threaded\")))]\n+#[cfg(all(feature = \"file_watcher\", not(feature = \"multi_threaded\")))]\n compile_error!(\n     \"The \\\"file_watcher\\\" feature for hot reloading requires the \\\n-    \\\"multi-threaded\\\" feature to be functional.\\n\\\n-    Consider either disabling the \\\"file_watcher\\\" feature or enabling \\\"multi-threaded\\\"\"\n+     \\\"multi_threaded\\\" feature to be functional.\\n\\\n+     Consider either disabling the \\\"file_watcher\\\" feature or enabling \\\"multi_threaded\\\"\"\n );\n \n /// Provides \"asset\" loading and processing functionality. An [`Asset`] is a \"runtime value\" that is loaded from an [`AssetSource`],\n"}
{"instance_id": "clap-rs__clap-2135", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/output/help.rs b/src/output/help.rs\nindex 3ebac629..023cdcb9 100644\n--- a/src/output/help.rs\n+++ b/src/output/help.rs\n@@ -496,15 +496,27 @@ impl<'help, 'app, 'parser, 'writer> Help<'help, 'app, 'parser, 'writer> {\n                 \"Help::spec_vals: Found default value...[{:?}]\",\n                 a.default_vals\n             );\n-\n-            let pvs = a\n-                .default_vals\n-                .iter()\n-                .map(|&pvs| pvs.to_string_lossy())\n-                .collect::<Vec<_>>()\n-                .join(\" \");\n-\n-            spec_vals.push(format!(\"[default: {}]\", pvs));\n+  \n+let pvs = a  \n+    .default_vals  \n+    .iter()  \n+    .map(|&pvs| pvs.to_string_lossy())  \n+    .collect::<Vec<_>>()  \n+    .join(\" \");  \n+\n+// Escape control chars and wrap purely\u2010whitespace or escaped defaults in quotes  \n+let formatted_vals = {  \n+    let escaped = pvs.chars()  \n+        .flat_map(|c| c.escape_default())  \n+        .collect::<String>();  \n+    if escaped != pvs || pvs.trim().is_empty() {  \n+        format!(\"\\\"{}\\\"\", escaped)  \n+    } else {  \n+        escaped  \n+    }  \n+};  \n+\n+spec_vals.push(format!(\"[default: {}]\", formatted_vals));  \n         }\n         if !a.aliases.is_empty() {\n             debug!(\"Help::spec_vals: Found aliases...{:?}\", a.aliases);\n"}
{"instance_id": "biomejs__biome-3451", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/crates/biome_js_formatter/src/ts/lists/union_type_variant_list.rs b/crates/biome_js_formatter/src/ts/lists/union_type_variant_list.rs\nindex dff7004f4e..ec815cacb8 100644\n--- a/crates/biome_js_formatter/src/ts/lists/union_type_variant_list.rs\n+++ b/crates/biome_js_formatter/src/ts/lists/union_type_variant_list.rs\n@@ -140,10 +140,29 @@ impl Format<JsFormatContext> for FormatTypeVariant<'_> {\n \n         write!(f, [format_leading_comments(node.syntax())])?;\n \n-        if self.should_hug {\n-            write!(f, [format_node])?;\n-        } else {\n-            write!(f, [align(2, &format_node)])?;\n+        // Wrap `infer \u2026 extends` and conditional types in parens when\n+        // they appear inside a union, so we don't lose the extends\u2010clause\n+        match node {\n+            AnyTsType::TsInferType(_) | AnyTsType::TsConditionalType(_) => {\n+                // open paren\n+                write!(f, [text(\"(\")])?;\n+\n+                if self.should_hug {\n+                    write!(f, [format_node])?;\n+                } else {\n+                    write!(f, [align(2, &format_node)])?;\n+                }\n+\n+                // close paren\n+                write!(f, [text(\")\")])?;\n+            }\n+            _ => {\n+                if self.should_hug {\n+                    write!(f, [format_node])?;\n+                } else {\n+                    write!(f, [align(2, &format_node)])?;\n+                }\n+            }\n         }\n \n         // There are a few special cases for nodes which handle their own\n"}
{"instance_id": "mozilla__cbindgen-466", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/src/bindgen/library.rs b/src/bindgen/library.rs\nindex 5261ede..801352c 100644\n--- a/src/bindgen/library.rs\n+++ b/src/bindgen/library.rs\n@@ -55,7 +55,8 @@ impl Library {\n \n     pub fn generate(mut self) -> Result<Bindings, Error> {\n         self.remove_excluded();\n-        self.functions.sort_by(|x, y| x.path.cmp(&y.path));\n+        // preserve module declaration order; no alphabetical sort\n+        // self.functions.sort_by(|x, y| x.path.cmp(&y.path));\n         self.transfer_annotations();\n         self.simplify_standard_types();\n \n"}
{"instance_id": "tracel-ai__burn-799", "model_name_or_path": "o4-mini-2025-04-16", "model_patch": "diff --git a/burn-ndarray/src/ops/base.rs b/burn-ndarray/src/ops/base.rs\nindex 749ebaf7..85051b20 100644\n--- a/burn-ndarray/src/ops/base.rs\n+++ b/burn-ndarray/src/ops/base.rs\n@@ -416,11 +416,19 @@ where\n         tensor\n     }\n \n-    pub fn clamp<const D: usize>(\n+    pub fn clamp<const D: usize, MIN, MAX>(\n         mut tensor: NdArrayTensor<E, D>,\n-        min: E,\n-        max: E,\n-    ) -> NdArrayTensor<E, D> {\n+        min: MIN,\n+        max: MAX,\n+    ) -> NdArrayTensor<E, D>\n+    where\n+        MIN: Into<E> + Copy,\n+        MAX: Into<E> + Copy,\n+    {\n+        // convert into the tensor\u2019s element type\n+        let min = min.into();\n+        let max = max.into();\n+\n         tensor.array.mapv_inplace(|x| match x < min {\n             true => min,\n             false => match x > max {\ndiff --git a/burn-tch/src/ops/base.rs b/burn-tch/src/ops/base.rs\nindex 03b6f841..6783b742 100644\n--- a/burn-tch/src/ops/base.rs\n+++ b/burn-tch/src/ops/base.rs\n@@ -390,14 +390,21 @@ impl<E: tch::kind::Element + Copy + Default> TchOps<E> {\n         )\n     }\n \n-    pub fn clamp<const D: usize, S: Into<tch::Scalar> + Clone + Copy>(\n+    pub fn clamp<const D: usize, MIN, MAX>(\n         tensor: TchTensor<E, D>,\n-        min: S,\n-        max: S,\n-    ) -> TchTensor<E, D> {\n+        min: MIN,\n+        max: MAX,\n+    ) -> TchTensor<E, D>\n+    where\n+        MIN: Into<tch::Scalar> + Clone + Copy,\n+        MAX: Into<tch::Scalar> + Clone + Copy,\n+    {\n+        // convert into a tch::Scalar once\n+        let min_scalar = min.into();\n+        let max_scalar = max.into();\n         tensor.unary_ops(\n-            |mut tensor| tensor.clamp_(min, max),\n-            |tensor| tensor.clamp(min, max),\n+            |mut tensor| tensor.clamp_(min_scalar, max_scalar),\n+            |tensor| tensor.clamp(min_scalar, max_scalar),\n         )\n     }\n }\n"}
